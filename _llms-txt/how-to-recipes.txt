<SYSTEM>How-to Recipes: guided examples of adding features to an Astro project</SYSTEM>

# Astro recipes

> Short, focused how-to guides.

See guided examples of adding features to your Astro project. ## Official Recipes [Section titled ‚ÄúOfficial Recipes‚Äù](#official-recipes) Astro‚Äôs official recipes are short, focused how-to guides that walk a reader through completing a working example of a specific task. Recipes are a great way to add new features or behavior to your Astro project by following step-by-step instructions! * ### [Installing a Vite or Rollup plugin](/en/recipes/add-yaml-support/) Learn how you can import YAML data by adding a Rollup plugin to your project. * ### [Analyze bundle size](/en/recipes/analyze-bundle-size/) Learn how to analyze the bundle generated by Astro using \`rollup-plugin-visualizer\`. * ### [Build a custom image component](/en/recipes/build-custom-img-component/) Learn how to build a custom image component that supports media queries using the getImage function. * ### [Build forms with API routes](/en/recipes/build-forms-api/) Learn how to use JavaScript to send form submissions to an API Route. * ### [Build HTML forms in Astro pages](/en/recipes/build-forms/) Learn how to build HTML forms and handle submissions in your frontmatter. * ### [Use Bun with Astro](/en/recipes/bun/) Learn how to use Bun with your Astro site. * ### [Call endpoints from the server](/en/recipes/call-endpoints/) Learn how to call endpoints from the server in Astro. * ### [Verify a Captcha](/en/recipes/captcha/) Learn how to create an API route and fetch it from the client. * ### [Customize file names in the build output](/en/recipes/customizing-output-filenames/) Learn how to change the default naming pattern for your built assets like JavaScript, CSS, and images in Astro using Vite's Rollup options. * ### [Build your Astro site with Docker](/en/recipes/docker/) Learn how to build your Astro site using Docker. * ### [Dynamically import images](/en/recipes/dynamically-importing-images/) Learn how to dynamically import images using Vite's import.meta.glob function. * ### [Add icons to external links](/en/recipes/external-links/) Learn how to install a rehype plugin to add icons to external links in your Markdown files. * ### [Add i18n features](/en/recipes/i18n/) Use dynamic routing and content collections to add internationalization support to your Astro site. * ### [Create a dev toolbar app](/en/recipes/making-toolbar-apps/) Learn how to create a dev toolbar app for your site. * ### [Add last modified time](/en/recipes/modified-time/) Build a remark plugin to add the last modified time to your Markdown and MDX. * ### [Add reading time](/en/recipes/reading-time/) Build a remark plugin to add reading time to your Markdown or MDX files. * ### [Add an RSS feed](/en/recipes/rss/) Add an RSS feed to your Astro site to let users subscribe to your content. * ### [Share state between islands](/en/recipes/sharing-state-islands/) Learn how to share state across framework components with Nano Stores. * ### [Share state between Astro components](/en/recipes/sharing-state/) Learn how to share state across Astro components with Nano Stores. * ### [Using streaming to improve page performance](/en/recipes/streaming-improve-page-performance/) Learn how to use streaming to improve page performance. * ### [Style rendered Markdown with Tailwind Typography](/en/recipes/tailwind-rendered-markdown/) Learn how to use @tailwind/typography to style your rendered Markdown. ## Community Resources [Section titled ‚ÄúCommunity Resources‚Äù](#community-resources) Find more recipes written and submitted by the community at [Astro Tips](https://astro-tips.dev).

# Installing a Vite or Rollup plugin

> Learn how you can import YAML data by adding a Rollup plugin to your project.

Astro builds on top of Vite, and supports both Vite and Rollup plugins. This recipe uses a Rollup plugin to add the ability to import a YAML (`.yml`) file in Astro. ## Recipe [Section titled ‚ÄúRecipe‚Äù](#recipe) 1. Install `@rollup/plugin-yaml`: * npm ```shell npm install @rollup/plugin-yaml --save-dev ``` * pnpm ```shell pnpm add @rollup/plugin-yaml --save-dev ``` * Yarn ```shell yarn add @rollup/plugin-yaml --dev ``` 2. Import the plugin in your `astro.config.mjs` and add it to the Vite plugins array: astro.config.mjs ```diff import { defineConfig } from 'astro/config'; +import yaml from '@rollup/plugin-yaml'; export default defineConfig({ + vite: { + plugins: [yaml()] + } }); ``` 3. Finally, you can import YAML data using an `import` statement: ```js import yml from './data.yml'; ```

# Analyze bundle size

> Learn how to analyze the bundle generated by Astro using `rollup-plugin-visualizer`.

Understanding what is a part of an Astro bundle is important for improving site performance. Visualizing the bundle can give clues as to where changes can be made in your project to reduce the bundle size. ## Recipe [Section titled ‚ÄúRecipe‚Äù](#recipe) The [`rollup-plugin-visualizer` library](https://github.com/btd/rollup-plugin-visualizer) allows you to visualize and analyze your Rollup bundle to see which modules are taking up space. 1. Install `rollup-plugin-visualizer`: * npm ```shell npm install rollup-plugin-visualizer --save-dev ``` * pnpm ```shell pnpm add rollup-plugin-visualizer --save-dev ``` * Yarn ```shell yarn add rollup-plugin-visualizer --save-dev ``` 2. Add the plugin to the `astro.config.mjs` file: ```js // @ts-check import { defineConfig } from 'astro/config'; import { visualizer } from "rollup-plugin-visualizer"; export default defineConfig({ vite: { plugins: [visualizer({ emitFile: true, filename: "stats.html", })] } }); ``` 3. Run the build command: * npm ```shell npm run build ``` * pnpm ```shell pnpm build ``` * Yarn ```shell yarn build ``` 4. Find the `stats.html` file(s) for your project. This will be at the root of your `dist/` directory for entirely static sites and will allow you to see what is included in the bundle. If your Astro project uses on-demand rendering, you will have two `stats.html` files. One will be for the client, and the other for the server, and each will be located at the root of the `dist/client` and `dist/server/` directories. See [the Rollup Plugin Visualizer documentation](https://github.com/btd/rollup-plugin-visualizer#how-to-use-generated-files) for guidance on how to interpret these files, or configure specific options.

# Build a custom image component

> Learn how to build a custom image component that supports media queries using the getImage function.

Astro provides two built-in components that you can use to display and optimize your images. The `<Picture>` component allows you to display responsive images and work with different formats and sizes. The `<Image>` component will optimize your images and allow you to pass in different formats and quality properties. When you need options that the `<Picture>` and `<Image>` components do not currently support, you can use the `getImage()` function to create a custom component. In this recipe, you will use the [`getImage()` function](/en/guides/images/#generating-images-with-getimage) to create your own custom image component that displays different source images based on media queries. ## Recipe [Section titled ‚ÄúRecipe‚Äù](#recipe) 1. Create a new Astro component and import the `getImage()` function src/components/MyCustomImageComponent.astro ```astro --- import { getImage } from "astro:assets"; --- ``` 2. Create a new component for your custom image. `MyCustomComponent.astro` will receive three `props` from `Astro.props`. The `mobileImgUrl` and `desktopImgUrl` props are used for creating your image at different viewport sizes. The `alt` prop is used for the image‚Äôs alt text. These props will be passed wherever you render your custom image components. Add the following imports and define the props that you will use in your component. You can also use TypeScript to type the props. src/components/MyCustomImageComponent.astro ```diff --- import type { ImageMetadata } from "astro"; +import { getImage } from "astro:assets"; interface Props { mobileImgUrl: string | ImageMetadata; desktopImgUrl: string | ImageMetadata; alt: string; } +const { mobileImgUrl, desktopImgUrl, alt } = Astro.props; --- ``` 3. Define each of your responsive images by calling the `getImage()` function with your desired properties. src/components/MyCustomImageComponent.astro ```diff --- import type { ImageMetadata } from "astro"; import { getImage } from "astro:assets"; interface Props { mobileImgUrl: string | ImageMetadata; desktopImgUrl: string | ImageMetadata; alt: string; } const { mobileImgUrl, desktopImgUrl, alt } = Astro.props; +const mobileImg = await getImage({ src: mobileImgUrl, format: "webp", width: 200, height: 200, +}); +const desktopImg = await getImage({ src: desktopImgUrl, format: "webp", width: 800, height: 200, +}); --- ``` 4. Create a `<picture>` element that generates a `srcset` with your different images based on your desired media queries. src/components/MyCustomImageComponent.astro ```diff --- import type { ImageMetadata } from "astro"; import { getImage } from "astro:assets"; interface Props { mobileImgUrl: string | ImageMetadata; desktopImgUrl: string | ImageMetadata; alt: string; } const { mobileImgUrl, desktopImgUrl, alt } = Astro.props; const mobileImg = await getImage({ src: mobileImgUrl, format: "webp", width: 200, height: 200, }); const desktopImg = await getImage({ src: desktopImgUrl, format: "webp", width: 800, height: 200, }); --- <picture> <source media="(max-width: 799px)" srcset={mobileImg.src} /> <source media="(min-width: 800px)" srcset={desktopImg.src} /> <img src={desktopImg.src} alt={alt} /> </picture> ``` 5. Import and use `<MyCustomImageComponent />` in any `.astro` file. Be sure to pass the necessary props for generating two different images at the different viewport sizes: src/pages/index.astro ```astro --- import MyCustomImageComponent from "../components/MyCustomImageComponent.astro"; import mobileImage from "../images/mobile-profile-image.jpg"; import desktopImage from "../images/desktop-profile-image.jpg"; --- <MyCustomImageComponent mobileImgUrl={mobileImage} desktopImgUrl={desktopImage} alt="user profile picture" /> ```

# Build HTML forms in Astro pages

> Learn how to build HTML forms and handle submissions in your frontmatter.

Astro pages that are rendered on demand can both display and handle forms. In this recipe, you‚Äôll use a standard HTML form to submit data to the server. Your frontmatter script will handle the data on the server, sending no JavaScript to the client. ## Prerequisites [Section titled ‚ÄúPrerequisites‚Äù](#prerequisites) * An Astro project with a [server adapter](/en/guides/on-demand-rendering/#server-adapters) installed. ## Recipe [Section titled ‚ÄúRecipe‚Äù](#recipe) 1. Create or identify a `.astro` page which will contain your form and your handling code. For example, you could add a registration page: src/pages/register.astro ```astro --- --- <h1>Register</h1> ``` 2. Add a `<form>` tag with some inputs to the page. Each input should have a `name` attribute that describes the value of that input. Be sure to include a `<button>` or `<input type="submit">` element to submit the form. src/pages/register.astro ```astro --- --- <h1>Register</h1> <form> <label> Username: <input type="text" name="username" /> </label> <label> Email: <input type="email" name="email" /> </label> <label> Password: <input type="password" name="password" /> </label> <button>Submit</button> </form> ``` 3. Use [validation attributes](https://developer.mozilla.org/en-US/docs/Learn/Forms/Form_validation#using_built-in_form_validation) to provide basic client-side validation that works even if JavaScript is disabled. In this example, * `required` prevents form submission until the field is filled. * `minlength` sets a minimum required length for the input text. * `type="email"` also introduces validation that will only accept a valid email format. src/pages/register.astro ```astro --- --- <h1>Register</h1> <form> <label> Username: <input type="text" name="username" required /> </label> <label> Email: <input type="email" name="email" required /> </label> <label> Password: <input type="password" name="password" required minlength="6" /> </label> <button>Submit</button> </form> ``` 4. The form submission will cause the browser to request the page again. Change the form‚Äôs data transfer `method` to `POST` to send the form data as part of the `Request` body, rather than as URL parameters. src/pages/register.astro ```astro --- --- <h1>Register</h1> <form method="POST"> <label> Username: <input type="text" name="username" required /> </label> <label> Email: <input type="email" name="email" required /> </label> <label> Password: <input type="password" name="password" required minlength="6" /> </label> <button>Submit</button> </form> ``` 5. Check for the `POST` method in the frontmatter and access the form data using `Astro.request.formData()`. Wrap this in a `try ... catch` block to handle cases when the `POST` request wasn‚Äôt sent by a form and the `formData` is invalid. src/pages/register.astro ```diff --- +export const prerender = false; // Not needed in 'server' mode +if (Astro.request.method === "POST") { +try { +const data = await Astro.request.formData(); +const name = data.get("username"); +const email = data.get("email"); +const password = data.get("password"); +// Do something with the data + } catch (error) { +if (error instanceof Error) { + console.error(error.message); + } + } +} --- <h1>Register</h1> <form method="POST"> <label> Username: <input type="text" name="username" required /> </label> <label> Email: <input type="email" name="email" required /> </label> <label> Password: <input type="password" name="password" required minlength="6" /> </label> <button>Submit</button> </form> ``` 6. Validate the form data on the server. This should include the same validation done on the client to prevent malicious submissions to your endpoint and to support the rare legacy browser that doesn‚Äôt have form validation. It can also include validation that can‚Äôt be done on the client. For example, this example checks if the email is already in the database. Error messages can be sent back to the client by storing them in an `errors` object and accessing it in the template. src/pages/register.astro ```diff --- export const prerender = false; // Not needed in 'server' mode import { isRegistered, registerUser } from "../../data/users" import { isValidEmail } from "../../utils/isValidEmail"; +const errors = { username: "", email: "", password: "" }; if (Astro.request.method === "POST") { try { const data = await Astro.request.formData(); const name = data.get("username"); const email = data.get("email"); const password = data.get("password"); +if (typeof name !== "string" || name.length < 1) { + errors.username += "Please enter a username. "; + } +if (typeof email !== "string" || !isValidEmail(email)) { + errors.email += "Email is not valid. "; + } else if (await isRegistered(email)) { + errors.email += "Email is already registered. "; + } +if (typeof password !== "string" || password.length < 6) { + errors.password += "Password must be at least 6 characters. "; + } const hasErrors = Object.values(errors).some(msg => msg) if (!hasErrors) { await registerUser({name, email, password}); return Astro.redirect("/login"); } } catch (error) { if (error instanceof Error) { console.error(error.message); } } } --- <h1>Register</h1> <form method="POST"> <label> Username: <input type="text" name="username" /> </label> +{errors.username && <p>{errors.username}</p>} <label> Email: <input type="email" name="email" required /> </label> +{errors.email && <p>{errors.email}</p>} <label> Password: <input type="password" name="password" required minlength="6" /> </label> +{errors.password && <p>{errors.password}</p>} <button>Register</button> </form> ```

# Build forms with API routes

> Learn how to use JavaScript to send form submissions to an API Route.

An HTML form causes the browser to refresh the page or navigate to a new one. To send form data to an API endpoint instead, you must intercept the form submission using JavaScript. This recipe shows you how to send form data to an API endpoint and handle that data. ## Prerequisites [Section titled ‚ÄúPrerequisites‚Äù](#prerequisites) * A project with [an adapter for on-demand rendering](/en/guides/on-demand-rendering/) * A [UI Framework integration](/en/guides/framework-components/) installed ## Recipe [Section titled ‚ÄúRecipe‚Äù](#recipe) 1. Create a `POST` API endpoint at `/api/feedback` that will receive the form data. Use `request.formData()` to process it. Be sure to validate the form values before you use them. This example sends a JSON object with a message back to the client. src/pages/api/feedback.ts ```ts export const prerender = false; // Not needed in 'server' mode import type { APIRoute } from "astro"; export const POST: APIRoute = async ({ request }) => { const data = await request.formData(); const name = data.get("name"); const email = data.get("email"); const message = data.get("message"); // Validate the data - you'll probably want to do more than this if (!name || !email || !message) { return new Response( JSON.stringify({ message: "Missing required fields", }), { status: 400 } ); } // Do something with the data, then return a success response return new Response( JSON.stringify({ message: "Success!" }), { status: 200 } ); }; ``` 2. Create a form component using your UI framework. Each input should have a `name` attribute that describes the value of that input. Be sure to include a `<button>` or `<input type="submit">` element to submit the form. * Preact src/components/FeedbackForm.tsx ```tsx export default function Form() { return ( <form> <label> Name <input type="text" id="name" name="name" required /> </label> <label> Email <input type="email" id="email" name="email" required /> </label> <label> Message <textarea id="message" name="message" required /> </label> <button>Send</button> </form> ); } ``` * React src/components/FeedbackForm.tsx ```tsx export default function Form() { return ( <form> <label> Name <input type="text" id="name" name="name" required /> </label> <label> Email <input type="email" id="email" name="email" required /> </label> <label> Message <textarea id="message" name="message" required /> </label> <button>Send</button> </form> ); } ``` * Solid src/components/FeedbackForm.tsx ```tsx export default function Form() { return ( <form> <label> Name <input type="text" id="name" name="name" required /> </label> <label> Email <input type="email" id="email" name="email" required /> </label> <label> Message <textarea id="message" name="message" required /> </label> <button>Send</button> </form> ); } ``` * Svelte src/components/FeedbackForm.svelte ```svelte <form> <label> Name <input type="text" id="name" name="name" required /> </label> <label> Email <input type="email" id="email" name="email" required /> </label> <label> Message <textarea id="message" name="message" required /> </label> <button>Send</button> </form> ``` * Vue src/components/FeedbackForm.vue ```vue <template> <form> <label> Name <input type="text" id="name" name="name" required /> </label> <label> Email <input type="email" id="email" name="email" required /> </label> <label> Message <textarea id="message" name="message" required /> </label> <button>Send</button> </form> </template> ``` 3. Create a function that accepts a submit event, then pass it as a `submit` handler to your form. In the function: * Call `preventDefault()` on the event to override the browser‚Äôs default submission process. * Create a `FormData` object and send it in a `POST` request to your endpoint using `fetch()`. - Preact src/components/FeedbackForm.tsx ```diff +import { useState } from "preact/hooks"; export default function Form() { +const [responseMessage, setResponseMessage] = useState(""); +async function submit(e: SubmitEvent) { + e.preventDefault(); +const formData = new FormData(e.target as HTMLFormElement); +const response = await fetch("/api/feedback", { method: "POST", body: formData, }); +const data = await response.json(); +if (data.message) { +setResponseMessage(data.message); + } + } return ( <form onSubmit={submit}> <label> Name <input type="text" id="name" name="name" required /> </label> <label> Email <input type="email" id="email" name="email" required /> </label> <label> Message <textarea id="message" name="message" required /> </label> <button>Send</button> +{responseMessage && <p>{responseMessage}</p>} </form> ); } ``` - React src/components/FeedbackForm.tsx ```diff +import { useState } from "react"; +import type { FormEvent } from "react"; export default function Form() { +const [responseMessage, setResponseMessage] = useState(""); +async function submit(e: FormEvent<HTMLFormElement>) { + e.preventDefault(); +const formData = new FormData(e.target as HTMLFormElement); +const response = await fetch("/api/feedback", { method: "POST", body: formData, }); +const data = await response.json(); +if (data.message) { +setResponseMessage(data.message); + } + } return ( <form onSubmit={submit}> <label htmlFor="name"> Name <input type="text" id="name" name="name" autoComplete="name" required /> </label> <label htmlFor="email"> Email <input type="email" id="email" name="email" autoComplete="email" required /> </label> <label htmlFor="message"> Message <textarea id="message" name="message" autoComplete="off" required /> </label> <button>Send</button> +{responseMessage && <p>{responseMessage}</p>} </form> ); } ``` - Solid src/components/FeedbackForm.tsx ```diff +import { createSignal, createResource, Suspense } from "solid-js"; +async function postFormData(formData: FormData) { +const response = await fetch("/api/feedback", { method: "POST", body: formData, }); +const data = await response.json(); +return data; } export default function Form() { +const [formData, setFormData] = createSignal<FormData>(); +const [response] = createResource(formData, postFormData); +function submit(e: SubmitEvent) { + e.preventDefault(); +setFormData(new FormData(e.target as HTMLFormElement)); + } return ( <form onSubmit={submit}> <label> Name <input type="text" id="name" name="name" required /> </label> <label> Email <input type="email" id="email" name="email" required /> </label> <label> Message <textarea id="message" name="message" required /> </label> <button>Send</button> +<Suspense>{response() && <p>{response().message}</p>}</Suspense> </form> ); } ``` - Svelte src/components/FeedbackForm.svelte ```diff <script lang="ts"> +let responseMessage: string; +async function submit(e: SubmitEvent) { + e.preventDefault(); +const formData = new FormData(e.currentTarget as HTMLFormElement); +const response = await fetch("/api/feedback", { method: "POST", body: formData, }); +const data = await response.json(); + responseMessage = data.message; + } </script> <form on:submit={submit}> <label> Name <input type="text" id="name" name="name" required /> </label> <label> Email <input type="email" id="email" name="email" required /> </label> <label> Message <textarea id="message" name="message" required /> </label> <button>Send</button> + {#if responseMessage} <p>{responseMessage}</p> + {/if} </form> ``` - Vue src/components/FeedbackForm.vue ```diff <script setup lang="ts"> +import { ref } from "vue"; +const responseMessage = ref<string>(); +async function submit(e: Event) { + e.preventDefault(); +const formData = new FormData(e.currentTarget as HTMLFormElement); +const response = await fetch("/api/feedback", { method: "POST", body: formData, }); +const data = await response.json(); + responseMessage.value = data.message; +} </script> <template> <form @submit="submit"> <label> Name <input type="text" id="name" name="name" required /> </label> <label> Email <input type="email" id="email" name="email" required /> </label> <label> Message <textarea id="message" name="message" required /> </label> <button>Send</button> <p v-if="responseMessage">{{ responseMessage }}</p> </form> </template> ``` 4. Import and include your `<FeedbackForm />` component on a page. Be sure to use a `client:*` directive to ensure that the form logic is hydrated when you want it to be. * Preact src/pages/index.astro ```astro --- import FeedbackForm from "../components/FeedbackForm" --- <FeedbackForm client:load /> ``` * React src/pages/index.astro ```astro --- import FeedbackForm from "../components/FeedbackForm" --- <FeedbackForm client:load /> ``` * Solid src/pages/index.astro ```astro --- import FeedbackForm from "../components/FeedbackForm" --- <FeedbackForm client:load /> ``` * Svelte src/pages/index.astro ```astro --- import FeedbackForm from "../components/FeedbackForm.svelte" --- <FeedbackForm client:load /> ``` * Vue src/pages/index.astro ```astro --- import FeedbackForm from "../components/FeedbackForm.vue" --- <FeedbackForm client:load /> ```

# Use Bun with Astro

> Learn how to use Bun with your Astro site.

[Bun](https://bun.sh/) is an all-in-one JavaScript runtime & toolkit. See [Bun‚Äôs documentation](https://bun.sh/docs) for more information. Caution Using Bun with Astro may reveal rough edges. Some integrations may not work as expected. Consult [Bun‚Äôs official documentation for working with Astro](https://bun.sh/guides/ecosystem/astro) for details. If you have any problems using Bun, please [open an Issue on GitHub with Bun directly](https://github.com/oven-sh/bun/issues/new/choose). ## Prerequisites [Section titled ‚ÄúPrerequisites‚Äù](#prerequisites) * Bun installed locally on your machine. See the [installation instructions](https://bun.sh/docs/installation) in Bun‚Äôs official documentation. ## Create a new Astro project with Bun [Section titled ‚ÄúCreate a new Astro project with Bun‚Äù](#create-a-new-astro-project-with-bun) Create a new Astro project with Bun using the following `create-astro` command: ```bash bun create astro my-astro-project-using-bun ``` ## Install dependencies [Section titled ‚ÄúInstall dependencies‚Äù](#install-dependencies) If you skipped the ‚ÄúInstall dependencies?‚Äù step during the CLI wizard, then be sure to install your dependencies before continuing. ```bash bun install ``` ## Add Types [Section titled ‚ÄúAdd Types‚Äù](#add-types) Bun publishes the [`@types/bun`](https://www.npmjs.com/package/@types/bun) package, containing the runtime types for Bun. Install `@types/bun` using the following command: ```sh bun add -d @types/bun ``` ## CLI installation flags [Section titled ‚ÄúCLI installation flags‚Äù](#cli-installation-flags) ### Using integrations [Section titled ‚ÄúUsing integrations‚Äù](#using-integrations) You can also use any of the official Astro integrations with the `astro add` command: ```bash bun astro add react ``` ### Use a theme or starter template [Section titled ‚ÄúUse a theme or starter template‚Äù](#use-a-theme-or-starter-template) You can start a new Astro project based on an [official example](https://github.com/withastro/astro/tree/main/examples) or the main branch of any GitHub repository by passing a `--template` argument to the `create astro` command. Run the following command in your terminal, substituting the official Astro starter template name, or the GitHub username and repository of the theme you want to use: ```bash # create a new project with an official example bun create astro@latest --template <example-name> # create a new project based on a GitHub repository‚Äôs main branch bun create astro@latest --template <github-username>/<github-repo> ``` ## Develop and build [Section titled ‚ÄúDevelop and build‚Äù](#develop-and-build) To run the development server, use following command: ```bash bun run dev ``` ### Build and preview your site [Section titled ‚ÄúBuild and preview your site‚Äù](#build-and-preview-your-site) To build your site, use the following command: ```bash bun run build ``` When the build is finished, run the appropriate preview command (e.g. `bun run preview`) in your terminal and you can view the built version of your site locally in the same browser preview window. ## Testing [Section titled ‚ÄúTesting‚Äù](#testing) Bun ships with a fast, built-in, Jest-compatible test runner through the [`bun test` command](https://bun.sh/docs/cli/test). You can also use any other [testing tools for Astro](/en/guides/testing/). ## Official Resources [Section titled ‚ÄúOfficial Resources‚Äù](#official-resources) * [Build an app with Astro and Bun](https://bun.sh/guides/ecosystem/astro) ## Community Resources [Section titled ‚ÄúCommunity Resources‚Äù](#community-resources) Using Bun with Astro? Add your blog post or video to this page! * [Using Bun with Astro and Cloudflare Pages](https://handerson.hashnode.dev/using-bun-with-astro-and-cloudflare-pages) - blog post

# Call endpoints from the server

> Learn how to call endpoints from the server in Astro.

Endpoints can be used to serve many kinds of data. This recipe calls a server endpoint from a page‚Äôs component script to display a greeting, without requiring an additional fetch request. ## Prerequisites [Section titled ‚ÄúPrerequisites‚Äù](#prerequisites) * A project with [SSR](/en/guides/on-demand-rendering/) (output: ‚Äòserver‚Äô) enabled ## Recipe [Section titled ‚ÄúRecipe‚Äù](#recipe) 1. Create an endpoint in a new file `src/pages/api/hello.ts` that returns some data: src/pages/api/hello.ts ```ts import type { APIRoute } from 'astro' export const GET: APIRoute = () => { return new Response( JSON.stringify({ greeting: 'Hello', }), ) } ``` 2. On any Astro page, import the `GET()` method from the endpoint. Call it with the [`Astro` global](/en/reference/api-reference/) to provide the request context, and use the response on the page: src/pages/index.astro ```astro --- import { GET } from './api/hello.ts' let response = await GET(Astro) const data = await response.json() --- <h1>{data.greeting} world!</h1> ```

# Verify a Captcha

> Learn how to create an API route and fetch it from the client.

[Server endpoints](/en/guides/endpoints/#server-endpoints-api-routes) can be used as REST API endpoints to run functions such as authentications, database access, and verifications without exposing sensitive data to the client. In this recipe, an API route is used to verify Google reCAPTCHA v3 without exposing the secret to clients. ## Prerequisites [Section titled ‚ÄúPrerequisites‚Äù](#prerequisites) * A project with [SSR](/en/guides/on-demand-rendering/) (`output: 'server'`) enabled ## Recipe [Section titled ‚ÄúRecipe‚Äù](#recipe) 1. Create a `POST` endpoint that accepts recaptcha data, then verifies it with reCAPTCHA‚Äôs API. Here, you can safely define secret values or read environment variables. src/pages/recaptcha.js ```js export async function POST({ request }) { const data = await request.json(); const recaptchaURL = 'https://www.google.com/recaptcha/api/siteverify'; const requestHeaders = { 'Content-Type': 'application/x-www-form-urlencoded' }; const requestBody = new URLSearchParams({ secret: "YOUR_SITE_SECRET_KEY", // This can be an environment variable response: data.recaptcha // The token passed in from the client }); const response = await fetch(recaptchaURL, { method: "POST", headers: requestHeaders, body: requestBody.toString() }); const responseData = await response.json(); return new Response(JSON.stringify(responseData), { status: 200 }); } ``` 2. Access your endpoint using `fetch` from a client script: src/pages/index.astro ```astro <html> <head> <script is:inline src="https://www.google.com/recaptcha/api.js"></script> </head> <body> <button class="g-recaptcha" data-sitekey="PUBLIC_SITE_KEY" data-callback="onSubmit" data-action="submit"> Click me to verify the captcha challenge! </button> <script is:inline> function onSubmit(token) { fetch("/recaptcha", { method: "POST", body: JSON.stringify({ recaptcha: token }) }) .then((response) => response.json()) .then((gResponse) => { if (gResponse.success) { // Captcha verification was a success } else { // Captcha verification failed } }) } </script> </body> </html> ```

# Customize file names in the build output

> Learn how to change the default naming pattern for your built assets like JavaScript, CSS, and images in Astro using Vite's Rollup options.

By default, the `astro build` command outputs your built assets from [your project source](/en/basics/project-structure/#src), like JavaScript and CSS files located in the `src/` directory, into an `_astro` directory with hashed filenames (e.g. `_astro/index.DRf8L97S.js`) which are excellent for long-term caching. Although it is normally not necessary, you can customise the output file names when needed. For example, this can be helpful if you have scripts with names that might trigger ad blockers (e.g. `ads.js`), or if you want to organize your assets with a particular naming convention. By customizing Rollup output options, you can gain more control over your project‚Äôs build structure, allowing you to meet specific organizational or deployment requirements. ## Recipe [Section titled ‚ÄúRecipe‚Äù](#recipe) This recipe configures `vite.build.rollupOptions` to output built assets with the following structure and naming pattern: * JavaScript entry files (e.g. scripts directly associated with your pages or layouts): `dist/js/[name]-[hash].js` * JavaScript code-split chunks (e.g. dynamically imported components or shared modules): `dist/js/chunks/[name]-[hash].js` * Other assets (e.g. CSS, images, fonts): `dist/static/[name]-[hash][extname]` (e.g. `dist/static/styles-a1b2c3d4.css`, `dist/static/logo-e5f6g7h8.svg`) 1. Add Vite Rollup Output Options. Modify your `astro.config.mjs` to include the following `vite.build.rollupOptions.output` configuration. This is where you can define the custom naming patterns for your assets using Rollup‚Äôs [`entryFileNames`](https://rollupjs.org/configuration-options/#output-entryfilenames), [`chunkFileNames`](https://rollupjs.org/configuration-options/#output-chunkfilenames), and [`assetFileNames`](https://rollupjs.org/configuration-options/#output-assetfilenames): astro.config.mjs ```javascript import { defineConfig } from 'astro/config'; export default defineConfig({ // ... vite: { build: { rollupOptions: { output: { // path names relative to `outDir` entryFileNames: 'js/[name]-[hash].js', chunkFileNames: 'js/chunks/[name]-[hash].js', assetFileNames: 'static/[name]-[hash][extname]', }, }, }, }, }); ``` This example uses the following file name placeholders: * `[name]`: The original name of the file (without the extension and path). * `[hash]`: A content-based hash generated for the file, crucial for cache busting. You can also specify a length, e.g. `[hash:8]`. This ensures that when you update an asset, the filename changes, forcing browsers to download the new version instead of serving a stale cached version. * `[extname]`: The original file extension, including the leading dot (e.g. `.js`, `.css`, `.svg`). For a full list of available placeholders and advanced patterns for these options, refer to the [Rollup configuration documentation](https://rollupjs.org/configuration-options/). 2. Build your project. Since these filename customizations apply to the production build output only, you will need to run your project‚Äôs build command: * npm ```shell npm run build ``` * pnpm ```shell pnpm build ``` * Yarn ```shell yarn build ``` 3. After the build completes, inspect your [output directory](/en/reference/configuration-reference/#outdir) (`dist/` by default). Verify that the build assets from your project `src` are named and organized according to the new patterns. (Files from [your `public/` directory](/en/basics/project-structure/#public) are copied directly to the output directory and are not affected by these Rollup naming options.) Depending on your project‚Äôs specific contents, your build folder will now look something like this:

# Build your Astro site with Docker

> Learn how to build your Astro site using Docker.

[Docker](https://docker.com) is a tool to build, deploy, and run applications using containers. Docker images and containers can be deployed to many different platforms, like AWS, Azure, and [Google Cloud](/en/guides/deploy/google-cloud/#cloud-run-ssr-and-static). This recipe won‚Äôt cover how to deploy your site to a specific platform but will show you how to set up Docker for your project. ## Prerequisites [Section titled ‚ÄúPrerequisites‚Äù](#prerequisites) * Docker installed on your local machine. You can find [installation instructions for your operating system here](https://docs.docker.com/get-docker/). * A Dockerfile in your project. You can [learn more about Dockerfiles here](https://docs.docker.com/engine/reference/builder/) and use the Dockerfiles in the following section as a starting point. ## Creating a Dockerfile [Section titled ‚ÄúCreating a Dockerfile‚Äù](#creating-a-dockerfile) Create a file called `Dockerfile` in your project‚Äôs root directory. This file contains the instructions to build your site, which will differ depending on your needs. This guide can‚Äôt show all possible options but will give you starting points for SSR and static mode. If you‚Äôre using another package manager than npm, you‚Äôll need to adjust the commands accordingly. ### SSR [Section titled ‚ÄúSSR‚Äù](#ssr) This Dockerfile will build your site and serve it using Node.js on port `4321` and therefore requires the [Node adapter](/en/guides/integrations-guide/node/) installed in your Astro project. Dockerfile ```docker FROM node:lts AS runtime WORKDIR /app COPY . . RUN npm install RUN npm run build ENV HOST=0.0.0.0 ENV PORT=4321 EXPOSE 4321 CMD ["node", "./dist/server/entry.mjs"] ``` ### Adding a .dockerignore [Section titled ‚ÄúAdding a .dockerignore‚Äù](#adding-a-dockerignore) Adding a `.dockerignore` file to your project is best practice. This file describes which files or folders should be ignored in the Docker `COPY` or `ADD` commands, very similar to how `.gitignore` works. This speeds up the build process and reduces the size of the final image. .dockerignore ```docker .DS_Store node_modules dist ``` This file should go in the same directory as the `Dockerfile` itself. [Read the `.dockerignore` documentation for extra info](https://docs.docker.com/engine/reference/builder/#dockerignore-file) ### Static [Section titled ‚ÄúStatic‚Äù](#static) #### Apache (httpd) [Section titled ‚ÄúApache (httpd)‚Äù](#apache-httpd) The following Dockerfile will build your site and serve it using Apache httpd on port `80` with the default configuration. Dockerfile ```docker FROM node:lts AS build WORKDIR /app COPY . . RUN npm i RUN npm run build FROM httpd:2.4 AS runtime COPY --from=build /app/dist /usr/local/apache2/htdocs/ EXPOSE 80 ``` Recommendation Use this approach for simple websites that don‚Äôt need any special configuration. For more complex websites, it is recommended to use a custom configuration, either in Apache or NGINX. #### NGINX [Section titled ‚ÄúNGINX‚Äù](#nginx) Dockerfile ```docker FROM node:lts AS build WORKDIR /app COPY package*.json ./ RUN npm install COPY . . RUN npm run build FROM nginx:alpine AS runtime COPY ./nginx/nginx.conf /etc/nginx/nginx.conf COPY --from=build /app/dist /usr/share/nginx/html EXPOSE 8080 ``` In order to build the Dockerfile above, you‚Äôll also need to create a configuration file for NGINX. Create a folder called `nginx` in your project‚Äôs root directory and create a file called `nginx.conf` inside. nginx.conf ```nginx worker_processes 1; events { worker_connections 1024; } http { server { listen 8080; server_name _; root /usr/share/nginx/html; index index.html index.htm; include /etc/nginx/mime.types; gzip on; gzip_min_length 1000; gzip_proxied expired no-cache no-store private auth; gzip_types text/plain text/css application/json application/javascript application/x-javascript text/xml application/xml application/xml+rss text/javascript; error_page 404 /404.html; location = /404.html { root /usr/share/nginx/html; internal; } location / { try_files $uri $uri/index.html =404; } } } ``` ### Multi-stage build (using SSR) [Section titled ‚ÄúMulti-stage build (using SSR)‚Äù](#multi-stage-build-using-ssr) Here‚Äôs an example of a more advanced Dockerfile that, thanks to Docker‚Äôs [multi-stage builds](https://docs.docker.com/build/building/multi-stage/), optimizes the build process for your site by not reinstalling the npm dependencies when only the source code changes. This can reduce the build time even by minutes, depending on the size of your dependencies. Dockerfile ```docker FROM node:lts AS base WORKDIR /app # By copying only the package.json and package-lock.json here, we ensure that the following `-deps` steps are independent of the source code. # Therefore, the `-deps` steps will be skipped if only the source code changes. COPY package.json package-lock.json ./ FROM base AS prod-deps RUN npm install --omit=dev FROM base AS build-deps RUN npm install FROM build-deps AS build COPY . . RUN npm run build FROM base AS runtime COPY --from=prod-deps /app/node_modules ./node_modules COPY --from=build /app/dist ./dist ENV HOST=0.0.0.0 ENV PORT=4321 EXPOSE 4321 CMD ["node", "./dist/server/entry.mjs"] ``` ## Recipe [Section titled ‚ÄúRecipe‚Äù](#recipe) 1. Build your container by running the following command in your project‚Äôs root directory. Use any name for `<your-astro-image-name>`: ```bash docker build -t <your-astro-image-name> . ``` This will output an image, which you can run locally or deploy to a platform of your choice. 2. To run your image as a local container, use the following command. Replace `<local-port>` with an open port on your machine. Replace `<container-port>` with the port exposed by your Docker container (`4321`, `80`, or `8080` in the above examples.) ```bash docker run -p <local-port>:<container-port> <your-astro-image-name> ``` You should be able to access your site at `http://localhost:<local-port>`. 3. Now that your website is successfully built and packaged in a container, you can deploy it to a cloud provider. See the [Google Cloud](/en/guides/deploy/google-cloud/#cloud-run-ssr-and-static) deployment guide for one example, and the [Deploy your app](https://docs.docker.com/language/nodejs/deploy/) page in the Docker docs.

# Dynamically import images

> Learn how to dynamically import images using Vite's import.meta.glob function.

Local [images](/en/guides/images/) must be imported into `.astro` files in order to display them. There will be times where you will want or need to dynamically import the image paths of your images instead of explicitly importing each individual image. In this recipe, you will learn how to dynamically import your images using Vite‚Äôs `import.meta.glob` function. You will build a card component that displays the name, age, and photo of a person. ## Recipe [Section titled ‚ÄúRecipe‚Äù](#recipe) 1. Create a new `assets` folder under the `src` directory and add your images inside that new folder. 2. Create a new Astro component for your card and import the `<Image />` component. src/components/MyCustomCardComponent.astro ```astro --- import { Image } from 'astro:assets'; --- ``` 3. Specify the `props` that your component will receive in order to display the necessary information on each card. You can optionally define their types, if you are using TypeScript in your project. src/components/MyCustomCardComponent.astro ```diff --- import { Image } from 'astro:assets'; +interface Props { + imagePath: string; + altText: string; + name: string; + age: number; +} +const { imagePath, altText, name, age } = Astro.props; --- ``` 4. Create a new `images` variable and use the `import.meta.glob` function which returns an object of all of the image paths inside the `assets` folder. You will also need to import `ImageMetadata` type to help define the type of the `images` variable. src/components/MyCustomCardComponent.astro ```diff --- +import type { ImageMetadata } from 'astro'; import { Image } from 'astro:assets'; interface Props { imagePath: string; altText: string; name: string; age: number; } const { imagePath, altText, name, age } = Astro.props; +const images = import.meta.glob<{ default: ImageMetadata }>('/src/assets/*.{jpeg,jpg,png,gif}') --- ``` 5. Use the props to create the markup for your card component. src/components/MyCustomCardComponent.astro ```diff --- import type { ImageMetadata } from 'astro'; import { Image } from 'astro:assets'; interface Props { imagePath: string; altText: string; name: string; age: number; } const { imagePath, altText, name, age } = Astro.props; const images = import.meta.glob<{ default: ImageMetadata }>('/src/assets/*.{jpeg,jpg,png,gif}'); --- <div class="card"> <h2>{name}</h2> <p>Age: {age}</p> +<Image src={} alt={altText} /> </div> ``` 6. Inside the `src` attribute, pass in the `images` object and use bracket notation for the image path. Then make sure to invoke the glob function. Since you are accessing the `images` object which has an unknown type, you should also `throw` an error in case an invalid file path is passed as a prop. src/components/MyCustomCardComponent.astro ```diff --- import type { ImageMetadata } from 'astro'; import { Image } from 'astro:assets'; interface Props { imagePath: string; altText: string; name: string; age: number; } const { imagePath, altText, name, age } = Astro.props; const images = import.meta.glob<{ default: ImageMetadata }>('/src/assets/*.{jpeg,jpg,png,gif}'); +if (!images[imagePath]) throw new Error(`"${imagePath}" does not exist in glob: "src/assets/*.{jpeg,jpg,png,gif}"`); --- <div class="card"> <h2>{name}</h2> <p>Age: {age}</p> <Image src={images[imagePath]()} alt={altText} /> </div> ``` 7. Import and use the card component inside an Astro page, passing in the values for the `props`. src/pages/index.astro ```astro --- import MyCustomCardComponent from '../components/MyCustomCardComponent.astro'; --- <MyCustomCardComponent imagePath="/src/assets/avatar-1.jpg" altText="A headshot of Priya against a brick wall background." name="Priya" age={25} /> ```

# Add icons to external links

> Learn how to install a rehype plugin to add icons to external links in your Markdown files.

Using a rehype plugin, you can identify and modify links in your Markdown files that point to external sites. This example adds icons to the end of each external link, so that visitors will know they are leaving your site. ## Prerequisites [Section titled ‚ÄúPrerequisites‚Äù](#prerequisites) * An Astro project using Markdown for content pages. ## Recipe [Section titled ‚ÄúRecipe‚Äù](#recipe) 1. Install the `rehype-external-links` plugin. * npm ```shell npm install rehype-external-links ``` * pnpm ```shell pnpm add rehype-external-links ``` * Yarn ```shell yarn add rehype-external-links ``` 2. Import the plugin into your `astro.config.mjs` file. Pass `rehypeExternalLinks` to the `rehypePlugins` array, along with an options object that includes a content property. Set this property‚Äôs `type` to `text` if you want to add plain text to the end of the link. To add HTML to the end of the link instead, set the property `type` to `raw`. ```ts // ... import rehypeExternalLinks from 'rehype-external-links'; export default defineConfig({ // ... markdown: { rehypePlugins: [ [ rehypeExternalLinks, { content: { type: 'text', value: ' üîó' } } ], ] }, }); ``` ## Resources [Section titled ‚ÄúResources‚Äù](#resources) * [rehype-external-links](https://www.npmjs.com/package/rehype-external-links)

# Add i18n features

> Use dynamic routing and content collections to add internationalization support to your Astro site.

In this recipe, you will learn how to use content collections and dynamic routing to build your own internationalization (i18n) solution and serve your content in different languages. This example serves each language at its own subpath, e.g. `example.com/en/blog` for English and `example.com/fr/blog` for French. If you prefer the default language to not be visible in the URL unlike other languages, there are [instructions to hide the default language](/en/recipes/i18n/#hide-default-language-in-the-url) below. See the [resources section](#resources) for external links to related topics such as right-to-left (RTL) styling and choosing language tags. ## Recipe [Section titled ‚ÄúRecipe‚Äù](#recipe) ### Set up pages for each language [Section titled ‚ÄúSet up pages for each language‚Äù](#set-up-pages-for-each-language) 1. Create a directory for each language you want to support. For example, `en/` and `fr/` if you are supporting English and French: 2. Set up `src/pages/index.astro` to redirect to your default language. * Static src/pages/index.astro ```astro <meta http-equiv="refresh" content="0;url=/en/" /> ``` This approach uses a [meta refresh](https://en.wikipedia.org/wiki/Meta_refresh) and will work however you deploy your site. Some static hosts also let you configure server redirects with a custom configuration file. See your deploy platform‚Äôs documentation for more details. * On demand If you are using an SSR adapter, you can use [`Astro.redirect`](/en/guides/routing/#dynamic-redirects) to redirect to the default language on the server. src/pages/index.astro ```astro --- return Astro.redirect('/en/'); --- ``` ### Use collections for translated content [Section titled ‚ÄúUse collections for translated content‚Äù](#use-collections-for-translated-content) 1. Create a folder in `src/content/` for each type of content you want to include and add subdirectories for each supported language. For example, to support English and French blog posts: 2. Create a `src/content.config.ts` file and export a collection for each type of content. src/content.config.ts ```ts import { defineCollection } from 'astro:content'; import { z } from 'astro/zod'; const blogCollection = defineCollection({ schema: z.object({ title: z.string(), author: z.string(), date: z.date() }) }); export const collections = { 'blog': blogCollection }; ``` Read more about [Content Collections](/en/guides/content-collections/). 3. Use [dynamic routes](/en/guides/routing/#dynamic-routes) to fetch and render content based on a `lang` and a `slug` parameter. * Static In static rendering mode, use `getStaticPaths` to map each content entry to a page: src/pages/\[lang]/blog/\[...slug].astro ```astro --- import { getCollection, render } from 'astro:content'; export async function getStaticPaths() { const pages = await getCollection('blog'); const paths = pages.map(page => { const [lang, ...slug] = page.id.split('/'); return { params: { lang, slug: slug.join('/') || undefined }, props: page }; }); return paths; } const { lang, slug } = Astro.params; const page = Astro.props; const formattedDate = page.data.date.toLocaleString(lang); const { Content } = await render(page); --- <h1>{page.data.title}</h1> <p>by {page.data.author} ‚Ä¢ {formattedDate}</p> <Content/> ``` * On demand In [SSR mode](/en/guides/on-demand-rendering/), fetch the requested entry directly: src/pages/\[lang]/blog/\[...slug].astro ```astro --- import { getEntry, render } from 'astro:content'; const { lang, slug } = Astro.params; const page = await getEntry('blog', `${lang}/${slug}`); if (!page) { return Astro.redirect('/404'); } const formattedDate = page.data.date.toLocaleString(lang); const { Content, headings } = await render(page); --- <h1>{page.data.title}</h1> <p>by {page.data.author} ‚Ä¢ {formattedDate}</p> <Content/> ``` Read more about [dynamic routing](/en/guides/routing/#dynamic-routes). ### Translate UI strings [Section titled ‚ÄúTranslate UI strings‚Äù](#translate-ui-strings) Create dictionaries of terms to translate the labels for UI elements around your site. This allows your visitors to experience your site fully in their language. 1. Create a `src/i18n/ui.ts` file to store your translation strings: src/i18n/ui.ts ```ts export const languages = { en: 'English', fr: 'Fran√ßais', }; export const defaultLang = 'en'; export const ui = { en: { 'nav.home': 'Home', 'nav.about': 'About', 'nav.twitter': 'Twitter', }, fr: { 'nav.home': 'Accueil', 'nav.about': '√Ä propos', }, } as const; ``` 2. Create two helper functions: one to detect the page language based on the current URL, and one to get translations strings for different parts of the UI in `src/i18n/utils.ts`: src/i18n/utils.ts ```js import { ui, defaultLang } from './ui'; export function getLangFromUrl(url: URL) { const [, lang] = url.pathname.split('/'); if (lang in ui) return lang as keyof typeof ui; return defaultLang; } export function useTranslations(lang: keyof typeof ui) { return function t(key: keyof typeof ui[typeof defaultLang]) { return ui[lang][key] || ui[defaultLang][key]; } } ``` 3. Import the helpers where needed and use them to choose the UI string that corresponds to the current language. For example, a nav component might look like: src/components/Nav.astro ```astro --- import { getLangFromUrl, useTranslations } from '../i18n/utils'; const lang = getLangFromUrl(Astro.url); const t = useTranslations(lang); --- <ul> <li> <a href={`/${lang}/home/`}> {t('nav.home')} </a> </li> <li> <a href={`/${lang}/about/`}> {t('nav.about')} </a> </li> <li> <a href="https://twitter.com/astrodotbuild"> {t('nav.twitter')} </a> </li> </ul> ``` 4. Each page must have a `lang` attribute on the `<html>` element that matches the language on the page. In this example, a [reusable layout](/en/basics/layouts/) extracts the language from the current route: src/layouts/Base.astro ```astro --- import { getLangFromUrl } from '../i18n/utils'; const lang = getLangFromUrl(Astro.url); --- <html lang={lang}> <head> <meta charset="utf-8" /> <link rel="icon" type="image/svg+xml" href="/favicon.svg" /> <meta name="viewport" content="width=device-width" /> <title>Astro</title> </head> <body> <slot /> </body> </html> ``` You can then use this base layout to ensure that pages use the correct `lang` attribute automatically. src/pages/en/about.astro ```astro --- import Base from '../../layouts/Base.astro'; --- <Base> <h1>About me</h1> ... </Base> ``` ### Let users switch between languages [Section titled ‚ÄúLet users switch between languages‚Äù](#let-users-switch-between-languages) Create links to the different languages you support so users can choose the language they want to read your site in. 1. Create a component to show a link for each language: src/components/LanguagePicker.astro ```astro --- import { languages } from '../i18n/ui'; --- <ul> {Object.entries(languages).map(([lang, label]) => ( <li> <a href={`/${lang}/`}>{label}</a> </li> ))} </ul> ``` 2. Add `<LanguagePicker />` to your site so it is shown on every page. The example below adds it to the site footer in a base layout: src/layouts/Base.astro ```diff --- +import LanguagePicker from '../components/LanguagePicker.astro'; import { getLangFromUrl } from '../i18n/utils'; const lang = getLangFromUrl(Astro.url); --- <html lang={lang}> <head> <meta charset="utf-8" /> <link rel="icon" type="image/svg+xml" href="/favicon.svg" /> <meta name="viewport" content="width=device-width" /> <title>Astro</title> </head> <body> <slot /> <footer> +<LanguagePicker /> </footer> </body> </html> ``` ### Hide default language in the URL [Section titled ‚ÄúHide default language in the URL‚Äù](#hide-default-language-in-the-url) 1. Create a directory for each language except the default language. For example, store your default language pages directly in `pages/`, and your translated pages in `fr/`: 2. Add another line to the `src/i18n/ui.ts` file to toggle the feature: src/i18n/ui.ts ```ts export const showDefaultLang = false; ``` 3. Add a helper function to `src/i18n/utils.ts`, to translate paths based on the current language: src/i18n/utils.ts ```js import { ui, defaultLang, showDefaultLang } from './ui'; export function useTranslatedPath(lang: keyof typeof ui) { return function translatePath(path: string, l: string = lang) { return !showDefaultLang && l === defaultLang ? path : `/${l}${path}` } } ``` 4. Import the helper where needed. For example, a `nav` component might look like: src/components/Nav.astro ```astro --- import { getLangFromUrl, useTranslations, useTranslatedPath } from '../i18n/utils'; const lang = getLangFromUrl(Astro.url); const t = useTranslations(lang); const translatePath = useTranslatedPath(lang); --- <ul> <li> <a href={translatePath('/home/')}> {t('nav.home')} </a> </li> <li> <a href={translatePath('/about/')}> {t('nav.about')} </a> </li> <li> <a href="https://twitter.com/astrodotbuild"> {t('nav.twitter')} </a> </li> </ul> ``` 5. The helper function can also be used to translate paths for a specific language. For example, when users switch between languages: src/components/LanguagePicker.astro ```astro --- import { languages } from '../i18n/ui'; import { getLangFromUrl, useTranslatedPath } from '../i18n/utils'; const lang = getLangFromUrl(Astro.url); const translatePath = useTranslatedPath(lang); --- <ul> {Object.entries(languages).map(([lang, label]) => ( <li> <a href={translatePath('/', lang)}>{label}</a> </li> ))} </ul> ``` ### Translate Routes [Section titled ‚ÄúTranslate Routes‚Äù](#translate-routes) Translate the routes of your pages for each language. 1. Add route mappings to `src/i18n/ui.ts`: src/i18n/ui.ts ```ts export const routes = { de: { 'services': 'leistungen', }, fr: { 'services': 'prestations-de-service', }, } ``` 2. Update the `useTranslatedPath` helper function in `src/i18n/utils.ts` to add router translation logic. src/i18n/utils.ts ```js import { ui, defaultLang, showDefaultLang, routes } from './ui'; export function useTranslatedPath(lang: keyof typeof ui) { return function translatePath(path: string, l: string = lang) { const pathName = path.replaceAll('/', '') const hasTranslation = defaultLang !== l && routes[l] !== undefined && routes[l][pathName] !== undefined const translatedPath = hasTranslation ? '/' + routes[l][pathName] : path return !showDefaultLang && l === defaultLang ? translatedPath : `/${l}${translatedPath}` } } ``` 3. Create a helper function to get the route, if it exists based on the current URL, in `src/i18n/utils.ts`: src/i18n/utils.ts ```js import { ui, defaultLang, showDefaultLang, routes } from './ui'; export function getRouteFromUrl(url: URL): string | undefined { const pathname = new URL(url).pathname; const parts = pathname?.split('/'); const path = parts.pop() || parts.pop(); if (path === undefined) { return undefined; } const currentLang = getLangFromUrl(url); if (defaultLang === currentLang) { const route = Object.values(routes)[0]; return route[path] !== undefined ? route[path] : undefined; } const getKeyByValue = (obj: Record<string, string>, value: string): string | undefined => { return Object.keys(obj).find((key) => obj[key] === value); } const reversedKey = getKeyByValue(routes[currentLang], path); if (reversedKey !== undefined) { return reversedKey; } return undefined; } ``` 4. The helper function can be used to get a translated route. For example, when no translated route is defined, the user will be redirected to the home page: src/components/LanguagePicker.astro ```astro --- import { languages } from '../i18n/ui'; import { getRouteFromUrl, useTranslatedPath } from '../i18n/utils'; const route = getRouteFromUrl(Astro.url); --- <ul> {Object.entries(languages).map(([lang, label]) => { const translatePath = useTranslatedPath(lang); return ( <li> <a href={translatePath(`/${route ? route : ''}`)}>{label}</a> </li> ) })} </ul> ``` ## Resources [Section titled ‚ÄúResources‚Äù](#resources) * [Choosing a Language Tag](https://www.w3.org/International/questions/qa-choosing-language-tags) * [Right-to-left (RTL) Styling 101](https://rtlstyling.com/) ## Community libraries [Section titled ‚ÄúCommunity libraries‚Äù](#community-libraries) Find [community-built i18n utilities](https://astro.build/integrations/?search=i18n) that you can add to your Astro project in our integrations directory.

# Create a dev toolbar app

> Learn how to create a dev toolbar app for your site.

Astro includes a [development toolbar](/en/guides/dev-toolbar/) that you can use to inspect your site, check for accessibility and performance issues, and more. This toolbar can be extended with custom apps. ## Build a motivational dev toolbar app [Section titled ‚ÄúBuild a motivational dev toolbar app‚Äù](#build-a-motivational-dev-toolbar-app) In this recipe, you‚Äôll learn how to create a dev toolbar app that helps you stay motivated while working on your site. This app will display a motivational message every time you toggle it on. ### Creating the Astro integration [Section titled ‚ÄúCreating the Astro integration‚Äù](#creating-the-astro-integration) Dev toolbar apps can only be added by [Astro Integrations](/en/guides/integrations-guide/) using [the `astro:config:setup` hook](/en/reference/integrations-reference/#astroconfigsetup). You will need to create both a toolbar app and the integration that will add it to the toolbar of your existing Astro project. 1. In the root of your existing Astro project, create a new folder named `my-toolbar-app/` for your app and integration files. Create two new files in this folder: `app.ts` and `my-integration.ts`. * astro.config.mjs * package.json * tsconfig.json 2. In `my-integration.ts`, add the following code to provide both the name of your integration and the [`addDevToolbarApp()` function](/en/reference/dev-toolbar-app-reference/#toolbar-app-integration-setup) needed to add your dev toolbar app with the `astro:config:setup` hook: my-toolbar-app/my-integration.ts ```ts import { fileURLToPath } from 'node:url'; import type { AstroIntegration } from 'astro'; export default { name: 'my-astro-integration', hooks: { 'astro:config:setup': ({ addDevToolbarApp }) => { addDevToolbarApp({ id: "my-toolbar-app", name: "My Toolbar App", icon: "üöÄ", entrypoint: fileURLToPath(new URL('./app.ts', import.meta.url)) }); }, }, } satisfies AstroIntegration; ``` 3. To use this integration in your project, add it to the `integrations` array in your `astro.config.mjs` file. astro.config.mjs ```diff import { defineConfig } from 'astro/config'; +import myIntegration from './my-toolbar-app/my-integration.ts'; export default defineConfig({ + integrations: [myIntegration], }) ``` 4. If not already running, start the dev server. If your integration has been successfully added to your project, you should see a new ‚Äúundefined‚Äù app in the dev toolbar. But, you will also see an error message that your dev toolbar app has failed to load. This is because you have not yet built the app itself. You will do that in the next section. See the [Astro Integration API documentation](/en/reference/integrations-reference/) for more about building Astro integrations. ### Creating the app [Section titled ‚ÄúCreating the app‚Äù](#creating-the-app) Dev toolbar apps are defined using the `defineToolbarApp()` function from the `astro/toolbar` module. This function takes an object with an `init()` function that will be called when the dev toolbar app is loaded. This `init()` function contains your app logic to render elements to the screen, send and receive client-side events from the dev toolbar, and communicate with the server. app.ts ```ts import { defineToolbarApp } from "astro/toolbar"; export default defineToolbarApp({ init(canvas, app, server) { // ... }, }); ``` To display motivational messages on the screen, you will use the `canvas` property to access a standard [ShadowRoot](https://developer.mozilla.org/en-US/docs/Web/API/ShadowRoot). Elements can be created and added to the ShadowRoot using the standard DOM APIs. 1. Copy the following code into `my-toolbar-app/app.ts`. This provides a list of motivational messages, and the logic to create a new `<h1>` element with a random message: my-toolbar-app/app.ts ```ts import { defineToolbarApp } from "astro/toolbar"; const motivationalMessages = [ "You're doing great!", "Keep up the good work!", "You're awesome!", "You're a star!", ]; export default defineToolbarApp({ init(canvas) { const h1 = document.createElement('h1'); h1.textContent = motivationalMessages[Math.floor(Math.random() * motivationalMessages.length)]; canvas.append(h1); }, }); ``` 2. Start the dev server if it is not already running and toggle the app on in the dev toolbar. If your app is working successfully, you will see a motivational message displayed in the top-left corner of the screen. (And, it‚Äôs true!) However, this message will not change when the app is toggled on and off, as the `init()` function is only called once when the app is loaded. 3. To add client-side interactivity to your app, add the `app` argument and use `onAppToggled()` to select a new random message each time your toolbar app is toggled on: app.ts ```diff import { defineToolbarApp } from "astro/toolbar"; const motivationalMessages = [ "You're doing great!", "Keep up the good work!", "You're awesome!", "You're a star!", ]; export default defineToolbarApp({ init(canvas, app) { const h1 = document.createElement('h1'); h1.textContent = motivationalMessages[Math.floor(Math.random() * motivationalMessages.length)]; canvas.append(h1); +// Display a random message when the app is toggled + app.onToggled(({ state }) => { +const newMessage = motivationalMessages[Math.floor(Math.random() * motivationalMessages.length)]; + h1.textContent = newMessage; + }); }, }); ``` 4. In your browser preview, toggle your app on and off several times. With this change, a new random message will be selected every time you toggle the app on, providing you with an infinite source of motivation! See the [Astro Dev Toolbar API documentation](/en/reference/dev-toolbar-app-reference/) for more about building dev toolbar apps. ## Building apps with a UI framework [Section titled ‚ÄúBuilding apps with a UI framework‚Äù](#building-apps-with-a-ui-framework) UI frameworks like React, Vue, or Svelte can also be used to create dev toolbar apps. These frameworks provide a more declarative way to create UIs and can make your code more maintainable and easier to read. The same motivational dev toolbar app built into your existing Astro project earlier on this page with JavaScript can be built using a UI framework (e.g. Preact) instead. Depending on your chosen framework, you may or may not require a build step. ### Without a build step [Section titled ‚ÄúWithout a build step‚Äù](#without-a-build-step) If your framework supports it, you can create a dev toolbar app without a build step. For example, you can use Preact‚Äôs `h` function to create elements and render them directly to the ShadowRoot: app.ts ```ts import { defineToolbarApp } from "astro/toolbar"; import { render, h } from "preact"; const motivationalMessages = [ "You're doing great!", "Keep up the good work!", "You're awesome!", "You're a star!", ]; export default defineToolbarApp({ init(canvas) { const message = motivationalMessages[Math.floor(Math.random() * motivationalMessages.length)]; render(h('h1', null, message), canvas); }, }); ``` Alternatively, the [`htm` package](https://github.com/developit/htm) is a good choice for creating dev toolbar apps without a build step, offering native integration for React and Preact and support for other frameworks: app.ts ```diff import { defineToolbarApp } from "astro/toolbar"; import { render } from "preact"; +import { html } from 'htm/preact'; const motivationalMessages = [ "You're doing great!", "Keep up the good work!", "You're awesome!", "You're a star!", ]; export default defineToolbarApp({ init(canvas) { const message = motivationalMessages[Math.floor(Math.random() * motivationalMessages.length)]; +render(html`<h1>${message}</h1>`, canvas); }, }); ``` In both cases, you can now start your project and see the motivational message displayed in the top-left corner of the screen when you toggle the app on. ### With a build step [Section titled ‚ÄúWith a build step‚Äù](#with-a-build-step) Astro does not preprocess JSX code in dev toolbar apps, so a build step is required in order to use JSX components in your dev toolbar app. The following steps will use TypeScript to do this, but any other tools that compile JSX code will also work (e.g. Babel, Rollup, ESBuild). 1. Install TypeScript inside your project: * npm ```shell npm install --save-dev typescript ``` * pnpm ```shell pnpm install --save-dev typescript ``` * Yarn ```shell yarn add --dev typescript ``` 2. Create a `tsconfig.json` file in the root of your toolbar app‚Äôs folder with the appropriate settings to build and for the framework you‚Äôre using ([React](https://react-typescript-cheatsheet.netlify.app/docs/basic/setup), [Preact](https://preactjs.com/guide/v10/typescript), [Solid](https://www.solidjs.com/guides/typescript)). For example, for Preact: my-toolbar-app/tsconfig.json ```json { "compilerOptions": { "skipLibCheck": true, "module": "NodeNext", "jsx": "react-jsx", "jsxImportSource": "preact", } } ``` 3. Adjust the `entrypoint` in your integration to point to the compiled file, remembering that this file is relative to the root of your Astro project: my-integration.ts ```ts addDevToolbarApp({ id: "my-toolbar-app", name: "My Toolbar App", icon: "üöÄ", entrypoint: join(__dirname, "./app.js"), }); ``` 4. Run `tsc` to build your toolbar app, or `tsc --watch` to automatically rebuild your app when you make changes. With these changes, you can now rename your `app.ts` file to `app.tsx` (or `.jsx`) and use JSX syntax to create your dev toolbar app: app.tsx ```tsx import { defineToolbarApp } from "astro/toolbar"; import { render } from "preact"; const motivationalMessages = [ "You're doing great!", "Keep up the good work!", "You're awesome!", "You're a star!", ]; export default defineToolbarApp({ init(canvas) { const message = motivationalMessages[Math.floor(Math.random() * motivationalMessages.length)]; render(<h1>{message}</h1>, canvas); }, }); ``` You should now have all the tools you need to create a dev toolbar app using a UI framework of your choice!

# Add last modified time

> Build a remark plugin to add the last modified time to your Markdown and MDX.

Learn how to build a [remark plugin](https://github.com/remarkjs/remark) that adds the last modified time to the frontmatter of your Markdown and MDX files. Use this property to display the modified time in your pages. ## Recipe [Section titled ‚ÄúRecipe‚Äù](#recipe) 1. Install Helper Packages Install [`Day.js`](https://www.npmjs.com/package/dayjs) to modify and format times: * npm ```shell npm install dayjs ``` * pnpm ```shell pnpm add dayjs ``` * Yarn ```shell yarn add dayjs ``` 2. Create a Remark Plugin This plugin uses `execSync` to run a Git command that returns the timestamp of the latest commit in ISO 8601 format. The timestamp is then added to the frontmatter of the file. remark-modified-time.mjs ```js import { execSync } from "child_process"; export function remarkModifiedTime() { return function (tree, file) { const filepath = file.history[0]; const result = execSync(`git log -1 --pretty="format:%cI" "${filepath}"`); file.data.astro.frontmatter.lastModified = result.toString(); }; } ``` 3. Add the plugin to your config astro.config.mjs ```js import { defineConfig } from 'astro/config'; import { remarkModifiedTime } from './remark-modified-time.mjs'; export default defineConfig({ markdown: { remarkPlugins: [remarkModifiedTime], }, }); ``` Now all Markdown documents will have a `lastModified` property in their frontmatter. 4. Display Last Modified Time If your content is stored in a [content collection](/en/guides/content-collections/), access the `remarkPluginFrontmatter` from the `render(entry)` function. Then render `lastModified` in your template wherever you would like it to appear. src/pages/posts/\[slug].astro ```astro --- import { getCollection, render } from 'astro:content'; import dayjs from "dayjs"; import utc from "dayjs/plugin/utc"; dayjs.extend(utc); export async function getStaticPaths() { const blog = await getCollection('blog'); return blog.map(entry => ({ params: { slug: entry.id }, props: { entry }, })); } const { entry } = Astro.props; const { Content, remarkPluginFrontmatter } = await render(entry); const lastModified = dayjs(remarkPluginFrontmatter.lastModified) .utc() .format("HH:mm:ss DD MMMM YYYY UTC"); --- <html> <head>...</head> <body> ... <p>Last Modified: {lastModified}</p> ... </body> </html> ``` If you‚Äôre using a [Markdown layout](/en/basics/layouts/#markdown-layouts), use the `lastModified` frontmatter property from `Astro.props` in your layout template. src/layouts/BlogLayout.astro ```astro --- import dayjs from "dayjs"; import utc from "dayjs/plugin/utc"; dayjs.extend(utc); const lastModified = dayjs() .utc(Astro.props.frontmatter.lastModified) .format("HH:mm:ss DD MMMM YYYY UTC"); --- <html> <head>...</head> <body> <p>{lastModified}</p> <slot /> </body> </html> ```

# Add reading time

> Build a remark plugin to add reading time to your Markdown or MDX files.

Create a [remark plugin](https://github.com/remarkjs/remark) which adds a reading time property to the frontmatter of your Markdown or MDX files. Use this property to display the reading time for each page. ## Recipe [Section titled ‚ÄúRecipe‚Äù](#recipe) 1. Install Helper Packages Install these two helper packages: * [`reading-time`](https://www.npmjs.com/package/reading-time) to calculate minutes read * [`mdast-util-to-string`](https://www.npmjs.com/package/mdast-util-to-string) to extract all text from your markdown - npm ```shell npm install reading-time mdast-util-to-string ``` - pnpm ```shell pnpm add reading-time mdast-util-to-string ``` - Yarn ```shell yarn add reading-time mdast-util-to-string ``` 2. Create a remark plugin. This plugin uses the `mdast-util-to-string` package to get the Markdown file‚Äôs text. This text is then passed to the `reading-time` package to calculate the reading time in minutes. remark-reading-time.mjs ```js import getReadingTime from 'reading-time'; import { toString } from 'mdast-util-to-string'; export function remarkReadingTime() { return function (tree, { data }) { const textOnPage = toString(tree); const readingTime = getReadingTime(textOnPage); // readingTime.text will give us minutes read as a friendly string, // i.e. "3 min read" data.astro.frontmatter.minutesRead = readingTime.text; }; } ``` 3. Add the plugin to your config: astro.config.mjs ```js import { defineConfig } from 'astro/config'; import { remarkReadingTime } from './remark-reading-time.mjs'; export default defineConfig({ markdown: { remarkPlugins: [remarkReadingTime], }, }); ``` Now all Markdown documents will have a calculated `minutesRead` property in their frontmatter. 4. Display Reading Time If your blog posts are stored in a [content collection](/en/guides/content-collections/), access the `remarkPluginFrontmatter` from the `render(entry)` function. Then, render `minutesRead` in your template wherever you would like it to appear. src/pages/posts/\[slug].astro ```astro --- import { getCollection, render } from 'astro:content'; export async function getStaticPaths() { const blog = await getCollection('blog'); return blog.map(entry => ({ params: { slug: entry.id }, props: { entry }, })); } const { entry } = Astro.props; const { Content, remarkPluginFrontmatter } = await render(entry); --- <html> <head>...</head> <body> ... <p>{remarkPluginFrontmatter.minutesRead}</p> ... </body> </html> ``` If you‚Äôre using a [Markdown layout](/en/basics/layouts/#markdown-layouts), use the `minutesRead` frontmatter property from `Astro.props` in your layout template. src/layouts/BlogLayout.astro ```astro --- const { minutesRead } = Astro.props.frontmatter; --- <html> <head>...</head> <body> <p>{minutesRead}</p> <slot /> </body> </html> ```

# Add an RSS feed

> Add an RSS feed to your Astro site to let users subscribe to your content.

Astro supports fast, automatic RSS feed generation for blogs and other content websites. RSS feeds provide an easy way for users to subscribe to your content. ## Setting up `@astrojs/rss` [Section titled ‚ÄúSetting up @astrojs/rss‚Äù](#setting-up-astrojsrss) The package [`@astrojs/rss`](https://github.com/withastro/astro/tree/main/packages/astro-rss) provides helpers for generating RSS feeds using [API endpoints](/en/guides/endpoints/#static-file-endpoints). This unlocks both static builds *and* on-demand generation when using an [SSR adapter](/en/guides/on-demand-rendering/). 1. Install `@astrojs/rss` using your preferred package manager: * npm ```shell npm install @astrojs/rss ``` * pnpm ```shell pnpm add @astrojs/rss ``` * Yarn ```shell yarn add @astrojs/rss ``` 2. Create a file in `src/pages/` with a name of your choice and the extension `.xml.js` to be used as the output URL for your feed. Some common RSS feed URL names are `feed.xml` or `rss.xml`. The example file below `src/pages/rss.xml.js` will create an RSS feed at `site/rss.xml`. 3. Import the `rss()` helper from the `@astrojs/rss` package into your `.xml.js` file and export a function that returns it using the following parameters: src/pages/rss.xml.js ```js import rss from '@astrojs/rss'; export function GET(context) { return rss({ // `<title>` field in output xml title: 'Buzz‚Äôs Blog', // `<description>` field in output xml description: 'A humble Astronaut‚Äôs guide to the stars', // Pull in your project "site" from the endpoint context // https://docs.astro.build/en/reference/api-reference/#site site: context.site, // Array of `<item>`s in output xml // See "Generating items" section for examples using content collections and glob imports items: [], // (optional) inject custom xml customData: `<language>en-us</language>`, }); } ``` See the [`@astrojs/rss` README](https://github.com/withastro/astro/tree/main/packages/astro-rss) for the full configuration reference. ## Generating `items` [Section titled ‚ÄúGenerating items‚Äù](#generating-items) The `items` field accepts a list of RSS feed objects, which can be generated from content collections entries using `getCollection()` or from your page files using `pagesGlobToRssItems()`. The RSS feed standard format includes metadata for each published item, including values such as: * `title`: The title of the entry. Optional only if a `description` is set. Otherwise, required. * `description`: A short excerpt from or describing the entry. Optional only if a `title` is set. Otherwise, required. * `link`: A URL to the original source of the entry. (optional) * `pubDate`: The date of publication of the entry. (optional) * `content`: The full content of your post. (optional) See the [`items` configuration reference](https://github.com/withastro/astro/tree/main/packages/astro-rss#items) for a complete list of options. ### Using content collections [Section titled ‚ÄúUsing content collections‚Äù](#using-content-collections) To create an RSS feed of pages managed in [content collections](/en/guides/content-collections/), use the `getCollection()` function to retrieve the data required for your `items` array. You will need to specify the values for each desired property (e.g. `title`, `description`) from the returned data. src/pages/rss.xml.js ```js import rss from '@astrojs/rss'; import { getCollection } from 'astro:content'; export async function GET(context) { const blog = await getCollection('blog'); return rss({ title: 'Buzz‚Äôs Blog', description: 'A humble Astronaut‚Äôs guide to the stars', site: context.site, items: blog.map((post) => ({ title: post.data.title, pubDate: post.data.pubDate, description: post.data.description, // Compute RSS link from post `id` // This example assumes all posts are rendered as `/blog/[id]` routes link: `/blog/${post.id}/`, })), }); } ``` Optional: replace your existing blog collection schema to enforce the expected RSS properties. To ensure that every blog entry produces a valid RSS feed item, you can optionally import and apply `rssSchema` instead of defining each individual property of your schema. src/content.config.ts ```js import { defineCollection } from 'astro:content'; import { rssSchema } from '@astrojs/rss'; const blog = defineCollection({ schema: rssSchema, }); export const collections = { blog }; ``` ### Using glob imports [Section titled ‚ÄúUsing glob imports‚Äù](#using-glob-imports) **Added in:** `@astrojs/rss@2.1.0` To create an RSS feed from documents in `src/pages/`, use the `pagesGlobToRssItems()` helper. This accepts an [`import.meta.glob`](https://vite.dev/guide/features.html#glob-import) result and outputs an array of valid RSS feed items (see [more about writing glob patterns](/en/guides/imports/#glob-patterns) for specifying which pages to include). Caution This function assumes, but does not verify, that all necessary feed properties are present in each document‚Äôs frontmatter. If you encounter errors, verify each page frontmatter manually. src/pages/rss.xml.js ```js import rss, { pagesGlobToRssItems } from '@astrojs/rss'; export async function GET(context) { return rss({ title: 'Buzz‚Äôs Blog', description: 'A humble Astronaut‚Äôs guide to the stars', site: context.site, items: await pagesGlobToRssItems( import.meta.glob('./blog/*.{md,mdx}'), ), }); } ``` ### Including full post content [Section titled ‚ÄúIncluding full post content‚Äù](#including-full-post-content) **Added in:** `astro@1.6.14` Set the `content` key on `rss.items` to provide the full content of a post as HTML. This allows `@astrojs/rss` to make the full Markdown text of your post available to RSS feed readers. Images and links with full URL paths are also supported. However, images and internal links to other pages using relative paths are not. When rendering full post content, you will have to consider images, relative links, styles, scripts, and other elements beyond standard Markdown text that you may have in your posts. You may need to include additional logic in your `src/pages/rss.xml.js` endpoint to account for these, or to remove elements that are unnecessary for an RSS feed (e.g. those that are used only for styling or interaction on your website). You can see [one specific community implementation](https://github.com/delucis/astro-blog-full-text-rss/blob/latest/src/pages/rss.xml.ts) that addresses some of these concerns for an example of how to proceed. When using content collections, render the post `body` using a standard Markdown parser like [`markdown-it`](https://github.com/markdown-it/markdown-it) and sanitize the result, including any extra tags (e.g. `<img>`) needed to render your content: src/pages/rss.xml.js ```diff import rss from '@astrojs/rss'; import { getCollection } from 'astro:content'; +import sanitizeHtml from 'sanitize-html'; +import MarkdownIt from 'markdown-it'; +const parser = new MarkdownIt(); export async function GET(context) { const blog = await getCollection('blog'); return rss({ title: 'Buzz‚Äôs Blog', description: 'A humble Astronaut‚Äôs guide to the stars', site: context.site, items: blog.map((post) => ({ link: `/blog/${post.id}/`, // Note: this will not process components or JSX expressions in MDX files. + content: sanitizeHtml(parser.render(post.body), { allowedTags: sanitizeHtml.defaults.allowedTags.concat(['img']) }), ...post.data, })), }); } ``` When using glob imports with Markdown, you may use the `compiledContent()` helper to retrieve the rendered HTML for sanitization. Note: this feature is **not** supported for MDX files. src/pages/rss.xml.js ```diff import rss from '@astrojs/rss'; +import sanitizeHtml from 'sanitize-html'; export async function GET(context) { const postImportResult = import.meta.glob('../posts/**/*.md', { eager: true }); const posts = Object.values(postImportResult); return rss({ title: 'Buzz‚Äôs Blog', description: 'A humble Astronaut‚Äôs guide to the stars', site: context.site, items: await Promise.all(posts.map(async (post) => ({ link: post.url, + content: sanitizeHtml((await post.compiledContent())), ...post.frontmatter, }))), }); } ``` ## Removing trailing slashes [Section titled ‚ÄúRemoving trailing slashes‚Äù](#removing-trailing-slashes) Astro‚Äôs RSS feed produces links with a trailing slash by default, no matter what value you have configured for `trailingSlash`. This means that your RSS links may not match your post URLs exactly. If you have set `trailingSlash: "never"` on your `astro.config.mjs`, set `trailingSlash: false` in the `rss()` helper so that your feed matches your project configuration. src/pages/rss.xml.js ```diff import rss from '@astrojs/rss'; export function GET(context) { const posts = Object.values(postImportResult); return rss({ title: 'Buzz‚Äôs Blog', description: 'A humble Astronaut‚Äôs guide to the stars', site: context.site, + trailingSlash: false, items: posts.map((post) => ({ link: post.url, ...post.frontmatter, })), }); } ``` ## Adding a stylesheet [Section titled ‚ÄúAdding a stylesheet‚Äù](#adding-a-stylesheet) Style your RSS feed for a more pleasant user experience when viewing the file in your browser. Use the `rss` function‚Äôs `stylesheet` option to specify an absolute path to your stylesheet. ```js rss({ // ex. use your stylesheet from "public/rss/styles.xsl" stylesheet: '/rss/styles.xsl', // ... }); ``` ## Enabling RSS feed auto-discovery [Section titled ‚ÄúEnabling RSS feed auto-discovery‚Äù](#enabling-rss-feed-auto-discovery) [RSS autodiscovery](https://www.rssboard.org/rss-autodiscovery) allows browsers and other software to automatically find a site‚Äôs RSS feed from the main URL. To enable, add a `<link>` tag with the following attributes to your site‚Äôs `head` element: ```jsx <link rel="alternate" type="application/rss+xml" title="Your Site's Title" href={new URL("rss.xml", Astro.site)} /> ``` With this tag, readers of your blog can enter your site‚Äôs base URL into their RSS reader to subscribe to your posts without needing the specific URL of your RSS feed. ## Next Steps [Section titled ‚ÄúNext Steps‚Äù](#next-steps) After visiting your feed in the browser at `your-domain.com/rss.xml` and confirming that you can see data for each of your posts, you can now [promote your feed on your website](https://medium.com/samsung-internet-dev/add-rss-feeds-to-your-website-to-keep-your-core-readers-engaged-3179dca9c91e#:~:text=com/~deno%2Drss-,Advertising%20your%20RSS%20feed,-Now%20you%20have). Adding the standard RSS icon to your site lets your readers know that they can subscribe to your posts in their own feed reader. ## Resources [Section titled ‚ÄúResources‚Äù](#resources) * [RSS Feeds](https://aboutfeeds.com/)

# Share state between Astro components

> Learn how to share state across Astro components with Nano Stores.

When building an Astro website, you may need to share state across components. Astro recommends the use of [Nano Stores](https://github.com/nanostores/nanostores) for shared client storage. ## Recipe [Section titled ‚ÄúRecipe‚Äù](#recipe) 1. Install Nano Stores: * npm ```shell npm install nanostores ``` * pnpm ```shell pnpm add nanostores ``` * Yarn ```shell yarn add nanostores ``` 2. Create a store. In this example, the store tracks whether a dialog is open or not: src/store.js ```ts import { atom } from 'nanostores'; export const isOpen = atom(false); ``` 3. Import and use the store in a `<script>` tag in the components that will share state. The following `Button` and `Dialog` components each use the shared `isOpen` state to control whether a particular `<div>` is hidden or displayed: src/components/Button.astro ```astro <button id="openDialog">Open</button> <script> import { isOpen } from '../store.js'; // Set the store to true when the button is clicked function openDialog() { isOpen.set(true); } // Add an event listener to the button document.getElementById('openDialog').addEventListener('click', openDialog); </script> ``` src/components/Dialog.astro ```astro <div id="dialog" style="display: none">Hello world!</div> <script> import { isOpen } from '../store.js'; // Listen to changes in the store, and show/hide the dialog accordingly isOpen.subscribe(open => { if (open) { document.getElementById('dialog').style.display = 'block'; } else { document.getElementById('dialog').style.display = 'none'; } }) </script> ``` ## Resources [Section titled ‚ÄúResources‚Äù](#resources) * [Nano Stores on NPM](https://www.npmjs.com/package/nanostores) * [Nano Stores documentation for Vanilla JS](https://github.com/nanostores/nanostores#vanilla-js)

# Share state between islands

> Learn how to share state across framework components with Nano Stores.

When building an Astro website with [islands architecture / partial hydration](/en/concepts/islands/), you may have run into this problem: **I want to share state between my components.** UI frameworks like React or Vue may encourage [‚Äúcontext‚Äù providers](https://react.dev/learn/passing-data-deeply-with-context) for other components to consume. But when [partially hydrating components](/en/guides/framework-components/#hydrating-interactive-components) within Astro or Markdown, you can‚Äôt use these context wrappers. Astro recommends a different solution for shared client-side storage: [**Nano Stores**](https://github.com/nanostores/nanostores). ![](/houston_chef.webp) **Related recipe:** [Share state between Astro components](/en/recipes/sharing-state/) ## Why Nano Stores? [Section titled ‚ÄúWhy Nano Stores?‚Äù](#why-nano-stores) The [Nano Stores](https://github.com/nanostores/nanostores) library allows you to author stores that any component can interact with. We recommend Nano Stores because: * **They‚Äôre lightweight.** Nano Stores ship the bare minimum JS you‚Äôll need (less than 1 KB) with zero dependencies. * **They‚Äôre framework-agnostic.** This means sharing state between frameworks will be seamless! Astro is built on flexibility, so we love solutions that offer a similar developer experience no matter your preference. Still, there are a number of alternatives you can explore. These include: * [Svelte‚Äôs built-in stores](https://svelte.dev/tutorial/writable-stores) * [Solid signals](https://www.solidjs.com/docs/latest) outside of a component context * [Vue‚Äôs reactivity API](https://vuejs.org/guide/scaling-up/state-management.html#simple-state-management-with-reactivity-api) * [Sending custom browser events](https://developer.mozilla.org/en-US/docs/Web/Events/Creating_and_triggering_events) between components ## Installing Nano Stores [Section titled ‚ÄúInstalling Nano Stores‚Äù](#installing-nano-stores) To get started, install Nano Stores alongside their helper package for your favorite UI framework: * Preact ```shell npm install nanostores @nanostores/preact ``` * React ```shell npm install nanostores @nanostores/react ``` * Solid ```shell npm install nanostores @nanostores/solid ``` * Svelte ```shell npm install nanostores ``` * Vue ```shell npm install nanostores @nanostores/vue ``` You can jump into the [Nano Stores usage guide](https://github.com/nanostores/nanostores#guide) from here, or follow along with our example below! ## Usage example - ecommerce cart flyout [Section titled ‚ÄúUsage example - ecommerce cart flyout‚Äù](#usage-example---ecommerce-cart-flyout) Let‚Äôs say we‚Äôre building a simple ecommerce interface with three interactive elements: * An ‚Äúadd to cart‚Äù submission form * A cart flyout to display those added items * A cart flyout toggle [](/videos/stores-example.mp4) *[**Try the completed example**](https://github.com/withastro/astro/tree/main/examples/with-nanostores) on your machine or online via StackBlitz.* Your base Astro file may look like this: src/pages/index.astro ```astro --- import CartFlyoutToggle from '../components/CartFlyoutToggle'; import CartFlyout from '../components/CartFlyout'; import AddToCartForm from '../components/AddToCartForm'; --- <!DOCTYPE html> <html lang="en"> <head>...</head> <body> <header> <nav> <a href="/">Astro storefront</a> <CartFlyoutToggle client:load /> </nav> </header> <main> <AddToCartForm client:load> <!-- ... --> </AddToCartForm> </main> <CartFlyout client:load /> </body> </html> ``` ### Using ‚Äúatoms‚Äù [Section titled ‚ÄúUsing ‚Äúatoms‚Äù‚Äù](#using-atoms) Let‚Äôs start by opening our `CartFlyout` whenever `CartFlyoutToggle` is clicked. First, create a new JS or TS file to contain our store. We‚Äôll use an [‚Äúatom‚Äù](https://github.com/nanostores/nanostores#atoms) for this: src/cartStore.js ```js import { atom } from 'nanostores'; export const isCartOpen = atom(false); ``` Now, we can import this store into any file that needs to read or write. We‚Äôll start by wiring up our `CartFlyoutToggle`: * Preact src/components/CartFlyoutToggle.jsx ```jsx import { useStore } from '@nanostores/preact'; import { isCartOpen } from '../cartStore'; export default function CartButton() { // read the store value with the `useStore` hook const $isCartOpen = useStore(isCartOpen); // write to the imported store using `.set` return ( <button onClick={() => isCartOpen.set(!$isCartOpen)}>Cart</button> ) } ``` * React src/components/CartFlyoutToggle.jsx ```jsx import { useStore } from '@nanostores/react'; import { isCartOpen } from '../cartStore'; export default function CartButton() { // read the store value with the `useStore` hook const $isCartOpen = useStore(isCartOpen); // write to the imported store using `.set` return ( <button onClick={() => isCartOpen.set(!$isCartOpen)}>Cart</button> ) } ``` * Solid src/components/CartFlyoutToggle.jsx ```jsx import { useStore } from '@nanostores/solid'; import { isCartOpen } from '../cartStore'; export default function CartButton() { // read the store value with the `useStore` hook const $isCartOpen = useStore(isCartOpen); // write to the imported store using `.set` return ( <button onClick={() => isCartOpen.set(!$isCartOpen())}>Cart</button> ) } ``` * Svelte src/components/CartFlyoutToggle.svelte ```svelte <script> import { isCartOpen } from '../cartStore'; </script> <!--use "$" to read the store value--> <button on:click={() => isCartOpen.set(!$isCartOpen)}>Cart</button> ``` * Vue src/components/CartFlyoutToggle.vue ```vue <template> <!--write to the imported store using `.set`--> <button @click="isCartOpen.set(!$isCartOpen)">Cart</button> </template> <script setup> import { isCartOpen } from '../cartStore'; import { useStore } from '@nanostores/vue'; // read the store value with the `useStore` hook const $isCartOpen = useStore(isCartOpen); </script> ``` Then, we can read `isCartOpen` from our `CartFlyout` component: * Preact src/components/CartFlyout.jsx ```jsx import { useStore } from '@nanostores/preact'; import { isCartOpen } from '../cartStore'; export default function CartFlyout() { const $isCartOpen = useStore(isCartOpen); return $isCartOpen ? <aside>...</aside> : null; } ``` * React src/components/CartFlyout.jsx ```jsx import { useStore } from '@nanostores/react'; import { isCartOpen } from '../cartStore'; export default function CartFlyout() { const $isCartOpen = useStore(isCartOpen); return $isCartOpen ? <aside>...</aside> : null; } ``` * Solid src/components/CartFlyout.jsx ```jsx import { useStore } from '@nanostores/solid'; import { isCartOpen } from '../cartStore'; export default function CartFlyout() { const $isCartOpen = useStore(isCartOpen); return $isCartOpen() ? <aside>...</aside> : null; } ``` * Svelte src/components/CartFlyout.svelte ```svelte <script> import { isCartOpen } from '../cartStore'; </script> {#if $isCartOpen} <aside>...</aside> {/if} ``` * Vue src/components/CartFlyout.vue ```vue <template> <aside v-if="$isCartOpen">...</aside> </template> <script setup> import { isCartOpen } from '../cartStore'; import { useStore } from '@nanostores/vue'; const $isCartOpen = useStore(isCartOpen); </script> ``` ### Using ‚Äúmaps‚Äù [Section titled ‚ÄúUsing ‚Äúmaps‚Äù‚Äù](#using-maps) Now, let‚Äôs keep track of the items inside your cart. To avoid duplicates and keep track of ‚Äúquantity,‚Äù we can store your cart as an object with the item‚Äôs ID as a key. We‚Äôll use a [Map](https://github.com/nanostores/nanostores#maps) for this. Let‚Äôs add a `cartItem` store to our `cartStore.js` from earlier. You can also switch to a TypeScript file to define the shape if you‚Äôre so inclined. * JavaScript src/cartStore.js ```js import { atom, map } from 'nanostores'; export const isCartOpen = atom(false); /** * @typedef {Object} CartItem * @property {string} id * @property {string} name * @property {string} imageSrc * @property {number} quantity */ /** @type {import('nanostores').MapStore<Record<string, CartItem>>} */ export const cartItems = map({}); ``` * TypeScript src/cartStore.ts ```ts import { atom, map } from 'nanostores'; export const isCartOpen = atom(false); export type CartItem = { id: string; name: string; imageSrc: string; quantity: number; } export const cartItems = map<Record<string, CartItem>>({}); ``` Now, let‚Äôs export an `addCartItem` helper for our components to use. * **If that item doesn‚Äôt exist in your cart**, add the item with a starting quantity of 1. * **If that item *does* already exist**, bump the quantity by 1. - JavaScript src/cartStore.js ```js ... export function addCartItem({ id, name, imageSrc }) { const existingEntry = cartItems.get()[id]; if (existingEntry) { cartItems.setKey(id, { ...existingEntry, quantity: existingEntry.quantity + 1, }) } else { cartItems.setKey( id, { id, name, imageSrc, quantity: 1 } ); } } ``` - TypeScript src/cartStore.ts ```ts ... type ItemDisplayInfo = Pick<CartItem, 'id' | 'name' | 'imageSrc'>; export function addCartItem({ id, name, imageSrc }: ItemDisplayInfo) { const existingEntry = cartItems.get()[id]; if (existingEntry) { cartItems.setKey(id, { ...existingEntry, quantity: existingEntry.quantity + 1, }); } else { cartItems.setKey( id, { id, name, imageSrc, quantity: 1 } ); } } ``` With our store in place, we can call this function inside our `AddToCartForm` whenever that form is submitted. We‚Äôll also open the cart flyout so you can see a full cart summary. * Preact src/components/AddToCartForm.jsx ```jsx import { addCartItem, isCartOpen } from '../cartStore'; export default function AddToCartForm({ children }) { // we'll hardcode the item info for simplicity! const hardcodedItemInfo = { id: 'astronaut-figurine', name: 'Astronaut Figurine', imageSrc: '/images/astronaut-figurine.png', } function addToCart(e) { e.preventDefault(); isCartOpen.set(true); addCartItem(hardcodedItemInfo); } return ( <form onSubmit={addToCart}> {children} </form> ) } ``` * React src/components/AddToCartForm.jsx ```jsx import { addCartItem, isCartOpen } from '../cartStore'; export default function AddToCartForm({ children }) { // we'll hardcode the item info for simplicity! const hardcodedItemInfo = { id: 'astronaut-figurine', name: 'Astronaut Figurine', imageSrc: '/images/astronaut-figurine.png', } function addToCart(e) { e.preventDefault(); isCartOpen.set(true); addCartItem(hardcodedItemInfo); } return ( <form onSubmit={addToCart}> {children} </form> ) } ``` * Solid src/components/AddToCartForm.jsx ```jsx import { addCartItem, isCartOpen } from '../cartStore'; export default function AddToCartForm({ children }) { // we'll hardcode the item info for simplicity! const hardcodedItemInfo = { id: 'astronaut-figurine', name: 'Astronaut Figurine', imageSrc: '/images/astronaut-figurine.png', } function addToCart(e) { e.preventDefault(); isCartOpen.set(true); addCartItem(hardcodedItemInfo); } return ( <form onSubmit={addToCart}> {children} </form> ) } ``` * Svelte src/components/AddToCartForm.svelte ```svelte <form on:submit|preventDefault={addToCart}> <slot></slot> </form> <script> import { addCartItem, isCartOpen } from '../cartStore'; // we'll hardcode the item info for simplicity! const hardcodedItemInfo = { id: 'astronaut-figurine', name: 'Astronaut Figurine', imageSrc: '/images/astronaut-figurine.png', } function addToCart() { isCartOpen.set(true); addCartItem(hardcodedItemInfo); } </script> ``` * Vue src/components/AddToCartForm.vue ```vue <template> <form @submit="addToCart"> <slot></slot> </form> </template> <script setup> import { addCartItem, isCartOpen } from '../cartStore'; // we'll hardcode the item info for simplicity! const hardcodedItemInfo = { id: 'astronaut-figurine', name: 'Astronaut Figurine', imageSrc: '/images/astronaut-figurine.png', } function addToCart(e) { e.preventDefault(); isCartOpen.set(true); addCartItem(hardcodedItemInfo); } </script> ``` Finally, we‚Äôll render those cart items inside our `CartFlyout`: * Preact src/components/CartFlyout.jsx ```jsx import { useStore } from '@nanostores/preact'; import { isCartOpen, cartItems } from '../cartStore'; export default function CartFlyout() { const $isCartOpen = useStore(isCartOpen); const $cartItems = useStore(cartItems); return $isCartOpen ? ( <aside> {Object.values($cartItems).length ? ( <ul> {Object.values($cartItems).map(cartItem => ( <li> <img src={cartItem.imageSrc} alt={cartItem.name} /> <h3>{cartItem.name}</h3> <p>Quantity: {cartItem.quantity}</p> </li> ))} </ul> ) : <p>Your cart is empty!</p>} </aside> ) : null; } ``` * React src/components/CartFlyout.jsx ```jsx import { useStore } from '@nanostores/react'; import { isCartOpen, cartItems } from '../cartStore'; export default function CartFlyout() { const $isCartOpen = useStore(isCartOpen); const $cartItems = useStore(cartItems); return $isCartOpen ? ( <aside> {Object.values($cartItems).length ? ( <ul> {Object.values($cartItems).map(cartItem => ( <li> <img src={cartItem.imageSrc} alt={cartItem.name} /> <h3>{cartItem.name}</h3> <p>Quantity: {cartItem.quantity}</p> </li> ))} </ul> ) : <p>Your cart is empty!</p>} </aside> ) : null; } ``` * Solid src/components/CartFlyout.jsx ```jsx import { useStore } from '@nanostores/solid'; import { isCartOpen, cartItems } from '../cartStore'; export default function CartFlyout() { const $isCartOpen = useStore(isCartOpen); const $cartItems = useStore(cartItems); return $isCartOpen() ? ( <aside> {Object.values($cartItems()).length ? ( <ul> {Object.values($cartItems()).map(cartItem => ( <li> <img src={cartItem.imageSrc} alt={cartItem.name} /> <h3>{cartItem.name}</h3> <p>Quantity: {cartItem.quantity}</p> </li> ))} </ul> ) : <p>Your cart is empty!</p>} </aside> ) : null; } ``` * Svelte src/components/CartFlyout.svelte ```svelte <script> import { isCartOpen, cartItems } from '../cartStore'; </script> {#if $isCartOpen} {#if Object.values($cartItems).length} <aside> {#each Object.values($cartItems) as cartItem} <li> <img src={cartItem.imageSrc} alt={cartItem.name} /> <h3>{cartItem.name}</h3> <p>Quantity: {cartItem.quantity}</p> </li> {/each} </aside> {:else} <p>Your cart is empty!</p> {/if} {/if} ``` * Vue src/components/CartFlyout.vue ```vue <template> <aside v-if="$isCartOpen"> <ul v-if="Object.values($cartItems).length"> <li v-for="cartItem in Object.values($cartItems)" v-bind:key="cartItem.name"> <img :src=cartItem.imageSrc :alt=cartItem.name /> <h3>{{cartItem.name}}</h3> <p>Quantity: {{cartItem.quantity}}</p> </li> </ul> <p v-else>Your cart is empty!</p> </aside> </template> <script setup> import { cartItems, isCartOpen } from '../cartStore'; import { useStore } from '@nanostores/vue'; const $isCartOpen = useStore(isCartOpen); const $cartItems = useStore(cartItems); </script> ``` Now, you should have a fully interactive ecommerce example with the smallest JS bundle in the galaxy üöÄ [**Try the completed example**](https://github.com/withastro/astro/tree/main/examples/with-nanostores) on your machine or online via StackBlitz!

# Using streaming to improve page performance

> Learn how to use streaming to improve page performance.

Astro‚Äôs SSR uses HTML streaming to send each component to the browser when available for faster page loading. To improve your page‚Äôs performance even further, you can build your components strategically to optimize their loading by avoiding blocking data fetches. The following refactoring example demonstrates how to improve page performance by moving fetch calls to other components, moving them out of a component where they block page rendering. The following page `await`s some data in its frontmatter. Astro will wait for all of the `fetch` calls to resolve before sending any HTML to the browser. src/pages/index.astro ```astro --- const personResponse = await fetch('https://randomuser.me/api/'); const personData = await personResponse.json(); const randomPerson = personData.results[0]; const factResponse = await fetch('https://catfact.ninja/fact'); const factData = await factResponse.json(); --- <html> <head> <title>A name and a fact</title> </head> <body> <h2>A name</h2> <p>{randomPerson.name.first}</p> <h2>A fact</h2> <p>{factData.fact}</p> </body> </html> ``` Moving the `await` calls into smaller components allows you to take advantage of Astro‚Äôs streaming. Using the following components to perform the data fetches, Astro can render some HTML first, such as the title, and then the paragraphs when the data is ready. src/components/RandomName.astro ```astro --- const personResponse = await fetch('https://randomuser.me/api/'); const personData = await personResponse.json(); const randomPerson = personData.results[0]; --- <p>{randomPerson.name.first}</p> ``` src/components/RandomFact.astro ```astro --- const factResponse = await fetch('https://catfact.ninja/fact'); const factData = await factResponse.json(); --- <p>{factData.fact}</p> ``` The Astro page below using these components can render parts of the page sooner. The `<head>`, `<body>`, and `<h2>` tags are no longer blocked by data fetches. The server will then fetch data for `RandomName` and `RandomFact` in parallel and stream the resulting HTML to the browser. src/pages/index.astro ```astro --- import RandomName from '../components/RandomName.astro'; import RandomFact from '../components/RandomFact.astro'; --- <html> <head> <title>A name and a fact</title> </head> <body> <h2>A name</h2> <RandomName /> <h2>A fact</h2> <RandomFact /> </body> </html> ``` #### Including Promises directly [Section titled ‚ÄúIncluding Promises directly‚Äù](#including-promises-directly) You can also include promises directly in the template. Instead of blocking the entire component, it will resolve the promise in parallel and only block the markup that comes after it. src/pages/index.astro ```astro --- const personPromise = fetch('https://randomuser.me/api/') .then(response => response.json()) .then(personData => personData.results[0].name.first); const factPromise = fetch('https://catfact.ninja/fact') .then(response => response.json()) .then(factData => factData.fact); --- <html> <head> <title>A name and a fact</title> </head> <body> <h2>A name</h2> <p>{personPromise}</p> <h2>A fact</h2> <p>{factPromise}</p> </body> </html> ``` In this example, `A name` will render while `personPromise` and `factPromise` are loading. Once `personPromise` has resolved, `A fact` will appear and `factPromise` will render when it‚Äôs finished loading.

# Style rendered Markdown with Tailwind Typography

> Learn how to use @tailwind/typography to style your rendered Markdown.

You can use [Tailwind](https://tailwindcss.com)‚Äôs Typography plugin to style rendered Markdown from sources such as Astro‚Äôs [**content collections**](/en/guides/content-collections/). This recipe will teach you how to create a reusable Astro component to style your Markdown content using Tailwind‚Äôs utility classes. ## Prerequisites [Section titled ‚ÄúPrerequisites‚Äù](#prerequisites) An Astro project that: * has [Tailwind‚Äôs Vite plugin](/en/guides/styling/#tailwind) installed. * uses Astro‚Äôs [content collections](/en/guides/content-collections/). ## Setting Up `@tailwindcss/typography` [Section titled ‚ÄúSetting Up @tailwindcss/typography‚Äù](#setting-up-tailwindcsstypography) First, install `@tailwindcss/typography` using your preferred package manager. * npm ```shell npm install -D @tailwindcss/typography ``` * pnpm ```shell pnpm add -D @tailwindcss/typography ``` * Yarn ```shell yarn add --dev @tailwindcss/typography ``` Then, add the package as a plugin in your Tailwind configuration file. src/styles/global.css ```diff @import 'tailwindcss'; +@plugin '@tailwindcss/typography'; ``` ## Recipe [Section titled ‚ÄúRecipe‚Äù](#recipe) 1. Create a `<Prose />` component to provide a wrapping `<div>` with a `<slot />` for your rendered Markdown. Add the style class `prose` alongside any desired [Tailwind element modifiers](https://tailwindcss.com/docs/typography-plugin#element-modifiers) in the parent element. src/components/Prose.astro ```astro --- --- <div class="prose dark:prose-invert prose-h1:font-bold prose-h1:text-xl prose-a:text-blue-600 prose-p:text-justify prose-img:rounded-xl prose-headings:underline"> <slot /> </div> ``` 2. Query your collection entry on the page you want to render your Markdown. Pass the `<Content />` component from `await render(entry)` to `<Prose />` as a child to wrap your Markdown content in Tailwind styles. src/pages/index.astro ```astro --- import Prose from '../components/Prose.astro'; import Layout from '../layouts/Layout.astro'; import { getEntry, render } from 'astro:content'; const entry = await getEntry('collection', 'entry'); const { Content } = await render(entry); --- <Layout> <Prose> <Content /> </Prose> </Layout> ``` ## Resources [Section titled ‚ÄúResources‚Äù](#resources) * [Tailwind Typography Documentation](https://tailwindcss.com/docs/typography-plugin)