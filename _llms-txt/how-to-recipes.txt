<SYSTEM>How-to Recipes: guided examples of adding features to an Astro project</SYSTEM>

# Astro recipes

> Short, focused how-to guides.

See guided examples of adding features to your Astro project. ## Official Recipes [Section titled “Official Recipes”](#official-recipes) Astro’s official recipes are short, focused how-to guides that walk a reader through completing a working example of a specific task. Recipes are a great way to add new features or behavior to your Astro project by following step-by-step instructions! * ### [Installing a Vite or Rollup plugin](/en/recipes/add-yaml-support/) Learn how you can import YAML data by adding a Rollup plugin to your project. * ### [Analyze bundle size](/en/recipes/analyze-bundle-size/) Learn how to analyze the bundle generated by Astro using \`rollup-plugin-visualizer\`. * ### [Build a custom image component](/en/recipes/build-custom-img-component/) Learn how to build a custom image component that supports media queries using the getImage function. * ### [Build forms with API routes](/en/recipes/build-forms-api/) Learn how to use JavaScript to send form submissions to an API Route. * ### [Build HTML forms in Astro pages](/en/recipes/build-forms/) Learn how to build HTML forms and handle submissions in your frontmatter. * ### [Use Bun with Astro](/en/recipes/bun/) Learn how to use Bun with your Astro site. * ### [Call endpoints from the server](/en/recipes/call-endpoints/) Learn how to call endpoints from the server in Astro. * ### [Verify a Captcha](/en/recipes/captcha/) Learn how to create an API route and fetch it from the client. * ### [Customize file names in the build output](/en/recipes/customizing-output-filenames/) Learn how to change the default naming pattern for your built assets like JavaScript, CSS, and images in Astro using Vite's Rollup options. * ### [Build your Astro site with Docker](/en/recipes/docker/) Learn how to build your Astro site using Docker. * ### [Dynamically import images](/en/recipes/dynamically-importing-images/) Learn how to dynamically import images using Vite's import.meta.glob function. * ### [Add icons to external links](/en/recipes/external-links/) Learn how to install a rehype plugin to add icons to external links in your Markdown files. * ### [Add i18n features](/en/recipes/i18n/) Use dynamic routing and content collections to add internationalization support to your Astro site. * ### [Create a dev toolbar app](/en/recipes/making-toolbar-apps/) Learn how to create a dev toolbar app for your site. * ### [Add last modified time](/en/recipes/modified-time/) Build a remark plugin to add the last modified time to your Markdown and MDX. * ### [Add reading time](/en/recipes/reading-time/) Build a remark plugin to add reading time to your Markdown or MDX files. * ### [Add an RSS feed](/en/recipes/rss/) Add an RSS feed to your Astro site to let users subscribe to your content. * ### [Share state between islands](/en/recipes/sharing-state-islands/) Learn how to share state across framework components with Nano Stores. * ### [Share state between Astro components](/en/recipes/sharing-state/) Learn how to share state across Astro components with Nano Stores. * ### [Style rendered Markdown with Tailwind Typography](/en/recipes/tailwind-rendered-markdown/) Learn how to use @tailwind/typography to style your rendered Markdown. * ### [Using streaming to improve page performance](/en/recipes/streaming-improve-page-performance/) Learn how to use streaming to improve page performance. ## Community Resources [Section titled “Community Resources”](#community-resources) Find more recipes written and submitted by the community at [Astro Tips](https://astro-tips.dev).

# Installing a Vite or Rollup plugin

> Learn how you can import YAML data by adding a Rollup plugin to your project.

Astro builds on top of Vite, and supports both Vite and Rollup plugins. This recipe uses a Rollup plugin to add the ability to import a YAML (`.yml`) file in Astro. ## Recipe [Section titled “Recipe”](#recipe) 1. Install `@rollup/plugin-yaml`: * npm ```shell npm install @rollup/plugin-yaml --save-dev ``` * pnpm ```shell pnpm add @rollup/plugin-yaml --save-dev ``` * Yarn ```shell yarn add @rollup/plugin-yaml --dev ``` 2. Import the plugin in your `astro.config.mjs` and add it to the Vite plugins array: astro.config.mjs ```diff import { defineConfig } from 'astro/config'; +import yaml from '@rollup/plugin-yaml'; export default defineConfig({ + vite: { + plugins: [yaml()] + } }); ``` 3. Finally, you can import YAML data using an `import` statement: ```js import yml from './data.yml'; ```

# Analyze bundle size

> Learn how to analyze the bundle generated by Astro using `rollup-plugin-visualizer`.

Understanding what is a part of an Astro bundle is important for improving site performance. Visualizing the bundle can give clues as to where changes can be made in your project to reduce the bundle size. ## Recipe [Section titled “Recipe”](#recipe) The [`rollup-plugin-visualizer` library](https://github.com/btd/rollup-plugin-visualizer) allows you to visualize and analyze your Rollup bundle to see which modules are taking up space. 1. Install `rollup-plugin-visualizer`: * npm ```shell npm install rollup-plugin-visualizer --save-dev ``` * pnpm ```shell pnpm add rollup-plugin-visualizer --save-dev ``` * Yarn ```shell yarn add rollup-plugin-visualizer --save-dev ``` 2. Add the plugin to the `astro.config.mjs` file: ```js // @ts-check import { defineConfig } from 'astro/config'; import { visualizer } from "rollup-plugin-visualizer"; export default defineConfig({ vite: { plugins: [visualizer({ emitFile: true, filename: "stats.html", })] } }); ``` 3. Run the build command: * npm ```shell npm run build ``` * pnpm ```shell pnpm build ``` * Yarn ```shell yarn build ``` 4. Find the `stats.html` file(s) for your project. This will be at the root of your `dist/` directory for entirely static sites and will allow you to see what is included in the bundle. If your Astro project uses on-demand rendering, you will have two `stats.html` files. One will be for the client, and the other for the server, and each will be located at the root of the `dist/client` and `dist/server/` directories. See [the Rollup Plugin Visualizer documentation](https://github.com/btd/rollup-plugin-visualizer#how-to-use-generated-files) for guidance on how to interpret these files, or configure specific options.

# Build a custom image component

> Learn how to build a custom image component that supports media queries using the getImage function.

Astro provides two built-in components that you can use to display and optimize your images. The `<Picture>` component allows you to display responsive images and work with different formats and sizes. The `<Image>` component will optimize your images and allow you to pass in different formats and quality properties. When you need options that the `<Picture>` and `<Image>` components do not currently support, you can use the `getImage()` function to create a custom component. In this recipe, you will use the [`getImage()` function](/en/guides/images/#generating-images-with-getimage) to create your own custom image component that displays different source images based on media queries. ## Recipe [Section titled “Recipe”](#recipe) 1. Create a new Astro component and import the `getImage()` function src/components/MyCustomImageComponent.astro ```astro --- import { getImage } from "astro:assets"; --- ``` 2. Create a new component for your custom image. `MyCustomComponent.astro` will receive three `props` from `Astro.props`. The `mobileImgUrl` and `desktopImgUrl` props are used for creating your image at different viewport sizes. The `alt` prop is used for the image’s alt text. These props will be passed wherever you render your custom image components. Add the following imports and define the props that you will use in your component. You can also use TypeScript to type the props. src/components/MyCustomImageComponent.astro ```diff --- import type { ImageMetadata } from "astro"; +import { getImage } from "astro:assets"; interface Props { mobileImgUrl: string | ImageMetadata; desktopImgUrl: string | ImageMetadata; alt: string; } +const { mobileImgUrl, desktopImgUrl, alt } = Astro.props; --- ``` 3. Define each of your responsive images by calling the `getImage()` function with your desired properties. src/components/MyCustomImageComponent.astro ```diff --- import type { ImageMetadata } from "astro"; import { getImage } from "astro:assets"; interface Props { mobileImgUrl: string | ImageMetadata; desktopImgUrl: string | ImageMetadata; alt: string; } const { mobileImgUrl, desktopImgUrl, alt } = Astro.props; +const mobileImg = await getImage({ src: mobileImgUrl, format: "webp", width: 200, height: 200, +}); +const desktopImg = await getImage({ src: desktopImgUrl, format: "webp", width: 800, height: 200, +}); --- ``` 4. Create a `<picture>` element that generates a `srcset` with your different images based on your desired media queries. src/components/MyCustomImageComponent.astro ```diff --- import type { ImageMetadata } from "astro"; import { getImage } from "astro:assets"; interface Props { mobileImgUrl: string | ImageMetadata; desktopImgUrl: string | ImageMetadata; alt: string; } const { mobileImgUrl, desktopImgUrl, alt } = Astro.props; const mobileImg = await getImage({ src: mobileImgUrl, format: "webp", width: 200, height: 200, }); const desktopImg = await getImage({ src: desktopImgUrl, format: "webp", width: 800, height: 200, }); --- <picture> <source media="(max-width: 799px)" srcset={mobileImg.src} /> <source media="(min-width: 800px)" srcset={desktopImg.src} /> <img src={desktopImg.src} alt={alt} /> </picture> ``` 5. Import and use `<MyCustomImageComponent />` in any `.astro` file. Be sure to pass the necessary props for generating two different images at the different viewport sizes: src/pages/index.astro ```astro --- import MyCustomImageComponent from "../components/MyCustomImageComponent.astro"; import mobileImage from "../images/mobile-profile-image.jpg"; import desktopImage from "../images/desktop-profile-image.jpg"; --- <MyCustomImageComponent mobileImgUrl={mobileImage} desktopImgUrl={desktopImage} alt="user profile picture" /> ```

# Build HTML forms in Astro pages

> Learn how to build HTML forms and handle submissions in your frontmatter.

Astro pages that are rendered on demand can both display and handle forms. In this recipe, you’ll use a standard HTML form to submit data to the server. Your frontmatter script will handle the data on the server, sending no JavaScript to the client. ## Prerequisites [Section titled “Prerequisites”](#prerequisites) * An Astro project with a [server adapter](/en/guides/on-demand-rendering/#server-adapters) installed. ## Recipe [Section titled “Recipe”](#recipe) 1. Create or identify a `.astro` page which will contain your form and your handling code. For example, you could add a registration page: src/pages/register.astro ```astro --- --- <h1>Register</h1> ``` 2. Add a `<form>` tag with some inputs to the page. Each input should have a `name` attribute that describes the value of that input. Be sure to include a `<button>` or `<input type="submit">` element to submit the form. src/pages/register.astro ```astro --- --- <h1>Register</h1> <form> <label> Username: <input type="text" name="username" /> </label> <label> Email: <input type="email" name="email" /> </label> <label> Password: <input type="password" name="password" /> </label> <button>Submit</button> </form> ``` 3. Use [validation attributes](https://developer.mozilla.org/en-US/docs/Learn/Forms/Form_validation#using_built-in_form_validation) to provide basic client-side validation that works even if JavaScript is disabled. In this example, * `required` prevents form submission until the field is filled. * `minlength` sets a minimum required length for the input text. * `type="email"` also introduces validation that will only accept a valid email format. src/pages/register.astro ```astro --- --- <h1>Register</h1> <form> <label> Username: <input type="text" name="username" required /> </label> <label> Email: <input type="email" name="email" required /> </label> <label> Password: <input type="password" name="password" required minlength="6" /> </label> <button>Submit</button> </form> ``` 4. The form submission will cause the browser to request the page again. Change the form’s data transfer `method` to `POST` to send the form data as part of the `Request` body, rather than as URL parameters. src/pages/register.astro ```astro --- --- <h1>Register</h1> <form method="POST"> <label> Username: <input type="text" name="username" required /> </label> <label> Email: <input type="email" name="email" required /> </label> <label> Password: <input type="password" name="password" required minlength="6" /> </label> <button>Submit</button> </form> ``` 5. Check for the `POST` method in the frontmatter and access the form data using `Astro.request.formData()`. Wrap this in a `try ... catch` block to handle cases when the `POST` request wasn’t sent by a form and the `formData` is invalid. src/pages/register.astro ```diff --- +export const prerender = false; // Not needed in 'server' mode +if (Astro.request.method === "POST") { +try { +const data = await Astro.request.formData(); +const name = data.get("username"); +const email = data.get("email"); +const password = data.get("password"); +// Do something with the data + } catch (error) { +if (error instanceof Error) { + console.error(error.message); + } + } +} --- <h1>Register</h1> <form method="POST"> <label> Username: <input type="text" name="username" required /> </label> <label> Email: <input type="email" name="email" required /> </label> <label> Password: <input type="password" name="password" required minlength="6" /> </label> <button>Submit</button> </form> ``` 6. Validate the form data on the server. This should include the same validation done on the client to prevent malicious submissions to your endpoint and to support the rare legacy browser that doesn’t have form validation. It can also include validation that can’t be done on the client. For example, this example checks if the email is already in the database. Error messages can be sent back to the client by storing them in an `errors` object and accessing it in the template. src/pages/register.astro ```diff --- export const prerender = false; // Not needed in 'server' mode import { isRegistered, registerUser } from "../../data/users" import { isValidEmail } from "../../utils/isValidEmail"; +const errors = { username: "", email: "", password: "" }; if (Astro.request.method === "POST") { try { const data = await Astro.request.formData(); const name = data.get("username"); const email = data.get("email"); const password = data.get("password"); +if (typeof name !== "string" || name.length < 1) { + errors.username += "Please enter a username. "; + } +if (typeof email !== "string" || !isValidEmail(email)) { + errors.email += "Email is not valid. "; + } else if (await isRegistered(email)) { + errors.email += "Email is already registered. "; + } +if (typeof password !== "string" || password.length < 6) { + errors.password += "Password must be at least 6 characters. "; + } const hasErrors = Object.values(errors).some(msg => msg) if (!hasErrors) { await registerUser({name, email, password}); return Astro.redirect("/login"); } } catch (error) { if (error instanceof Error) { console.error(error.message); } } } --- <h1>Register</h1> <form method="POST"> <label> Username: <input type="text" name="username" /> </label> +{errors.username && <p>{errors.username}</p>} <label> Email: <input type="email" name="email" required /> </label> +{errors.email && <p>{errors.email}</p>} <label> Password: <input type="password" name="password" required minlength="6" /> </label> +{errors.password && <p>{errors.password}</p>} <button>Register</button> </form> ```

# Build forms with API routes

> Learn how to use JavaScript to send form submissions to an API Route.

An HTML form causes the browser to refresh the page or navigate to a new one. To send form data to an API endpoint instead, you must intercept the form submission using JavaScript. This recipe shows you how to send form data to an API endpoint and handle that data. ## Prerequisites [Section titled “Prerequisites”](#prerequisites) * A project with [an adapter for on-demand rendering](/en/guides/on-demand-rendering/) * A [UI Framework integration](/en/guides/framework-components/) installed ## Recipe [Section titled “Recipe”](#recipe) 1. Create a `POST` API endpoint at `/api/feedback` that will receive the form data. Use `request.formData()` to process it. Be sure to validate the form values before you use them. This example sends a JSON object with a message back to the client. src/pages/api/feedback.ts ```ts export const prerender = false; // Not needed in 'server' mode import type { APIRoute } from "astro"; export const POST: APIRoute = async ({ request }) => { const data = await request.formData(); const name = data.get("name"); const email = data.get("email"); const message = data.get("message"); // Validate the data - you'll probably want to do more than this if (!name || !email || !message) { return new Response( JSON.stringify({ message: "Missing required fields", }), { status: 400 } ); } // Do something with the data, then return a success response return new Response( JSON.stringify({ message: "Success!" }), { status: 200 } ); }; ``` 2. Create a form component using your UI framework. Each input should have a `name` attribute that describes the value of that input. Be sure to include a `<button>` or `<input type="submit">` element to submit the form. * Preact src/components/FeedbackForm.tsx ```tsx export default function Form() { return ( <form> <label> Name <input type="text" id="name" name="name" required /> </label> <label> Email <input type="email" id="email" name="email" required /> </label> <label> Message <textarea id="message" name="message" required /> </label> <button>Send</button> </form> ); } ``` * React src/components/FeedbackForm.tsx ```tsx export default function Form() { return ( <form> <label> Name <input type="text" id="name" name="name" required /> </label> <label> Email <input type="email" id="email" name="email" required /> </label> <label> Message <textarea id="message" name="message" required /> </label> <button>Send</button> </form> ); } ``` * Solid src/components/FeedbackForm.tsx ```tsx export default function Form() { return ( <form> <label> Name <input type="text" id="name" name="name" required /> </label> <label> Email <input type="email" id="email" name="email" required /> </label> <label> Message <textarea id="message" name="message" required /> </label> <button>Send</button> </form> ); } ``` * Svelte src/components/FeedbackForm.svelte ```svelte <form> <label> Name <input type="text" id="name" name="name" required /> </label> <label> Email <input type="email" id="email" name="email" required /> </label> <label> Message <textarea id="message" name="message" required /> </label> <button>Send</button> </form> ``` * Vue src/components/FeedbackForm.vue ```vue <template> <form> <label> Name <input type="text" id="name" name="name" required /> </label> <label> Email <input type="email" id="email" name="email" required /> </label> <label> Message <textarea id="message" name="message" required /> </label> <button>Send</button> </form> </template> ``` 3. Create a function that accepts a submit event, then pass it as a `submit` handler to your form. In the function: * Call `preventDefault()` on the event to override the browser’s default submission process. * Create a `FormData` object and send it in a `POST` request to your endpoint using `fetch()`. - Preact src/components/FeedbackForm.tsx ```diff +import { useState } from "preact/hooks"; export default function Form() { +const [responseMessage, setResponseMessage] = useState(""); +async function submit(e: SubmitEvent) { + e.preventDefault(); +const formData = new FormData(e.target as HTMLFormElement); +const response = await fetch("/api/feedback", { method: "POST", body: formData, }); +const data = await response.json(); +if (data.message) { +setResponseMessage(data.message); + } + } return ( <form onSubmit={submit}> <label> Name <input type="text" id="name" name="name" required /> </label> <label> Email <input type="email" id="email" name="email" required /> </label> <label> Message <textarea id="message" name="message" required /> </label> <button>Send</button> +{responseMessage && <p>{responseMessage}</p>} </form> ); } ``` - React src/components/FeedbackForm.tsx ```diff +import { useState } from "react"; +import type { FormEvent } from "react"; export default function Form() { +const [responseMessage, setResponseMessage] = useState(""); +async function submit(e: FormEvent<HTMLFormElement>) { + e.preventDefault(); +const formData = new FormData(e.target as HTMLFormElement); +const response = await fetch("/api/feedback", { method: "POST", body: formData, }); +const data = await response.json(); +if (data.message) { +setResponseMessage(data.message); + } + } return ( <form onSubmit={submit}> <label htmlFor="name"> Name <input type="text" id="name" name="name" autoComplete="name" required /> </label> <label htmlFor="email"> Email <input type="email" id="email" name="email" autoComplete="email" required /> </label> <label htmlFor="message"> Message <textarea id="message" name="message" autoComplete="off" required /> </label> <button>Send</button> +{responseMessage && <p>{responseMessage}</p>} </form> ); } ``` - Solid src/components/FeedbackForm.tsx ```diff +import { createSignal, createResource, Suspense } from "solid-js"; +async function postFormData(formData: FormData) { +const response = await fetch("/api/feedback", { method: "POST", body: formData, }); +const data = await response.json(); +return data; } export default function Form() { +const [formData, setFormData] = createSignal<FormData>(); +const [response] = createResource(formData, postFormData); +function submit(e: SubmitEvent) { + e.preventDefault(); +setFormData(new FormData(e.target as HTMLFormElement)); + } return ( <form onSubmit={submit}> <label> Name <input type="text" id="name" name="name" required /> </label> <label> Email <input type="email" id="email" name="email" required /> </label> <label> Message <textarea id="message" name="message" required /> </label> <button>Send</button> +<Suspense>{response() && <p>{response().message}</p>}</Suspense> </form> ); } ``` - Svelte src/components/FeedbackForm.svelte ```diff <script lang="ts"> +let responseMessage: string; +async function submit(e: SubmitEvent) { + e.preventDefault(); +const formData = new FormData(e.currentTarget as HTMLFormElement); +const response = await fetch("/api/feedback", { method: "POST", body: formData, }); +const data = await response.json(); + responseMessage = data.message; + } </script> <form on:submit={submit}> <label> Name <input type="text" id="name" name="name" required /> </label> <label> Email <input type="email" id="email" name="email" required /> </label> <label> Message <textarea id="message" name="message" required /> </label> <button>Send</button> + {#if responseMessage} <p>{responseMessage}</p> + {/if} </form> ``` - Vue src/components/FeedbackForm.vue ```diff <script setup lang="ts"> +import { ref } from "vue"; +const responseMessage = ref<string>(); +async function submit(e: Event) { + e.preventDefault(); +const formData = new FormData(e.currentTarget as HTMLFormElement); +const response = await fetch("/api/feedback", { method: "POST", body: formData, }); +const data = await response.json(); + responseMessage.value = data.message; +} </script> <template> <form @submit="submit"> <label> Name <input type="text" id="name" name="name" required /> </label> <label> Email <input type="email" id="email" name="email" required /> </label> <label> Message <textarea id="message" name="message" required /> </label> <button>Send</button> <p v-if="responseMessage">{{ responseMessage }}</p> </form> </template> ``` 4. Import and include your `<FeedbackForm />` component on a page. Be sure to use a `client:*` directive to ensure that the form logic is hydrated when you want it to be. * Preact src/pages/index.astro ```astro --- import FeedbackForm from "../components/FeedbackForm" --- <FeedbackForm client:load /> ``` * React src/pages/index.astro ```astro --- import FeedbackForm from "../components/FeedbackForm" --- <FeedbackForm client:load /> ``` * Solid src/pages/index.astro ```astro --- import FeedbackForm from "../components/FeedbackForm" --- <FeedbackForm client:load /> ``` * Svelte src/pages/index.astro ```astro --- import FeedbackForm from "../components/FeedbackForm.svelte" --- <FeedbackForm client:load /> ``` * Vue src/pages/index.astro ```astro --- import FeedbackForm from "../components/FeedbackForm.vue" --- <FeedbackForm client:load /> ```

# Use Bun with Astro

> Learn how to use Bun with your Astro site.

[Bun](https://bun.sh/) is an all-in-one JavaScript runtime & toolkit. See [Bun’s documentation](https://bun.sh/docs) for more information. Caution Using Bun with Astro may reveal rough edges. Some integrations may not work as expected. Consult [Bun’s official documentation for working with Astro](https://bun.sh/guides/ecosystem/astro) for details. If you have any problems using Bun, please [open an Issue on GitHub with Bun directly](https://github.com/oven-sh/bun/issues/new/choose). ## Prerequisites [Section titled “Prerequisites”](#prerequisites) * Bun installed locally on your machine. See the [installation instructions](https://bun.sh/docs/installation) in Bun’s official documentation. ## Create a new Astro project with Bun [Section titled “Create a new Astro project with Bun”](#create-a-new-astro-project-with-bun) Create a new Astro project with Bun using the following `create-astro` command: ```bash bunx create-astro@latest my-astro-project-using-bun ``` ## Install dependencies [Section titled “Install dependencies”](#install-dependencies) If you’re starting a new project using `bunx create-astro`, the CLI will automatically use Bun to install dependencies and you can skip this step. Otherwise, you’ll need to install your dependencies with Bun: ```bash bun install ``` ## Add Types [Section titled “Add Types”](#add-types) Bun publishes the [`@types/bun`](https://www.npmjs.com/package/@types/bun) package, containing the runtime types for Bun. Install `@types/bun` using the following command: ```sh bun add -d @types/bun ``` ## Using Astro integrations [Section titled “Using Astro integrations”](#using-astro-integrations) You can also use any of the official Astro integrations with the `astro add` command: ```bash bunx astro add react ``` ## Run Astro with Bun [Section titled “Run Astro with Bun”](#run-astro-with-bun) ### Run the development server [Section titled “Run the development server”](#run-the-development-server) To run the development server using Bun as the runtime, use the following command: ```bash bunx --bun astro dev ``` ### Building your site with Bun [Section titled “Building your site with Bun”](#building-your-site-with-bun) To build your site using Bun as the runtime, use the following command: ```bash bunx --bun astro build ``` Astro will output your site to the `dist/` directory. Then, you can serve your site using the `preview` command: ```bash bunx --bun astro preview ``` ## Add SSR with Bun [Section titled “Add SSR with Bun”](#add-ssr-with-bun) Since Bun features [Node.js API compatibility](https://bun.sh/docs/runtime/nodejs-apis), you can use any Astro adapter for [on-demand rendering](/en/guides/on-demand-rendering/) with your Astro project: ```bash bunx astro add vercel ``` ## Testing in Bun [Section titled “Testing in Bun”](#testing-in-bun) Bun ships with a fast, built-in, Jest-compatible test runner through the `bun test` command. If you like to use that read [`bun test` documentation](https://bun.sh/docs/cli/test). However, it is also possible to use Cypress or Playwright for a modern approach to testing web apps. ### Cypress [Section titled “Cypress”](#cypress) Cypress is a front-end testing tool and is on a mission to “make the testing experience enjoyable and generate developer happiness”. This enables you to write end-to-end tests for your Astro site. Install Cypress with the following command: ```bash bun add cypress --dev ``` For the rest of the configuration and to start your first test, follow the rest of Cypress process in the [Astro Testing Guide](/en/guides/testing/#configuration). ### Playwright [Section titled “Playwright”](#playwright) Playwright is an end-to-end testing framework that allows you to test your Astro code on all modern rendering engines including Chromium, WebKit, and Firefox. Install Playwright using the following command: ```bash bun create playwright ``` To create your first Playwright test, follow the instructions for the rest of the Playwright process in the [Astro Testing Guide](/en/guides/testing/#create-your-first-playwright-test). ## Official Resources [Section titled “Official Resources”](#official-resources) * [Build an app with Astro and Bun](https://bun.sh/guides/ecosystem/astro) ## Community Resources [Section titled “Community Resources”](#community-resources) Using Bun with Astro? Add your blog post or video to this page! * [Building a Cloudflare Pages site with Bun](https://blog.otterlord.dev/posts/hello-from-bun/) - blog post * [Using Bun with Astro and Cloudflare Pages](https://handerson.hashnode.dev/using-bun-with-astro-and-cloudflare-pages) - blog post

# Call endpoints from the server

> Learn how to call endpoints from the server in Astro.

Endpoints can be used to serve many kinds of data. This recipe calls a server endpoint from a page’s component script to display a greeting, without requiring an additional fetch request. ## Prerequisites [Section titled “Prerequisites”](#prerequisites) * A project with [SSR](/en/guides/on-demand-rendering/) (output: ‘server’) enabled ## Recipe [Section titled “Recipe”](#recipe) 1. Create an endpoint in a new file `src/pages/api/hello.ts` that returns some data: src/pages/api/hello.ts ```ts import type { APIRoute } from 'astro' export const GET: APIRoute = () => { return new Response( JSON.stringify({ greeting: 'Hello', }), ) } ``` 2. On any Astro page, import the `GET()` method from the endpoint. Call it with the [`Astro` global](/en/reference/api-reference/) to provide the request context, and use the response on the page: src/pages/index.astro ```astro --- import { GET } from './api/hello.ts' let response = await GET(Astro) const data = await response.json() --- <h1>{data.greeting} world!</h1> ```

# Verify a Captcha

> Learn how to create an API route and fetch it from the client.

[Server endpoints](/en/guides/endpoints/#server-endpoints-api-routes) can be used as REST API endpoints to run functions such as authentications, database access, and verifications without exposing sensitive data to the client. In this recipe, an API route is used to verify Google reCAPTCHA v3 without exposing the secret to clients. ## Prerequisites [Section titled “Prerequisites”](#prerequisites) * A project with [SSR](/en/guides/on-demand-rendering/) (`output: 'server'`) enabled ## Recipe [Section titled “Recipe”](#recipe) 1. Create a `POST` endpoint that accepts recaptcha data, then verifies it with reCAPTCHA’s API. Here, you can safely define secret values or read environment variables. src/pages/recaptcha.js ```js export async function POST({ request }) { const data = await request.json(); const recaptchaURL = 'https://www.google.com/recaptcha/api/siteverify'; const requestHeaders = { 'Content-Type': 'application/x-www-form-urlencoded' }; const requestBody = new URLSearchParams({ secret: "YOUR_SITE_SECRET_KEY", // This can be an environment variable response: data.recaptcha // The token passed in from the client }); const response = await fetch(recaptchaURL, { method: "POST", headers: requestHeaders, body: requestBody.toString() }); const responseData = await response.json(); return new Response(JSON.stringify(responseData), { status: 200 }); } ``` 2. Access your endpoint using `fetch` from a client script: src/pages/index.astro ```astro <html> <head> <script is:inline src="https://www.google.com/recaptcha/api.js"></script> </head> <body> <button class="g-recaptcha" data-sitekey="PUBLIC_SITE_KEY" data-callback="onSubmit" data-action="submit"> Click me to verify the captcha challenge! </button> <script is:inline> function onSubmit(token) { fetch("/recaptcha", { method: "POST", body: JSON.stringify({ recaptcha: token }) }) .then((response) => response.json()) .then((gResponse) => { if (gResponse.success) { // Captcha verification was a success } else { // Captcha verification failed } }) } </script> </body> </html> ```

# Customize file names in the build output

> Learn how to change the default naming pattern for your built assets like JavaScript, CSS, and images in Astro using Vite's Rollup options.

By default, the `astro build` command outputs your built assets from [your project source](/en/basics/project-structure/#src), like JavaScript and CSS files located in the `src/` directory, into an `_astro` directory with hashed filenames (e.g. `_astro/index.DRf8L97S.js`) which are excellent for long-term caching. Although it is normally not necessary, you can customise the output file names when needed. For example, this can be helpful if you have scripts with names that might trigger ad blockers (e.g. `ads.js`), or if you want to organize your assets with a particular naming convention. By customizing Rollup output options, you can gain more control over your project’s build structure, allowing you to meet specific organizational or deployment requirements. ## Recipe [Section titled “Recipe”](#recipe) This recipe configures `vite.build.rollupOptions` to output built assets with the following structure and naming pattern: * JavaScript entry files (e.g. scripts directly associated with your pages or layouts): `dist/js/[name]-[hash].js` * JavaScript code-split chunks (e.g. dynamically imported components or shared modules): `dist/js/chunks/[name]-[hash].js` * Other assets (e.g. CSS, images, fonts): `dist/static/[name]-[hash][extname]` (e.g. `dist/static/styles-a1b2c3d4.css`, `dist/static/logo-e5f6g7h8.svg`) 1. Add Vite Rollup Output Options. Modify your `astro.config.mjs` to include the following `vite.build.rollupOptions.output` configuration. This is where you can define the custom naming patterns for your assets using Rollup’s [`entryFileNames`](https://rollupjs.org/configuration-options/#output-entryfilenames), [`chunkFileNames`](https://rollupjs.org/configuration-options/#output-chunkfilenames), and [`assetFileNames`](https://rollupjs.org/configuration-options/#output-assetfilenames): astro.config.mjs ```javascript import { defineConfig } from 'astro/config'; export default defineConfig({ // ... vite: { build: { rollupOptions: { output: { // path names relative to `outDir` entryFileNames: 'js/[name]-[hash].js', chunkFileNames: 'js/chunks/[name]-[hash].js', assetFileNames: 'static/[name]-[hash][extname]', }, }, }, }, }); ``` This example uses the following file name placeholders: * `[name]`: The original name of the file (without the extension and path). * `[hash]`: A content-based hash generated for the file, crucial for cache busting. You can also specify a length, e.g. `[hash:8]`. This ensures that when you update an asset, the filename changes, forcing browsers to download the new version instead of serving a stale cached version. * `[extname]`: The original file extension, including the leading dot (e.g. `.js`, `.css`, `.svg`). For a full list of available placeholders and advanced patterns for these options, refer to the [Rollup configuration documentation](https://rollupjs.org/configuration-options/). 2. Build your project. Since these filename customizations apply to the production build output only, you will need to run your project’s build command: * npm ```shell npm run build ``` * pnpm ```shell pnpm build ``` * Yarn ```shell yarn build ``` 3. After the build completes, inspect your [output directory](/en/reference/configuration-reference/#outdir) (`dist/` by default). Verify that the build assets from your project `src` are named and organized according to the new patterns. (Files from [your `public/` directory](/en/basics/project-structure/#public) are copied directly to the output directory and are not affected by these Rollup naming options.) Depending on your project’s specific contents, your build folder will now look something like this:

# Build your Astro site with Docker

> Learn how to build your Astro site using Docker.

[Docker](https://docker.com) is a tool to build, deploy, and run applications using containers. Docker images and containers can be deployed to many different platforms, like AWS, Azure, and [Google Cloud](/en/guides/deploy/google-cloud/#cloud-run-ssr-and-static). This recipe won’t cover how to deploy your site to a specific platform but will show you how to set up Docker for your project. ## Prerequisites [Section titled “Prerequisites”](#prerequisites) * Docker installed on your local machine. You can find [installation instructions for your operating system here](https://docs.docker.com/get-docker/). * A Dockerfile in your project. You can [learn more about Dockerfiles here](https://docs.docker.com/engine/reference/builder/) and use the Dockerfiles in the following section as a starting point. ## Creating a Dockerfile [Section titled “Creating a Dockerfile”](#creating-a-dockerfile) Create a file called `Dockerfile` in your project’s root directory. This file contains the instructions to build your site, which will differ depending on your needs. This guide can’t show all possible options but will give you starting points for SSR and static mode. If you’re using another package manager than npm, you’ll need to adjust the commands accordingly. ### SSR [Section titled “SSR”](#ssr) This Dockerfile will build your site and serve it using Node.js on port `4321` and therefore requires the [Node adapter](/en/guides/integrations-guide/node/) installed in your Astro project. Dockerfile ```docker FROM node:lts AS runtime WORKDIR /app COPY . . RUN npm install RUN npm run build ENV HOST=0.0.0.0 ENV PORT=4321 EXPOSE 4321 CMD node ./dist/server/entry.mjs ``` ### Adding a .dockerignore [Section titled “Adding a .dockerignore”](#adding-a-dockerignore) Adding a `.dockerignore` file to your project is best practice. This file describes which files or folders should be ignored in the Docker `COPY` or `ADD` commands, very similar to how `.gitignore` works. This speeds up the build process and reduces the size of the final image. .dockerignore ```docker .DS_Store node_modules dist ``` This file should go in the same directory as the `Dockerfile` itself. [Read the `.dockerignore` documentation for extra info](https://docs.docker.com/engine/reference/builder/#dockerignore-file) ### Static [Section titled “Static”](#static) #### Apache (httpd) [Section titled “Apache (httpd)”](#apache-httpd) The following Dockerfile will build your site and serve it using Apache httpd on port `80` with the default configuration. Dockerfile ```docker FROM node:lts AS build WORKDIR /app COPY . . RUN npm i RUN npm run build FROM httpd:2.4 AS runtime COPY --from=build /app/dist /usr/local/apache2/htdocs/ EXPOSE 80 ``` Recommendation Use this approach for simple websites that don’t need any special configuration. For more complex websites, it is recommended to use a custom configuration, either in Apache or NGINX. #### NGINX [Section titled “NGINX”](#nginx) Dockerfile ```docker FROM node:lts AS build WORKDIR /app COPY package*.json ./ RUN npm install COPY . . RUN npm run build FROM nginx:alpine AS runtime COPY ./nginx/nginx.conf /etc/nginx/nginx.conf COPY --from=build /app/dist /usr/share/nginx/html EXPOSE 8080 ``` In order to build the Dockerfile above, you’ll also need to create a configuration file for NGINX. Create a folder called `nginx` in your project’s root directory and create a file called `nginx.conf` inside. nginx.conf ```nginx worker_processes 1; events { worker_connections 1024; } http { server { listen 8080; server_name _; root /usr/share/nginx/html; index index.html index.htm; include /etc/nginx/mime.types; gzip on; gzip_min_length 1000; gzip_proxied expired no-cache no-store private auth; gzip_types text/plain text/css application/json application/javascript application/x-javascript text/xml application/xml application/xml+rss text/javascript; error_page 404 /404.html; location = /404.html { root /usr/share/nginx/html; internal; } location / { try_files $uri $uri/index.html =404; } } } ``` ### Multi-stage build (using SSR) [Section titled “Multi-stage build (using SSR)”](#multi-stage-build-using-ssr) Here’s an example of a more advanced Dockerfile that, thanks to Docker’s [multi-stage builds](https://docs.docker.com/build/building/multi-stage/), optimizes the build process for your site by not reinstalling the npm dependencies when only the source code changes. This can reduce the build time even by minutes, depending on the size of your dependencies. Dockerfile ```docker FROM node:lts AS base WORKDIR /app # By copying only the package.json and package-lock.json here, we ensure that the following `-deps` steps are independent of the source code. # Therefore, the `-deps` steps will be skipped if only the source code changes. COPY package.json package-lock.json ./ FROM base AS prod-deps RUN npm install --omit=dev FROM base AS build-deps RUN npm install FROM build-deps AS build COPY . . RUN npm run build FROM base AS runtime COPY --from=prod-deps /app/node_modules ./node_modules COPY --from=build /app/dist ./dist ENV HOST=0.0.0.0 ENV PORT=4321 EXPOSE 4321 CMD node ./dist/server/entry.mjs ``` ## Recipe [Section titled “Recipe”](#recipe) 1. Build your container by running the following command in your project’s root directory. Use any name for `<your-astro-image-name>`: ```bash docker build -t <your-astro-image-name> . ``` This will output an image, which you can run locally or deploy to a platform of your choice. 2. To run your image as a local container, use the following command. Replace `<local-port>` with an open port on your machine. Replace `<container-port>` with the port exposed by your Docker container (`4321`, `80`, or `8080` in the above examples.) ```bash docker run -p <local-port>:<container-port> <your-astro-image-name> ``` You should be able to access your site at `http://localhost:<local-port>`. 3. Now that your website is successfully built and packaged in a container, you can deploy it to a cloud provider. See the [Google Cloud](/en/guides/deploy/google-cloud/#cloud-run-ssr-and-static) deployment guide for one example, and the [Deploy your app](https://docs.docker.com/language/nodejs/deploy/) page in the Docker docs.

# Dynamically import images

> Learn how to dynamically import images using Vite's import.meta.glob function.

Local [images](/en/guides/images/) must be imported into `.astro` files in order to display them. There will be times where you will want or need to dynamically import the image paths of your images instead of explicitly importing each individual image. In this recipe, you will learn how to dynamically import your images using Vite’s `import.meta.glob` function. You will build a card component that displays the name, age, and photo of a person. ## Recipe [Section titled “Recipe”](#recipe) 1. Create a new `assets` folder under the `src` directory and add your images inside that new folder. 2. Create a new Astro component for your card and import the `<Image />` component. src/components/MyCustomCardComponent.astro ```astro --- import { Image } from 'astro:assets'; --- ``` 3. Specify the `props` that your component will receive in order to display the necessary information on each card. You can optionally define their types, if you are using TypeScript in your project. src/components/MyCustomCardComponent.astro ```diff --- import { Image } from 'astro:assets'; +interface Props { + imagePath: string; + altText: string; + name: string; + age: number; +} +const { imagePath, altText, name, age } = Astro.props; --- ``` 4. Create a new `images` variable and use the `import.meta.glob` function which returns an object of all of the image paths inside the `assets` folder. You will also need to import `ImageMetadata` type to help define the type of the `images` variable. src/components/MyCustomCardComponent.astro ```diff --- +import type { ImageMetadata } from 'astro'; import { Image } from 'astro:assets'; interface Props { imagePath: string; altText: string; name: string; age: number; } const { imagePath, altText, name, age } = Astro.props; +const images = import.meta.glob<{ default: ImageMetadata }>('/src/assets/*.{jpeg,jpg,png,gif}') --- ``` 5. Use the props to create the markup for your card component. src/components/MyCustomCardComponent.astro ```diff --- import type { ImageMetadata } from 'astro'; import { Image } from 'astro:assets'; interface Props { imagePath: string; altText: string; name: string; age: number; } const { imagePath, altText, name, age } = Astro.props; const images = import.meta.glob<{ default: ImageMetadata }>('/src/assets/*.{jpeg,jpg,png,gif}'); --- <div class="card"> <h2>{name}</h2> <p>Age: {age}</p> +<Image src={} alt={altText} /> </div> ``` 6. Inside the `src` attribute, pass in the `images` object and use bracket notation for the image path. Then make sure to invoke the glob function. Since you are accessing the `images` object which has an unknown type, you should also `throw` an error in case an invalid file path is passed as a prop. src/components/MyCustomCardComponent.astro ```diff --- import type { ImageMetadata } from 'astro'; import { Image } from 'astro:assets'; interface Props { imagePath: string; altText: string; name: string; age: number; } const { imagePath, altText, name, age } = Astro.props; const images = import.meta.glob<{ default: ImageMetadata }>('/src/assets/*.{jpeg,jpg,png,gif}'); +if (!images[imagePath]) throw new Error(`"${imagePath}" does not exist in glob: "src/assets/*.{jpeg,jpg,png,gif}"`); --- <div class="card"> <h2>{name}</h2> <p>Age: {age}</p> <Image src={images[imagePath]()} alt={altText} /> </div> ``` 7. Import and use the card component inside an Astro page, passing in the values for the `props`. src/pages/index.astro ```astro --- import MyCustomCardComponent from '../components/MyCustomCardComponent.astro'; --- <MyCustomCardComponent imagePath="/src/assets/avatar-1.jpg" altText="A headshot of Priya against a brick wall background." name="Priya" age={25} /> ```

# Add icons to external links

> Learn how to install a rehype plugin to add icons to external links in your Markdown files.

Using a rehype plugin, you can identify and modify links in your Markdown files that point to external sites. This example adds icons to the end of each external link, so that visitors will know they are leaving your site. ## Prerequisites [Section titled “Prerequisites”](#prerequisites) * An Astro project using Markdown for content pages. ## Recipe [Section titled “Recipe”](#recipe) 1. Install the `rehype-external-links` plugin. * npm ```shell npm install rehype-external-links ``` * pnpm ```shell pnpm add rehype-external-links ``` * Yarn ```shell yarn add rehype-external-links ``` 2. Import the plugin into your `astro.config.mjs` file. Pass `rehypeExternalLinks` to the `rehypePlugins` array, along with an options object that includes a content property. Set this property’s `type` to `text` if you want to add plain text to the end of the link. To add HTML to the end of the link instead, set the property `type` to `raw`. ```ts // ... import rehypeExternalLinks from 'rehype-external-links'; export default defineConfig({ // ... markdown: { rehypePlugins: [ [ rehypeExternalLinks, { content: { type: 'text', value: ' 🔗' } } ], ] }, }); ``` ## Resources [Section titled “Resources”](#resources) * [rehype-external-links](https://www.npmjs.com/package/rehype-external-links)

# Add i18n features

> Use dynamic routing and content collections to add internationalization support to your Astro site.

In this recipe, you will learn how to use content collections and dynamic routing to build your own internationalization (i18n) solution and serve your content in different languages. This example serves each language at its own subpath, e.g. `example.com/en/blog` for English and `example.com/fr/blog` for French. If you prefer the default language to not be visible in the URL unlike other languages, there are [instructions to hide the default language](/en/recipes/i18n/#hide-default-language-in-the-url) below. See the [resources section](#resources) for external links to related topics such as right-to-left (RTL) styling and choosing language tags. ## Recipe [Section titled “Recipe”](#recipe) ### Set up pages for each language [Section titled “Set up pages for each language”](#set-up-pages-for-each-language) 1. Create a directory for each language you want to support. For example, `en/` and `fr/` if you are supporting English and French: 2. Set up `src/pages/index.astro` to redirect to your default language. * Static src/pages/index.astro ```astro <meta http-equiv="refresh" content="0;url=/en/" /> ``` This approach uses a [meta refresh](https://en.wikipedia.org/wiki/Meta_refresh) and will work however you deploy your site. Some static hosts also let you configure server redirects with a custom configuration file. See your deploy platform’s documentation for more details. * On demand If you are using an SSR adapter, you can use [`Astro.redirect`](/en/guides/routing/#dynamic-redirects) to redirect to the default language on the server. src/pages/index.astro ```astro --- return Astro.redirect('/en/'); --- ``` ### Use collections for translated content [Section titled “Use collections for translated content”](#use-collections-for-translated-content) 1. Create a folder in `src/content/` for each type of content you want to include and add subdirectories for each supported language. For example, to support English and French blog posts: 2. Create a `src/content.config.ts` file and export a collection for each type of content. src/content.config.ts ```ts import { defineCollection, z } from 'astro:content'; const blogCollection = defineCollection({ schema: z.object({ title: z.string(), author: z.string(), date: z.date() }) }); export const collections = { 'blog': blogCollection }; ``` Read more about [Content Collections](/en/guides/content-collections/). 3. Use [dynamic routes](/en/guides/routing/#dynamic-routes) to fetch and render content based on a `lang` and a `slug` parameter. * Static In static rendering mode, use `getStaticPaths` to map each content entry to a page: src/pages/\[lang]/blog/\[...slug].astro ```astro --- import { getCollection, render } from 'astro:content'; export async function getStaticPaths() { const pages = await getCollection('blog'); const paths = pages.map(page => { const [lang, ...slug] = page.id.split('/'); return { params: { lang, slug: slug.join('/') || undefined }, props: page }; }); return paths; } const { lang, slug } = Astro.params; const page = Astro.props; const formattedDate = page.data.date.toLocaleString(lang); const { Content } = await render(page); --- <h1>{page.data.title}</h1> <p>by {page.data.author} • {formattedDate}</p> <Content/> ``` * On demand In [SSR mode](/en/guides/on-demand-rendering/), fetch the requested entry directly: src/pages/\[lang]/blog/\[...slug].astro ```astro --- import { getEntry, render } from 'astro:content'; const { lang, slug } = Astro.params; const page = await getEntry('blog', `${lang}/${slug}`); if (!page) { return Astro.redirect('/404'); } const formattedDate = page.data.date.toLocaleString(lang); const { Content, headings } = await render(page); --- <h1>{page.data.title}</h1> <p>by {page.data.author} • {formattedDate}</p> <Content/> ``` Read more about [dynamic routing](/en/guides/routing/#dynamic-routes). ### Translate UI strings [Section titled “Translate UI strings”](#translate-ui-strings) Create dictionaries of terms to translate the labels for UI elements around your site. This allows your visitors to experience your site fully in their language. 1. Create a `src/i18n/ui.ts` file to store your translation strings: src/i18n/ui.ts ```ts export const languages = { en: 'English', fr: 'Français', }; export const defaultLang = 'en'; export const ui = { en: { 'nav.home': 'Home', 'nav.about': 'About', 'nav.twitter': 'Twitter', }, fr: { 'nav.home': 'Accueil', 'nav.about': 'À propos', }, } as const; ``` 2. Create two helper functions: one to detect the page language based on the current URL, and one to get translations strings for different parts of the UI in `src/i18n/utils.ts`: src/i18n/utils.ts ```js import { ui, defaultLang } from './ui'; export function getLangFromUrl(url: URL) { const [, lang] = url.pathname.split('/'); if (lang in ui) return lang as keyof typeof ui; return defaultLang; } export function useTranslations(lang: keyof typeof ui) { return function t(key: keyof typeof ui[typeof defaultLang]) { return ui[lang][key] || ui[defaultLang][key]; } } ``` 3. Import the helpers where needed and use them to choose the UI string that corresponds to the current language. For example, a nav component might look like: src/components/Nav.astro ```astro --- import { getLangFromUrl, useTranslations } from '../i18n/utils'; const lang = getLangFromUrl(Astro.url); const t = useTranslations(lang); --- <ul> <li> <a href={`/${lang}/home/`}> {t('nav.home')} </a> </li> <li> <a href={`/${lang}/about/`}> {t('nav.about')} </a> </li> <li> <a href="https://twitter.com/astrodotbuild"> {t('nav.twitter')} </a> </li> </ul> ``` 4. Each page must have a `lang` attribute on the `<html>` element that matches the language on the page. In this example, a [reusable layout](/en/basics/layouts/) extracts the language from the current route: src/layouts/Base.astro ```astro --- import { getLangFromUrl } from '../i18n/utils'; const lang = getLangFromUrl(Astro.url); --- <html lang={lang}> <head> <meta charset="utf-8" /> <link rel="icon" type="image/svg+xml" href="/favicon.svg" /> <meta name="viewport" content="width=device-width" /> <title>Astro</title> </head> <body> <slot /> </body> </html> ``` You can then use this base layout to ensure that pages use the correct `lang` attribute automatically. src/pages/en/about.astro ```astro --- import Base from '../../layouts/Base.astro'; --- <Base> <h1>About me</h1> ... </Base> ``` ### Let users switch between languages [Section titled “Let users switch between languages”](#let-users-switch-between-languages) Create links to the different languages you support so users can choose the language they want to read your site in. 1. Create a component to show a link for each language: src/components/LanguagePicker.astro ```astro --- import { languages } from '../i18n/ui'; --- <ul> {Object.entries(languages).map(([lang, label]) => ( <li> <a href={`/${lang}/`}>{label}</a> </li> ))} </ul> ``` 2. Add `<LanguagePicker />` to your site so it is shown on every page. The example below adds it to the site footer in a base layout: src/layouts/Base.astro ```diff --- +import LanguagePicker from '../components/LanguagePicker.astro'; import { getLangFromUrl } from '../i18n/utils'; const lang = getLangFromUrl(Astro.url); --- <html lang={lang}> <head> <meta charset="utf-8" /> <link rel="icon" type="image/svg+xml" href="/favicon.svg" /> <meta name="viewport" content="width=device-width" /> <title>Astro</title> </head> <body> <slot /> <footer> +<LanguagePicker /> </footer> </body> </html> ``` ### Hide default language in the URL [Section titled “Hide default language in the URL”](#hide-default-language-in-the-url) 1. Create a directory for each language except the default language. For example, store your default language pages directly in `pages/`, and your translated pages in `fr/`: 2. Add another line to the `src/i18n/ui.ts` file to toggle the feature: src/i18n/ui.ts ```ts export const showDefaultLang = false; ``` 3. Add a helper function to `src/i18n/utils.ts`, to translate paths based on the current language: src/i18n/utils.ts ```js import { ui, defaultLang, showDefaultLang } from './ui'; export function useTranslatedPath(lang: keyof typeof ui) { return function translatePath(path: string, l: string = lang) { return !showDefaultLang && l === defaultLang ? path : `/${l}${path}` } } ``` 4. Import the helper where needed. For example, a `nav` component might look like: src/components/Nav.astro ```astro --- import { getLangFromUrl, useTranslations, useTranslatedPath } from '../i18n/utils'; const lang = getLangFromUrl(Astro.url); const t = useTranslations(lang); const translatePath = useTranslatedPath(lang); --- <ul> <li> <a href={translatePath('/home/')}> {t('nav.home')} </a> </li> <li> <a href={translatePath('/about/')}> {t('nav.about')} </a> </li> <li> <a href="https://twitter.com/astrodotbuild"> {t('nav.twitter')} </a> </li> </ul> ``` 5. The helper function can also be used to translate paths for a specific language. For example, when users switch between languages: src/components/LanguagePicker.astro ```astro --- import { languages } from '../i18n/ui'; import { getLangFromUrl, useTranslatedPath } from '../i18n/utils'; const lang = getLangFromUrl(Astro.url); const translatePath = useTranslatedPath(lang); --- <ul> {Object.entries(languages).map(([lang, label]) => ( <li> <a href={translatePath('/', lang)}>{label}</a> </li> ))} </ul> ``` ### Translate Routes [Section titled “Translate Routes”](#translate-routes) Translate the routes of your pages for each language. 1. Add route mappings to `src/i18n/ui.ts`: src/i18n/ui.ts ```ts export const routes = { de: { 'services': 'leistungen', }, fr: { 'services': 'prestations-de-service', }, } ``` 2. Update the `useTranslatedPath` helper function in `src/i18n/utils.ts` to add router translation logic. src/i18n/utils.ts ```js import { ui, defaultLang, showDefaultLang, routes } from './ui'; export function useTranslatedPath(lang: keyof typeof ui) { return function translatePath(path: string, l: string = lang) { const pathName = path.replaceAll('/', '') const hasTranslation = defaultLang !== l && routes[l] !== undefined && routes[l][pathName] !== undefined const translatedPath = hasTranslation ? '/' + routes[l][pathName] : path return !showDefaultLang && l === defaultLang ? translatedPath : `/${l}${translatedPath}` } } ``` 3. Create a helper function to get the route, if it exists based on the current URL, in `src/i18n/utils.ts`: src/i18n/utils.ts ```js import { ui, defaultLang, showDefaultLang, routes } from './ui'; export function getRouteFromUrl(url: URL): string | undefined { const pathname = new URL(url).pathname; const parts = pathname?.split('/'); const path = parts.pop() || parts.pop(); if (path === undefined) { return undefined; } const currentLang = getLangFromUrl(url); if (defaultLang === currentLang) { const route = Object.values(routes)[0]; return route[path] !== undefined ? route[path] : undefined; } const getKeyByValue = (obj: Record<string, string>, value: string): string | undefined => { return Object.keys(obj).find((key) => obj[key] === value); } const reversedKey = getKeyByValue(routes[currentLang], path); if (reversedKey !== undefined) { return reversedKey; } return undefined; } ``` 4. The helper function can be used to get a translated route. For example, when no translated route is defined, the user will be redirected to the home page: src/components/LanguagePicker.astro ```astro --- import { languages } from '../i18n/ui'; import { getRouteFromUrl, useTranslatedPath } from '../i18n/utils'; const route = getRouteFromUrl(Astro.url); --- <ul> {Object.entries(languages).map(([lang, label]) => { const translatePath = useTranslatedPath(lang); return ( <li> <a href={translatePath(`/${route ? route : ''}`)}>{label}</a> </li> ) })} </ul> ``` ## Resources [Section titled “Resources”](#resources) * [Choosing a Language Tag](https://www.w3.org/International/questions/qa-choosing-language-tags) * [Right-to-left (RTL) Styling 101](https://rtlstyling.com/) ## Community libraries [Section titled “Community libraries”](#community-libraries) * [astro-i18next](https://github.com/yassinedoghri/astro-i18next) — An Astro integration for i18next including some utility components. * [astro-i18n](https://github.com/alexandre-fernandez/astro-i18n) — A TypeScript-first internationalization library for Astro. * [astro-i18n-aut](https://github.com/jlarmstrongiv/astro-i18n-aut) — An Astro integration for i18n that supports the `defaultLocale` without page generation. The integration is adapter agnostic and UI framework agnostic. * [astro-react-i18next](https://github.com/jeremyxgo/astro-react-i18next) — An Astro integration that seamlessly enables the use of i18next and react-i18next in React components on Astro websites. * [paraglide](https://inlang.com/c/astro) — A fully type-safe i18n library specifically designed for partial hydration patterns like Astro islands. * [astro-loader-i18n](https://github.com/openscript/astro-loader-i18n) — An Astro glob content loader for i18n files and folder structures supporting the translation of routes.

# Create a dev toolbar app

> Learn how to create a dev toolbar app for your site.

Astro includes a [development toolbar](/en/guides/dev-toolbar/) that you can use to inspect your site, check for accessibility and performance issues, and more. This toolbar can be extended with custom apps. ## Build a motivational dev toolbar app [Section titled “Build a motivational dev toolbar app”](#build-a-motivational-dev-toolbar-app) In this recipe, you’ll learn how to create a dev toolbar app that helps you stay motivated while working on your site. This app will display a motivational message every time you toggle it on. ### Creating the Astro integration [Section titled “Creating the Astro integration”](#creating-the-astro-integration) Dev toolbar apps can only be added by [Astro Integrations](/en/guides/integrations-guide/) using [the `astro:config:setup` hook](/en/reference/integrations-reference/#astroconfigsetup). You will need to create both a toolbar app and the integration that will add it to the toolbar of your existing Astro project. 1. In the root of your existing Astro project, create a new folder named `my-toolbar-app/` for your app and integration files. Create two new files in this folder: `app.ts` and `my-integration.ts`. * astro.config.mjs * package.json * tsconfig.json 2. In `my-integration.ts`, add the following code to provide both the name of your integration and the [`addDevToolbarApp()` function](/en/reference/dev-toolbar-app-reference/#toolbar-app-integration-setup) needed to add your dev toolbar app with the `astro:config:setup` hook: my-toolbar-app/my-integration.ts ```ts import { fileURLToPath } from 'node:url'; import type { AstroIntegration } from 'astro'; export default { name: 'my-astro-integration', hooks: { 'astro:config:setup': ({ addDevToolbarApp }) => { addDevToolbarApp({ id: "my-toolbar-app", name: "My Toolbar App", icon: "🚀", entrypoint: fileURLToPath(new URL('./app.ts', import.meta.url)) }); }, }, } satisfies AstroIntegration; ``` 3. To use this integration in your project, add it to the `integrations` array in your `astro.config.mjs` file. astro.config.mjs ```diff import { defineConfig } from 'astro/config'; +import myIntegration from './my-toolbar-app/my-integration.ts'; export default defineConfig({ + integrations: [myIntegration], }) ``` 4. If not already running, start the dev server. If your integration has been successfully added to your project, you should see a new “undefined” app in the dev toolbar. But, you will also see an error message that your dev toolbar app has failed to load. This is because you have not yet built the app itself. You will do that in the next section. See the [Astro Integration API documentation](/en/reference/integrations-reference/) for more about building Astro integrations. ### Creating the app [Section titled “Creating the app”](#creating-the-app) Dev toolbar apps are defined using the `defineToolbarApp()` function from the `astro/toolbar` module. This function takes an object with an `init()` function that will be called when the dev toolbar app is loaded. This `init()` function contains your app logic to render elements to the screen, send and receive client-side events from the dev toolbar, and communicate with the server. app.ts ```ts import { defineToolbarApp } from "astro/toolbar"; export default defineToolbarApp({ init(canvas, app, server) { // ... }, }); ``` To display motivational messages on the screen, you will use the `canvas` property to access a standard [ShadowRoot](https://developer.mozilla.org/en-US/docs/Web/API/ShadowRoot). Elements can be created and added to the ShadowRoot using the standard DOM APIs. 1. Copy the following code into `my-toolbar-app/app.ts`. This provides a list of motivational messages, and the logic to create a new `<h1>` element with a random message: my-toolbar-app/app.ts ```ts import { defineToolbarApp } from "astro/toolbar"; const motivationalMessages = [ "You're doing great!", "Keep up the good work!", "You're awesome!", "You're a star!", ]; export default defineToolbarApp({ init(canvas) { const h1 = document.createElement('h1'); h1.textContent = motivationalMessages[Math.floor(Math.random() * motivationalMessages.length)]; canvas.append(h1); }, }); ``` 2. Start the dev server if it is not already running and toggle the app on in the dev toolbar. If your app is working successfully, you will see a motivational message displayed in the top-left corner of the screen. (And, it’s true!) However, this message will not change when the app is toggled on and off, as the `init()` function is only called once when the app is loaded. 3. To add client-side interactivity to your app, add the `app` argument and use `onAppToggled()` to select a new random message each time your toolbar app is toggled on: app.ts ```diff import { defineToolbarApp } from "astro/toolbar"; const motivationalMessages = [ "You're doing great!", "Keep up the good work!", "You're awesome!", "You're a star!", ]; export default defineToolbarApp({ init(canvas, app) { const h1 = document.createElement('h1'); h1.textContent = motivationalMessages[Math.floor(Math.random() * motivationalMessages.length)]; canvas.append(h1); +// Display a random message when the app is toggled + app.onToggled(({ state }) => { +const newMessage = motivationalMessages[Math.floor(Math.random() * motivationalMessages.length)]; + h1.textContent = newMessage; + }); }, }); ``` 4. In your browser preview, toggle your app on and off several times. With this change, a new random message will be selected every time you toggle the app on, providing you with an infinite source of motivation! See the [Astro Dev Toolbar API documentation](/en/reference/dev-toolbar-app-reference/) for more about building dev toolbar apps. ## Building apps with a UI framework [Section titled “Building apps with a UI framework”](#building-apps-with-a-ui-framework) UI frameworks like React, Vue, or Svelte can also be used to create dev toolbar apps. These frameworks provide a more declarative way to create UIs and can make your code more maintainable and easier to read. The same motivational dev toolbar app built into your existing Astro project earlier on this page with JavaScript can be built using a UI framework (e.g. Preact) instead. Depending on your chosen framework, you may or may not require a build step. ### Without a build step [Section titled “Without a build step”](#without-a-build-step) If your framework supports it, you can create a dev toolbar app without a build step. For example, you can use Preact’s `h` function to create elements and render them directly to the ShadowRoot: app.ts ```ts import { defineToolbarApp } from "astro/toolbar"; import { render, h } from "preact"; const motivationalMessages = [ "You're doing great!", "Keep up the good work!", "You're awesome!", "You're a star!", ]; export default defineToolbarApp({ init(canvas) { const message = motivationalMessages[Math.floor(Math.random() * motivationalMessages.length)]; render(h('h1', null, message), canvas); }, }); ``` Alternatively, the [`htm` package](https://github.com/developit/htm) is a good choice for creating dev toolbar apps without a build step, offering native integration for React and Preact and support for other frameworks: app.ts ```diff import { defineToolbarApp } from "astro/toolbar"; import { render } from "preact"; +import { html } from 'htm/preact'; const motivationalMessages = [ "You're doing great!", "Keep up the good work!", "You're awesome!", "You're a star!", ]; export default defineToolbarApp({ init(canvas) { const message = motivationalMessages[Math.floor(Math.random() * motivationalMessages.length)]; +render(html`<h1>${message}</h1>`, canvas); }, }); ``` In both cases, you can now start your project and see the motivational message displayed in the top-left corner of the screen when you toggle the app on. ### With a build step [Section titled “With a build step”](#with-a-build-step) Astro does not preprocess JSX code in dev toolbar apps, so a build step is required in order to use JSX components in your dev toolbar app. The following steps will use TypeScript to do this, but any other tools that compile JSX code will also work (e.g. Babel, Rollup, ESBuild). 1. Install TypeScript inside your project: * npm ```shell npm install --save-dev typescript ``` * pnpm ```shell pnpm install --save-dev typescript ``` * Yarn ```shell yarn add --dev typescript ``` 2. Create a `tsconfig.json` file in the root of your toolbar app’s folder with the appropriate settings to build and for the framework you’re using ([React](https://react-typescript-cheatsheet.netlify.app/docs/basic/setup), [Preact](https://preactjs.com/guide/v10/typescript), [Solid](https://www.solidjs.com/guides/typescript)). For example, for Preact: my-toolbar-app/tsconfig.json ```json { "compilerOptions": { "skipLibCheck": true, "module": "NodeNext", "jsx": "react-jsx", "jsxImportSource": "preact", } } ``` 3. Adjust the `entrypoint` in your integration to point to the compiled file, remembering that this file is relative to the root of your Astro project: my-integration.ts ```ts addDevToolbarApp({ id: "my-toolbar-app", name: "My Toolbar App", icon: "🚀", entrypoint: join(__dirname, "./app.js"), }); ``` 4. Run `tsc` to build your toolbar app, or `tsc --watch` to automatically rebuild your app when you make changes. With these changes, you can now rename your `app.ts` file to `app.tsx` (or `.jsx`) and use JSX syntax to create your dev toolbar app: app.tsx ```tsx import { defineToolbarApp } from "astro/toolbar"; import { render } from "preact"; const motivationalMessages = [ "You're doing great!", "Keep up the good work!", "You're awesome!", "You're a star!", ]; export default defineToolbarApp({ init(canvas) { const message = motivationalMessages[Math.floor(Math.random() * motivationalMessages.length)]; render(<h1>{message}</h1>, canvas); }, }); ``` You should now have all the tools you need to create a dev toolbar app using a UI framework of your choice!

# Add last modified time

> Build a remark plugin to add the last modified time to your Markdown and MDX.

Learn how to build a [remark plugin](https://github.com/remarkjs/remark) that adds the last modified time to the frontmatter of your Markdown and MDX files. Use this property to display the modified time in your pages. ## Recipe [Section titled “Recipe”](#recipe) 1. Install Helper Packages Install [`Day.js`](https://www.npmjs.com/package/dayjs) to modify and format times: * npm ```shell npm install dayjs ``` * pnpm ```shell pnpm add dayjs ``` * Yarn ```shell yarn add dayjs ``` 2. Create a Remark Plugin This plugin uses `execSync` to run a Git command that returns the timestamp of the latest commit in ISO 8601 format. The timestamp is then added to the frontmatter of the file. remark-modified-time.mjs ```js import { execSync } from "child_process"; export function remarkModifiedTime() { return function (tree, file) { const filepath = file.history[0]; const result = execSync(`git log -1 --pretty="format:%cI" "${filepath}"`); file.data.astro.frontmatter.lastModified = result.toString(); }; } ``` 3. Add the plugin to your config astro.config.mjs ```js import { defineConfig } from 'astro/config'; import { remarkModifiedTime } from './remark-modified-time.mjs'; export default defineConfig({ markdown: { remarkPlugins: [remarkModifiedTime], }, }); ``` Now all Markdown documents will have a `lastModified` property in their frontmatter. 4. Display Last Modified Time If your content is stored in a [content collection](/en/guides/content-collections/), access the `remarkPluginFrontmatter` from the `render(entry)` function. Then render `lastModified` in your template wherever you would like it to appear. src/pages/posts/\[slug].astro ```astro --- import { getCollection, render } from 'astro:content'; import dayjs from "dayjs"; import utc from "dayjs/plugin/utc"; dayjs.extend(utc); export async function getStaticPaths() { const blog = await getCollection('blog'); return blog.map(entry => ({ params: { slug: entry.id }, props: { entry }, })); } const { entry } = Astro.props; const { Content, remarkPluginFrontmatter } = await render(entry); const lastModified = dayjs(remarkPluginFrontmatter.lastModified) .utc() .format("HH:mm:ss DD MMMM YYYY UTC"); --- <html> <head>...</head> <body> ... <p>Last Modified: {lastModified}</p> ... </body> </html> ``` If you’re using a [Markdown layout](/en/basics/layouts/#markdown-layouts), use the `lastModified` frontmatter property from `Astro.props` in your layout template. src/layouts/BlogLayout.astro ```astro --- import dayjs from "dayjs"; import utc from "dayjs/plugin/utc"; dayjs.extend(utc); const lastModified = dayjs() .utc(Astro.props.frontmatter.lastModified) .format("HH:mm:ss DD MMMM YYYY UTC"); --- <html> <head>...</head> <body> <p>{lastModified}</p> <slot /> </body> </html> ```

# Add reading time

> Build a remark plugin to add reading time to your Markdown or MDX files.

Create a [remark plugin](https://github.com/remarkjs/remark) which adds a reading time property to the frontmatter of your Markdown or MDX files. Use this property to display the reading time for each page. ## Recipe [Section titled “Recipe”](#recipe) 1. Install Helper Packages Install these two helper packages: * [`reading-time`](https://www.npmjs.com/package/reading-time) to calculate minutes read * [`mdast-util-to-string`](https://www.npmjs.com/package/mdast-util-to-string) to extract all text from your markdown - npm ```shell npm install reading-time mdast-util-to-string ``` - pnpm ```shell pnpm add reading-time mdast-util-to-string ``` - Yarn ```shell yarn add reading-time mdast-util-to-string ``` 2. Create a remark plugin. This plugin uses the `mdast-util-to-string` package to get the Markdown file’s text. This text is then passed to the `reading-time` package to calculate the reading time in minutes. remark-reading-time.mjs ```js import getReadingTime from 'reading-time'; import { toString } from 'mdast-util-to-string'; export function remarkReadingTime() { return function (tree, { data }) { const textOnPage = toString(tree); const readingTime = getReadingTime(textOnPage); // readingTime.text will give us minutes read as a friendly string, // i.e. "3 min read" data.astro.frontmatter.minutesRead = readingTime.text; }; } ``` 3. Add the plugin to your config: astro.config.mjs ```js import { defineConfig } from 'astro/config'; import { remarkReadingTime } from './remark-reading-time.mjs'; export default defineConfig({ markdown: { remarkPlugins: [remarkReadingTime], }, }); ``` Now all Markdown documents will have a calculated `minutesRead` property in their frontmatter. 4. Display Reading Time If your blog posts are stored in a [content collection](/en/guides/content-collections/), access the `remarkPluginFrontmatter` from the `render(entry)` function. Then, render `minutesRead` in your template wherever you would like it to appear. src/pages/posts/\[slug].astro ```astro --- import { getCollection, render } from 'astro:content'; export async function getStaticPaths() { const blog = await getCollection('blog'); return blog.map(entry => ({ params: { slug: entry.id }, props: { entry }, })); } const { entry } = Astro.props; const { Content, remarkPluginFrontmatter } = await render(entry); --- <html> <head>...</head> <body> ... <p>{remarkPluginFrontmatter.minutesRead}</p> ... </body> </html> ``` If you’re using a [Markdown layout](/en/basics/layouts/#markdown-layouts), use the `minutesRead` frontmatter property from `Astro.props` in your layout template. src/layouts/BlogLayout.astro ```astro --- const { minutesRead } = Astro.props.frontmatter; --- <html> <head>...</head> <body> <p>{minutesRead}</p> <slot /> </body> </html> ```

# Add an RSS feed

> Add an RSS feed to your Astro site to let users subscribe to your content.

Astro supports fast, automatic RSS feed generation for blogs and other content websites. RSS feeds provide an easy way for users to subscribe to your content. ## Setting up `@astrojs/rss` [Section titled “Setting up @astrojs/rss”](#setting-up-astrojsrss) The package [`@astrojs/rss`](https://github.com/withastro/astro/tree/main/packages/astro-rss) provides helpers for generating RSS feeds using [API endpoints](/en/guides/endpoints/#static-file-endpoints). This unlocks both static builds *and* on-demand generation when using an [SSR adapter](/en/guides/on-demand-rendering/). 1. Install `@astrojs/rss` using your preferred package manager: * npm ```shell npm install @astrojs/rss ``` * pnpm ```shell pnpm add @astrojs/rss ``` * Yarn ```shell yarn add @astrojs/rss ``` 2. Create a file in `src/pages/` with a name of your choice and the extension `.xml.js` to be used as the output URL for your feed. Some common RSS feed URL names are `feed.xml` or `rss.xml`. The example file below `src/pages/rss.xml.js` will create an RSS feed at `site/rss.xml`. 3. Import the `rss()` helper from the `@astrojs/rss` package into your `.xml.js` file and export a function that returns it using the following parameters: src/pages/rss.xml.js ```js import rss from '@astrojs/rss'; export function GET(context) { return rss({ // `<title>` field in output xml title: 'Buzz’s Blog', // `<description>` field in output xml description: 'A humble Astronaut’s guide to the stars', // Pull in your project "site" from the endpoint context // https://docs.astro.build/en/reference/api-reference/#site site: context.site, // Array of `<item>`s in output xml // See "Generating items" section for examples using content collections and glob imports items: [], // (optional) inject custom xml customData: `<language>en-us</language>`, }); } ``` See the [`@astrojs/rss` README](https://github.com/withastro/astro/tree/main/packages/astro-rss) for the full configuration reference. ## Generating `items` [Section titled “Generating items”](#generating-items) The `items` field accepts a list of RSS feed objects, which can be generated from content collections entries using `getCollection()` or from your page files using `pagesGlobToRssItems()`. The RSS feed standard format includes metadata for each published item, including values such as: * `title`: The title of the entry. Optional only if a `description` is set. Otherwise, required. * `description`: A short excerpt from or describing the entry. Optional only if a `title` is set. Otherwise, required. * `link`: A URL to the original source of the entry. (optional) * `pubDate`: The date of publication of the entry. (optional) * `content`: The full content of your post. (optional) See the [`items` configuration reference](https://github.com/withastro/astro/tree/main/packages/astro-rss#items) for a complete list of options. ### Using content collections [Section titled “Using content collections”](#using-content-collections) To create an RSS feed of pages managed in [content collections](/en/guides/content-collections/), use the `getCollection()` function to retrieve the data required for your `items` array. You will need to specify the values for each desired property (e.g. `title`, `description`) from the returned data. src/pages/rss.xml.js ```js import rss from '@astrojs/rss'; import { getCollection } from 'astro:content'; export async function GET(context) { const blog = await getCollection('blog'); return rss({ title: 'Buzz’s Blog', description: 'A humble Astronaut’s guide to the stars', site: context.site, items: blog.map((post) => ({ title: post.data.title, pubDate: post.data.pubDate, description: post.data.description, // Compute RSS link from post `id` // This example assumes all posts are rendered as `/blog/[id]` routes link: `/blog/${post.id}/`, })), }); } ``` Optional: replace your existing blog collection schema to enforce the expected RSS properties. To ensure that every blog entry produces a valid RSS feed item, you can optionally import and apply `rssSchema` instead of defining each individual property of your schema. src/content.config.ts ```js import { defineCollection } from 'astro:content'; import { rssSchema } from '@astrojs/rss'; const blog = defineCollection({ schema: rssSchema, }); export const collections = { blog }; ``` ### Using glob imports [Section titled “Using glob imports”](#using-glob-imports) **Added in:** `@astrojs/rss@2.1.0` To create an RSS feed from documents in `src/pages/`, use the `pagesGlobToRssItems()` helper. This accepts an [`import.meta.glob`](https://vite.dev/guide/features.html#glob-import) result and outputs an array of valid RSS feed items (see [more about writing glob patterns](/en/guides/imports/#glob-patterns) for specifying which pages to include). Caution This function assumes, but does not verify, that all necessary feed properties are present in each document’s frontmatter. If you encounter errors, verify each page frontmatter manually. src/pages/rss.xml.js ```js import rss, { pagesGlobToRssItems } from '@astrojs/rss'; export async function GET(context) { return rss({ title: 'Buzz’s Blog', description: 'A humble Astronaut’s guide to the stars', site: context.site, items: await pagesGlobToRssItems( import.meta.glob('./blog/*.{md,mdx}'), ), }); } ``` ### Including full post content [Section titled “Including full post content”](#including-full-post-content) **Added in:** `astro@1.6.14` Set the `content` key on `rss.items` to provide the full content of a post as HTML. This allows `@astrojs/rss` to make the full Markdown text of your post available to RSS feed readers. Images and links with full URL paths are also supported. However, images and internal links to other pages using relative paths are not. When rendering full post content, you will have to consider images, relative links, styles, scripts, and other elements beyond standard Markdown text that you may have in your posts. You may need to include additional logic in your `src/pages/rss.xml.js` endpoint to account for these, or to remove elements that are unnecessary for an RSS feed (e.g. those that are used only for styling or interaction on your website). You can see [one specific community implementation](https://github.com/delucis/astro-blog-full-text-rss/blob/latest/src/pages/rss.xml.ts) that addresses some of these concerns for an example of how to proceed. When using content collections, render the post `body` using a standard Markdown parser like [`markdown-it`](https://github.com/markdown-it/markdown-it) and sanitize the result, including any extra tags (e.g. `<img>`) needed to render your content: src/pages/rss.xml.js ```diff import rss from '@astrojs/rss'; import { getCollection } from 'astro:content'; +import sanitizeHtml from 'sanitize-html'; +import MarkdownIt from 'markdown-it'; +const parser = new MarkdownIt(); export async function GET(context) { const blog = await getCollection('blog'); return rss({ title: 'Buzz’s Blog', description: 'A humble Astronaut’s guide to the stars', site: context.site, items: blog.map((post) => ({ link: `/blog/${post.id}/`, // Note: this will not process components or JSX expressions in MDX files. + content: sanitizeHtml(parser.render(post.body), { allowedTags: sanitizeHtml.defaults.allowedTags.concat(['img']) }), ...post.data, })), }); } ``` When using glob imports with Markdown, you may use the `compiledContent()` helper to retrieve the rendered HTML for sanitization. Note: this feature is **not** supported for MDX files. src/pages/rss.xml.js ```diff import rss from '@astrojs/rss'; +import sanitizeHtml from 'sanitize-html'; export async function GET(context) { const postImportResult = import.meta.glob('../posts/**/*.md', { eager: true }); const posts = Object.values(postImportResult); return rss({ title: 'Buzz’s Blog', description: 'A humble Astronaut’s guide to the stars', site: context.site, items: await Promise.all(posts.map(async (post) => ({ link: post.url, + content: sanitizeHtml((await post.compiledContent())), ...post.frontmatter, }))), }); } ``` ## Removing trailing slashes [Section titled “Removing trailing slashes”](#removing-trailing-slashes) Astro’s RSS feed produces links with a trailing slash by default, no matter what value you have configured for `trailingSlash`. This means that your RSS links may not match your post URLs exactly. If you have set `trailingSlash: "never"` on your `astro.config.mjs`, set `trailingSlash: false` in the `rss()` helper so that your feed matches your project configuration. src/pages/rss.xml.js ```diff import rss from '@astrojs/rss'; export function GET(context) { const posts = Object.values(postImportResult); return rss({ title: 'Buzz’s Blog', description: 'A humble Astronaut’s guide to the stars', site: context.site, + trailingSlash: false, items: posts.map((post) => ({ link: post.url, ...post.frontmatter, })), }); } ``` ## Adding a stylesheet [Section titled “Adding a stylesheet”](#adding-a-stylesheet) Style your RSS feed for a more pleasant user experience when viewing the file in your browser. Use the `rss` function’s `stylesheet` option to specify an absolute path to your stylesheet. ```js rss({ // ex. use your stylesheet from "public/rss/styles.xsl" stylesheet: '/rss/styles.xsl', // ... }); ``` ## Enabling RSS feed auto-discovery [Section titled “Enabling RSS feed auto-discovery”](#enabling-rss-feed-auto-discovery) [RSS autodiscovery](https://www.rssboard.org/rss-autodiscovery) allows browsers and other software to automatically find a site’s RSS feed from the main URL. To enable, add a `<link>` tag with the following attributes to your site’s `head` element: ```jsx <link rel="alternate" type="application/rss+xml" title="Your Site's Title" href={new URL("rss.xml", Astro.site)} /> ``` With this tag, readers of your blog can enter your site’s base URL into their RSS reader to subscribe to your posts without needing the specific URL of your RSS feed. ## Next Steps [Section titled “Next Steps”](#next-steps) After visiting your feed in the browser at `your-domain.com/rss.xml` and confirming that you can see data for each of your posts, you can now [promote your feed on your website](https://medium.com/samsung-internet-dev/add-rss-feeds-to-your-website-to-keep-your-core-readers-engaged-3179dca9c91e#:~:text=com/~deno%2Drss-,Advertising%20your%20RSS%20feed,-Now%20you%20have). Adding the standard RSS icon to your site lets your readers know that they can subscribe to your posts in their own feed reader. ## Resources [Section titled “Resources”](#resources) * [RSS Feeds](https://aboutfeeds.com/)

# Share state between Astro components

> Learn how to share state across Astro components with Nano Stores.

When building an Astro website, you may need to share state across components. Astro recommends the use of [Nano Stores](https://github.com/nanostores/nanostores) for shared client storage. ## Recipe [Section titled “Recipe”](#recipe) 1. Install Nano Stores: * npm ```shell npm install nanostores ``` * pnpm ```shell pnpm add nanostores ``` * Yarn ```shell yarn add nanostores ``` 2. Create a store. In this example, the store tracks whether a dialog is open or not: src/store.js ```ts import { atom } from 'nanostores'; export const isOpen = atom(false); ``` 3. Import and use the store in a `<script>` tag in the components that will share state. The following `Button` and `Dialog` components each use the shared `isOpen` state to control whether a particular `<div>` is hidden or displayed: src/components/Button.astro ```astro <button id="openDialog">Open</button> <script> import { isOpen } from '../store.js'; // Set the store to true when the button is clicked function openDialog() { isOpen.set(true); } // Add an event listener to the button document.getElementById('openDialog').addEventListener('click', openDialog); </script> ``` src/components/Dialog.astro ```astro <div id="dialog" style="display: none">Hello world!</div> <script> import { isOpen } from '../store.js'; // Listen to changes in the store, and show/hide the dialog accordingly isOpen.subscribe(open => { if (open) { document.getElementById('dialog').style.display = 'block'; } else { document.getElementById('dialog').style.display = 'none'; } }) </script> ``` ## Resources [Section titled “Resources”](#resources) * [Nano Stores on NPM](https://www.npmjs.com/package/nanostores) * [Nano Stores documentation for Vanilla JS](https://github.com/nanostores/nanostores#vanilla-js)

# Share state between islands

> Learn how to share state across framework components with Nano Stores.

When building an Astro website with [islands architecture / partial hydration](/en/concepts/islands/), you may have run into this problem: **I want to share state between my components.** UI frameworks like React or Vue may encourage [“context” providers](https://react.dev/learn/passing-data-deeply-with-context) for other components to consume. But when [partially hydrating components](/en/guides/framework-components/#hydrating-interactive-components) within Astro or Markdown, you can’t use these context wrappers. Astro recommends a different solution for shared client-side storage: [**Nano Stores**](https://github.com/nanostores/nanostores). ![](/houston_chef.webp) **Related recipe:** [Share state between Astro components](/en/recipes/sharing-state/) ## Why Nano Stores? [Section titled “Why Nano Stores?”](#why-nano-stores) The [Nano Stores](https://github.com/nanostores/nanostores) library allows you to author stores that any component can interact with. We recommend Nano Stores because: * **They’re lightweight.** Nano Stores ship the bare minimum JS you’ll need (less than 1 KB) with zero dependencies. * **They’re framework-agnostic.** This means sharing state between frameworks will be seamless! Astro is built on flexibility, so we love solutions that offer a similar developer experience no matter your preference. Still, there are a number of alternatives you can explore. These include: * [Svelte’s built-in stores](https://svelte.dev/tutorial/writable-stores) * [Solid signals](https://www.solidjs.com/docs/latest) outside of a component context * [Vue’s reactivity API](https://vuejs.org/guide/scaling-up/state-management.html#simple-state-management-with-reactivity-api) * [Sending custom browser events](https://developer.mozilla.org/en-US/docs/Web/Events/Creating_and_triggering_events) between components ## Installing Nano Stores [Section titled “Installing Nano Stores”](#installing-nano-stores) To get started, install Nano Stores alongside their helper package for your favorite UI framework: * Preact ```shell npm install nanostores @nanostores/preact ``` * React ```shell npm install nanostores @nanostores/react ``` * Solid ```shell npm install nanostores @nanostores/solid ``` * Svelte ```shell npm install nanostores ``` * Vue ```shell npm install nanostores @nanostores/vue ``` You can jump into the [Nano Stores usage guide](https://github.com/nanostores/nanostores#guide) from here, or follow along with our example below! ## Usage example - ecommerce cart flyout [Section titled “Usage example - ecommerce cart flyout”](#usage-example---ecommerce-cart-flyout) Let’s say we’re building a simple ecommerce interface with three interactive elements: * An “add to cart” submission form * A cart flyout to display those added items * A cart flyout toggle [](/videos/stores-example.mp4) *[**Try the completed example**](https://github.com/withastro/astro/tree/main/examples/with-nanostores) on your machine or online via StackBlitz.* Your base Astro file may look like this: src/pages/index.astro ```astro --- import CartFlyoutToggle from '../components/CartFlyoutToggle'; import CartFlyout from '../components/CartFlyout'; import AddToCartForm from '../components/AddToCartForm'; --- <!DOCTYPE html> <html lang="en"> <head>...</head> <body> <header> <nav> <a href="/">Astro storefront</a> <CartFlyoutToggle client:load /> </nav> </header> <main> <AddToCartForm client:load> <!-- ... --> </AddToCartForm> </main> <CartFlyout client:load /> </body> </html> ``` ### Using “atoms” [Section titled “Using “atoms””](#using-atoms) Let’s start by opening our `CartFlyout` whenever `CartFlyoutToggle` is clicked. First, create a new JS or TS file to contain our store. We’ll use an [“atom”](https://github.com/nanostores/nanostores#atoms) for this: src/cartStore.js ```js import { atom } from 'nanostores'; export const isCartOpen = atom(false); ``` Now, we can import this store into any file that needs to read or write. We’ll start by wiring up our `CartFlyoutToggle`: * Preact src/components/CartFlyoutToggle.jsx ```jsx import { useStore } from '@nanostores/preact'; import { isCartOpen } from '../cartStore'; export default function CartButton() { // read the store value with the `useStore` hook const $isCartOpen = useStore(isCartOpen); // write to the imported store using `.set` return ( <button onClick={() => isCartOpen.set(!$isCartOpen)}>Cart</button> ) } ``` * React src/components/CartFlyoutToggle.jsx ```jsx import { useStore } from '@nanostores/react'; import { isCartOpen } from '../cartStore'; export default function CartButton() { // read the store value with the `useStore` hook const $isCartOpen = useStore(isCartOpen); // write to the imported store using `.set` return ( <button onClick={() => isCartOpen.set(!$isCartOpen)}>Cart</button> ) } ``` * Solid src/components/CartFlyoutToggle.jsx ```jsx import { useStore } from '@nanostores/solid'; import { isCartOpen } from '../cartStore'; export default function CartButton() { // read the store value with the `useStore` hook const $isCartOpen = useStore(isCartOpen); // write to the imported store using `.set` return ( <button onClick={() => isCartOpen.set(!$isCartOpen())}>Cart</button> ) } ``` * Svelte src/components/CartFlyoutToggle.svelte ```svelte <script> import { isCartOpen } from '../cartStore'; </script> <!--use "$" to read the store value--> <button on:click={() => isCartOpen.set(!$isCartOpen)}>Cart</button> ``` * Vue src/components/CartFlyoutToggle.vue ```vue <template> <!--write to the imported store using `.set`--> <button @click="isCartOpen.set(!$isCartOpen)">Cart</button> </template> <script setup> import { isCartOpen } from '../cartStore'; import { useStore } from '@nanostores/vue'; // read the store value with the `useStore` hook const $isCartOpen = useStore(isCartOpen); </script> ``` Then, we can read `isCartOpen` from our `CartFlyout` component: * Preact src/components/CartFlyout.jsx ```jsx import { useStore } from '@nanostores/preact'; import { isCartOpen } from '../cartStore'; export default function CartFlyout() { const $isCartOpen = useStore(isCartOpen); return $isCartOpen ? <aside>...</aside> : null; } ``` * React src/components/CartFlyout.jsx ```jsx import { useStore } from '@nanostores/react'; import { isCartOpen } from '../cartStore'; export default function CartFlyout() { const $isCartOpen = useStore(isCartOpen); return $isCartOpen ? <aside>...</aside> : null; } ``` * Solid src/components/CartFlyout.jsx ```jsx import { useStore } from '@nanostores/solid'; import { isCartOpen } from '../cartStore'; export default function CartFlyout() { const $isCartOpen = useStore(isCartOpen); return $isCartOpen() ? <aside>...</aside> : null; } ``` * Svelte src/components/CartFlyout.svelte ```svelte <script> import { isCartOpen } from '../cartStore'; </script> {#if $isCartOpen} <aside>...</aside> {/if} ``` * Vue src/components/CartFlyout.vue ```vue <template> <aside v-if="$isCartOpen">...</aside> </template> <script setup> import { isCartOpen } from '../cartStore'; import { useStore } from '@nanostores/vue'; const $isCartOpen = useStore(isCartOpen); </script> ``` ### Using “maps” [Section titled “Using “maps””](#using-maps) Now, let’s keep track of the items inside your cart. To avoid duplicates and keep track of “quantity,” we can store your cart as an object with the item’s ID as a key. We’ll use a [Map](https://github.com/nanostores/nanostores#maps) for this. Let’s add a `cartItem` store to our `cartStore.js` from earlier. You can also switch to a TypeScript file to define the shape if you’re so inclined. * JavaScript src/cartStore.js ```js import { atom, map } from 'nanostores'; export const isCartOpen = atom(false); /** * @typedef {Object} CartItem * @property {string} id * @property {string} name * @property {string} imageSrc * @property {number} quantity */ /** @type {import('nanostores').MapStore<Record<string, CartItem>>} */ export const cartItems = map({}); ``` * TypeScript src/cartStore.ts ```ts import { atom, map } from 'nanostores'; export const isCartOpen = atom(false); export type CartItem = { id: string; name: string; imageSrc: string; quantity: number; } export const cartItems = map<Record<string, CartItem>>({}); ``` Now, let’s export an `addCartItem` helper for our components to use. * **If that item doesn’t exist in your cart**, add the item with a starting quantity of 1. * **If that item *does* already exist**, bump the quantity by 1. - JavaScript src/cartStore.js ```js ... export function addCartItem({ id, name, imageSrc }) { const existingEntry = cartItems.get()[id]; if (existingEntry) { cartItems.setKey(id, { ...existingEntry, quantity: existingEntry.quantity + 1, }) } else { cartItems.setKey( id, { id, name, imageSrc, quantity: 1 } ); } } ``` - TypeScript src/cartStore.ts ```ts ... type ItemDisplayInfo = Pick<CartItem, 'id' | 'name' | 'imageSrc'>; export function addCartItem({ id, name, imageSrc }: ItemDisplayInfo) { const existingEntry = cartItems.get()[id]; if (existingEntry) { cartItems.setKey(id, { ...existingEntry, quantity: existingEntry.quantity + 1, }); } else { cartItems.setKey( id, { id, name, imageSrc, quantity: 1 } ); } } ``` With our store in place, we can call this function inside our `AddToCartForm` whenever that form is submitted. We’ll also open the cart flyout so you can see a full cart summary. * Preact src/components/AddToCartForm.jsx ```jsx import { addCartItem, isCartOpen } from '../cartStore'; export default function AddToCartForm({ children }) { // we'll hardcode the item info for simplicity! const hardcodedItemInfo = { id: 'astronaut-figurine', name: 'Astronaut Figurine', imageSrc: '/images/astronaut-figurine.png', } function addToCart(e) { e.preventDefault(); isCartOpen.set(true); addCartItem(hardcodedItemInfo); } return ( <form onSubmit={addToCart}> {children} </form> ) } ``` * React src/components/AddToCartForm.jsx ```jsx import { addCartItem, isCartOpen } from '../cartStore'; export default function AddToCartForm({ children }) { // we'll hardcode the item info for simplicity! const hardcodedItemInfo = { id: 'astronaut-figurine', name: 'Astronaut Figurine', imageSrc: '/images/astronaut-figurine.png', } function addToCart(e) { e.preventDefault(); isCartOpen.set(true); addCartItem(hardcodedItemInfo); } return ( <form onSubmit={addToCart}> {children} </form> ) } ``` * Solid src/components/AddToCartForm.jsx ```jsx import { addCartItem, isCartOpen } from '../cartStore'; export default function AddToCartForm({ children }) { // we'll hardcode the item info for simplicity! const hardcodedItemInfo = { id: 'astronaut-figurine', name: 'Astronaut Figurine', imageSrc: '/images/astronaut-figurine.png', } function addToCart(e) { e.preventDefault(); isCartOpen.set(true); addCartItem(hardcodedItemInfo); } return ( <form onSubmit={addToCart}> {children} </form> ) } ``` * Svelte src/components/AddToCartForm.svelte ```svelte <form on:submit|preventDefault={addToCart}> <slot></slot> </form> <script> import { addCartItem, isCartOpen } from '../cartStore'; // we'll hardcode the item info for simplicity! const hardcodedItemInfo = { id: 'astronaut-figurine', name: 'Astronaut Figurine', imageSrc: '/images/astronaut-figurine.png', } function addToCart() { isCartOpen.set(true); addCartItem(hardcodedItemInfo); } </script> ``` * Vue src/components/AddToCartForm.vue ```vue <template> <form @submit="addToCart"> <slot></slot> </form> </template> <script setup> import { addCartItem, isCartOpen } from '../cartStore'; // we'll hardcode the item info for simplicity! const hardcodedItemInfo = { id: 'astronaut-figurine', name: 'Astronaut Figurine', imageSrc: '/images/astronaut-figurine.png', } function addToCart(e) { e.preventDefault(); isCartOpen.set(true); addCartItem(hardcodedItemInfo); } </script> ``` Finally, we’ll render those cart items inside our `CartFlyout`: * Preact src/components/CartFlyout.jsx ```jsx import { useStore } from '@nanostores/preact'; import { isCartOpen, cartItems } from '../cartStore'; export default function CartFlyout() { const $isCartOpen = useStore(isCartOpen); const $cartItems = useStore(cartItems); return $isCartOpen ? ( <aside> {Object.values($cartItems).length ? ( <ul> {Object.values($cartItems).map(cartItem => ( <li> <img src={cartItem.imageSrc} alt={cartItem.name} /> <h3>{cartItem.name}</h3> <p>Quantity: {cartItem.quantity}</p> </li> ))} </ul> ) : <p>Your cart is empty!</p>} </aside> ) : null; } ``` * React src/components/CartFlyout.jsx ```jsx import { useStore } from '@nanostores/react'; import { isCartOpen, cartItems } from '../cartStore'; export default function CartFlyout() { const $isCartOpen = useStore(isCartOpen); const $cartItems = useStore(cartItems); return $isCartOpen ? ( <aside> {Object.values($cartItems).length ? ( <ul> {Object.values($cartItems).map(cartItem => ( <li> <img src={cartItem.imageSrc} alt={cartItem.name} /> <h3>{cartItem.name}</h3> <p>Quantity: {cartItem.quantity}</p> </li> ))} </ul> ) : <p>Your cart is empty!</p>} </aside> ) : null; } ``` * Solid src/components/CartFlyout.jsx ```jsx import { useStore } from '@nanostores/solid'; import { isCartOpen, cartItems } from '../cartStore'; export default function CartFlyout() { const $isCartOpen = useStore(isCartOpen); const $cartItems = useStore(cartItems); return $isCartOpen() ? ( <aside> {Object.values($cartItems()).length ? ( <ul> {Object.values($cartItems()).map(cartItem => ( <li> <img src={cartItem.imageSrc} alt={cartItem.name} /> <h3>{cartItem.name}</h3> <p>Quantity: {cartItem.quantity}</p> </li> ))} </ul> ) : <p>Your cart is empty!</p>} </aside> ) : null; } ``` * Svelte src/components/CartFlyout.svelte ```svelte <script> import { isCartOpen, cartItems } from '../cartStore'; </script> {#if $isCartOpen} {#if Object.values($cartItems).length} <aside> {#each Object.values($cartItems) as cartItem} <li> <img src={cartItem.imageSrc} alt={cartItem.name} /> <h3>{cartItem.name}</h3> <p>Quantity: {cartItem.quantity}</p> </li> {/each} </aside> {:else} <p>Your cart is empty!</p> {/if} {/if} ``` * Vue src/components/CartFlyout.vue ```vue <template> <aside v-if="$isCartOpen"> <ul v-if="Object.values($cartItems).length"> <li v-for="cartItem in Object.values($cartItems)" v-bind:key="cartItem.name"> <img :src=cartItem.imageSrc :alt=cartItem.name /> <h3>{{cartItem.name}}</h3> <p>Quantity: {{cartItem.quantity}}</p> </li> </ul> <p v-else>Your cart is empty!</p> </aside> </template> <script setup> import { cartItems, isCartOpen } from '../cartStore'; import { useStore } from '@nanostores/vue'; const $isCartOpen = useStore(isCartOpen); const $cartItems = useStore(cartItems); </script> ``` Now, you should have a fully interactive ecommerce example with the smallest JS bundle in the galaxy 🚀 [**Try the completed example**](https://github.com/withastro/astro/tree/main/examples/with-nanostores) on your machine or online via StackBlitz!

# Using streaming to improve page performance

> Learn how to use streaming to improve page performance.

Astro’s SSR uses HTML streaming to send each component to the browser when available for faster page loading. To improve your page’s performance even further, you can build your components strategically to optimize their loading by avoiding blocking data fetches. The following refactoring example demonstrates how to improve page performance by moving fetch calls to other components, moving them out of a component where they block page rendering. The following page `await`s some data in its frontmatter. Astro will wait for all of the `fetch` calls to resolve before sending any HTML to the browser. src/pages/index.astro ```astro --- const personResponse = await fetch('https://randomuser.me/api/'); const personData = await personResponse.json(); const randomPerson = personData.results[0]; const factResponse = await fetch('https://catfact.ninja/fact'); const factData = await factResponse.json(); --- <html> <head> <title>A name and a fact</title> </head> <body> <h2>A name</h2> <p>{randomPerson.name.first}</p> <h2>A fact</h2> <p>{factData.fact}</p> </body> </html> ``` Moving the `await` calls into smaller components allows you to take advantage of Astro’s streaming. Using the following components to perform the data fetches, Astro can render some HTML first, such as the title, and then the paragraphs when the data is ready. src/components/RandomName.astro ```astro --- const personResponse = await fetch('https://randomuser.me/api/'); const personData = await personResponse.json(); const randomPerson = personData.results[0]; --- <p>{randomPerson.name.first}</p> ``` src/components/RandomFact.astro ```astro --- const factResponse = await fetch('https://catfact.ninja/fact'); const factData = await factResponse.json(); --- <p>{factData.fact}</p> ``` The Astro page below using these components can render parts of the page sooner. The `<head>`, `<body>`, and `<h2>` tags are no longer blocked by data fetches. The server will then fetch data for `RandomName` and `RandomFact` in parallel and stream the resulting HTML to the browser. src/pages/index.astro ```astro --- import RandomName from '../components/RandomName.astro'; import RandomFact from '../components/RandomFact.astro'; --- <html> <head> <title>A name and a fact</title> </head> <body> <h2>A name</h2> <RandomName /> <h2>A fact</h2> <RandomFact /> </body> </html> ``` #### Including Promises directly [Section titled “Including Promises directly”](#including-promises-directly) You can also include promises directly in the template. Instead of blocking the entire component, it will resolve the promise in parallel and only block the markup that comes after it. src/pages/index.astro ```astro --- const personPromise = fetch('https://randomuser.me/api/') .then(response => response.json()) .then(personData => personData.results[0].name.first); const factPromise = fetch('https://catfact.ninja/fact') .then(response => response.json()) .then(factData => factData.fact); --- <html> <head> <title>A name and a fact</title> </head> <body> <h2>A name</h2> <p>{personPromise}</p> <h2>A fact</h2> <p>{factPromise}</p> </body> </html> ``` In this example, `A name` will render while `personPromise` and `factPromise` are loading. Once `personPromise` has resolved, `A fact` will appear and `factPromise` will render when it’s finished loading.

# Style rendered Markdown with Tailwind Typography

> Learn how to use @tailwind/typography to style your rendered Markdown.

You can use [Tailwind](https://tailwindcss.com)’s Typography plugin to style rendered Markdown from sources such as Astro’s [**content collections**](/en/guides/content-collections/). This recipe will teach you how to create a reusable Astro component to style your Markdown content using Tailwind’s utility classes. ## Prerequisites [Section titled “Prerequisites”](#prerequisites) An Astro project that: * has [Tailwind’s Vite plugin](/en/guides/styling/#tailwind) installed. * uses Astro’s [content collections](/en/guides/content-collections/). ## Setting Up `@tailwindcss/typography` [Section titled “Setting Up @tailwindcss/typography”](#setting-up-tailwindcsstypography) First, install `@tailwindcss/typography` using your preferred package manager. * npm ```shell npm install -D @tailwindcss/typography ``` * pnpm ```shell pnpm add -D @tailwindcss/typography ``` * Yarn ```shell yarn add --dev @tailwindcss/typography ``` Then, add the package as a plugin in your Tailwind configuration file. src/styles/global.css ```diff @import 'tailwindcss'; +@plugin '@tailwindcss/typography'; ``` ## Recipe [Section titled “Recipe”](#recipe) 1. Create a `<Prose />` component to provide a wrapping `<div>` with a `<slot />` for your rendered Markdown. Add the style class `prose` alongside any desired [Tailwind element modifiers](https://tailwindcss.com/docs/typography-plugin#element-modifiers) in the parent element. src/components/Prose.astro ```astro --- --- <div class="prose dark:prose-invert prose-h1:font-bold prose-h1:text-xl prose-a:text-blue-600 prose-p:text-justify prose-img:rounded-xl prose-headings:underline"> <slot /> </div> ``` 2. Query your collection entry on the page you want to render your Markdown. Pass the `<Content />` component from `await render(entry)` to `<Prose />` as a child to wrap your Markdown content in Tailwind styles. src/pages/index.astro ```astro --- import Prose from '../components/Prose.astro'; import Layout from '../layouts/Layout.astro'; import { getEntry, render } from 'astro:content'; const entry = await getEntry('collection', 'entry'); const { Content } = await render(entry); --- <Layout> <Prose> <Content /> </Prose> </Layout> ``` ## Resources [Section titled “Resources”](#resources) * [Tailwind Typography Documentation](https://tailwindcss.com/docs/typography-plugin)