<SYSTEM>This is the abridged developer documentation for Astro</SYSTEM>

# Why Astro?

> Astro is the web framework for building content-driven websites like blogs, marketing, and e-commerce. Learn why Astro might be a good choice for your next website.

**Astro** is the web framework for building **content-driven websites** like blogs, marketing, and e-commerce. Astro is best-known for pioneering a new [frontend architecture](/en/concepts/islands/) to reduce JavaScript overhead and complexity compared to other frameworks. If you need a website that loads fast and has great SEO, then Astro is for you. ## Features [Section titled ‚ÄúFeatures‚Äù](#features) **Astro is an all-in-one web framework.** It includes everything you need to create a website, built-in. There are also hundreds of different [integrations](https://astro.build/integrations/) and [API hooks](/en/reference/integrations-reference/) available to customize a project to your exact use case and needs. Some highlights include: * **[Islands](/en/concepts/islands/):** A component-based web architecture optimized for content-driven websites. * **[UI-agnostic](/en/guides/framework-components/):** Supports React, Preact, Svelte, Vue, Solid, HTMX, web components, and more. * **[Server-first](/en/guides/on-demand-rendering/):** Moves expensive rendering off of your visitors‚Äô devices. * **[Zero JS, by default](/en/basics/astro-components/):** Less client-side JavaScript to slow your site down. * **[Content collections](/en/guides/content-collections/):** Organize, validate, and provide TypeScript type-safety for your Markdown content. * **[Customizable](/en/guides/integrations-guide/):** Partytown, MDX, and hundreds of integrations to choose from. ## Design Principles [Section titled ‚ÄúDesign Principles‚Äù](#design-principles) Here are five core design principles to help explain why we built Astro, the problems that it exists to solve, and why Astro may be the best choice for your project or team. Astro is‚Ä¶ 1. **[Content-driven](#content-driven):** Astro was designed to showcase your content. 2. **[Server-first](#server-first):** Websites run faster when they render HTML on the server. 3. **[Fast by default](#fast-by-default):** It should be impossible to build a slow website in Astro. 4. **[Easy to use](#easy-to-use):** You don‚Äôt need to be an expert to build something with Astro. 5. **[Developer-focused](#developer-focused):** You should have the resources you need to be successful. ### Content-driven [Section titled ‚ÄúContent-driven‚Äù](#content-driven) **Astro was designed for building content-rich websites.** This includes marketing sites, publishing sites, documentation sites, blogs, portfolios, landing pages, community sites, and e-commerce sites. If you have content to show, it needs to reach your reader quickly. By contrast, most modern web frameworks were designed for building *web applications*. These frameworks excel at building more complex, application-like experiences in the browser: logged-in admin dashboards, inboxes, social networks, todo lists, and even native-like applications like [Figma](https://figma.com/) and [Ping](https://ping.gg/). However with that complexity, they can struggle to provide great performance when delivering your content. Astro‚Äôs focus on content from its beginnings as a static site builder have allowed Astro to **sensibly scale up to performant, powerful, dynamic web applications** that still respect your content and your audience. Astro‚Äôs unique focus on content lets Astro make tradeoffs and deliver unmatched performance features that wouldn‚Äôt make sense for more application-focused web frameworks to implement. ### Server-first [Section titled ‚ÄúServer-first‚Äù](#server-first) **Astro leverages server rendering over client-side rendering in the browser as much as possible.** This is the same approach that traditional server-side frameworks -- PHP, WordPress, Laravel, Ruby on Rails, etc. -- have been using for decades. But you don‚Äôt need to learn a second server-side language to unlock it. With Astro, everything is still just HTML, CSS, and JavaScript (or TypeScript, if you prefer). This approach stands in contrast to other modern JavaScript web frameworks like Next.js, SvelteKit, Nuxt, Remix, and others. These frameworks were built for client-side rendering of your entire website and include server-side rendering mainly to address performance concerns. This approach has been dubbed the **Single-Page App (SPA)**, in contrast with Astro‚Äôs **Multi-Page App (MPA)** approach. The SPA model has its benefits. However, these come at the expense of additional complexity and performance tradeoffs. These tradeoffs harm page performance -- critical metrics like [Time to Interactive (TTI)](https://web.dev/interactive/) -- which doesn‚Äôt make much sense for content-focused websites where first-load performance is essential. Astro‚Äôs server-first approach allows you to opt in to client-side rendering only if, and exactly as, necessary. You can choose to add UI framework components that run on the client. You can take advantage of Astro‚Äôs view transitions router for finer control over select page transitions and animations. Astro‚Äôs server-first rendering, either pre-rendered or on-demand, provides performant defaults that you can enhance and extend. ### Fast by default [Section titled ‚ÄúFast by default‚Äù](#fast-by-default) Good performance is always important, but it is *especially* critical for websites whose success depends on displaying your content. It has been well-proven that poor performance loses you engagement, conversions, and money. For example: * Every 100ms faster ‚Üí 1% more conversions ([Mobify](https://web.dev/why-speed-matters/), earning +$380,000/yr) * 50% faster ‚Üí 12% more sales ([AutoAnything](https://www.digitalcommerce360.com/2010/08/19/web-accelerator-revs-conversion-and-sales-autoanything/)) * 20% faster ‚Üí 10% more conversions ([Furniture Village](https://www.thinkwithgoogle.com/intl/en-gb/marketing-strategies/app-and-mobile/furniture-village-and-greenlight-slash-page-load-times-boosting-user-experience/)) * 40% faster ‚Üí 15% more sign-ups ([Pinterest](https://medium.com/pinterest-engineering/driving-user-growth-with-performance-improvements-cfc50dafadd7)) * 850ms faster ‚Üí 7% more conversions ([COOK](https://web.dev/why-speed-matters/)) * Every 1 second slower ‚Üí 10% fewer users ([BBC](https://www.creativebloq.com/features/how-the-bbc-builds-websites-that-scale)) In many web frameworks, it is easy to build a website that looks great during development only to load painfully slow once deployed. JavaScript is often the culprit, since many phones and lower-powered devices rarely match the speed of a developer‚Äôs laptop. Astro‚Äôs magic is in how it combines the two values explained above -- a content focus with a server-first architecture -- to make tradeoffs and deliver features that other frameworks cannot. The result is amazing web performance for every website, out of the box. Our goal: **It should be nearly impossible to build a slow website with Astro.** An Astro website can [load 40% faster with 90% less JavaScript](https://twitter.com/t3dotgg/status/1437195415439360003) than the same site built with the most popular React web framework. But don‚Äôt take our word for it: watch Astro‚Äôs performance leave Ryan Carniato (creator of Solid.js and Marko) [speechless](https://youtu.be/2ZEMb_H-LYE?t=8163). ### Easy to use [Section titled ‚ÄúEasy to use‚Äù](#easy-to-use) **Astro‚Äôs goal is to be accessible to every web developer.** Astro was designed to feel familiar and approachable regardless of skill level or past experience with web development. The `.astro` UI language is a superset of HTML: any valid HTML is valid Astro templating syntax! So, if you can write HTML, you can write Astro components! But, it also combines some of our favorite features borrowed from other component languages like JSX expressions (React) and CSS scoping by default (Svelte and Vue). This closeness to HTML also makes it easier to use progressive enhancement and common accessibility patterns without any overhead. We then made sure that you could also use your favorite UI component languages that you already know, and even reuse components you might already have. React, Preact, Svelte, Vue, Solid, and others, including web components, are all supported for authoring UI components in an Astro project. Astro was designed to be less complex than other UI frameworks and languages. One big reason for this is that Astro was designed to render on the server, not in the browser. That means that you don‚Äôt need to worry about hooks (React), stale closures (also React), refs (Vue), observables (Svelte), atoms, selectors, reactions, or derivations. There is no reactivity on the server, so all of that complexity melts away. One of our favorite sayings is **opt in to complexity.** We designed Astro to remove as much ‚Äúrequired complexity‚Äù as possible from the developer experience, especially as you onboard for the first time. You can build a ‚ÄúHello World‚Äù example website in Astro with just HTML and CSS. Then, when you need to build something more powerful, you can incrementally reach for new features and APIs as you go. ### Developer-focused [Section titled ‚ÄúDeveloper-focused‚Äù](#developer-focused) We strongly believe that Astro is only a successful project if people love using it. Astro has everything you need to support you as you build with Astro. Astro invests in developer tools like a great CLI experience from the moment you open your terminal, an official VS Code extension for syntax highlighting, TypeScript and Intellisense, and documentation actively maintained by hundreds of community contributors and available in 14 languages. Our welcoming, respectful, inclusive community on Discord is ready to provide support, motivation, and encouragement. Open a `#support` thread to get help with your project. Visit our dedicated `#showcase` channel for sharing your Astro sites, blog posts, videos, and even work-in-progress for safe feedback and constructive criticism. Participate in regular live events such as our weekly community call, ‚ÄúTalking and Doc‚Äôing,‚Äù and API/bug bashes. As an open-source project, we welcome contributions of all types and sizes from community members of all experience levels. You are invited to join in roadmap discussions to shape the future of Astro, and we hope you‚Äôll contribute fixes and features to the core codebase, compiler, docs, language tools, websites, and other projects.

# Islands architecture

> Learn about how Astro's islands architecture helps keep sites fast.

Astro helped pioneer and popularize a new frontend architecture pattern called **Islands Architecture.** Islands architecture works by rendering the majority of your page to fast, static HTML with smaller ‚Äúislands‚Äù of JavaScript added when interactivity or personalization is needed on the page (an image carousel, for example). This avoids the monolithic JavaScript payloads that slow down the responsiveness of many other, modern JavaScript web frameworks. ## A brief history [Section titled ‚ÄúA brief history‚Äù](#a-brief-history) The term ‚Äúcomponent island‚Äù was first coined by Etsy‚Äôs frontend architect [Katie Sylor-Miller](https://sylormiller.com/) in 2019. This idea was then expanded on and documented in [this post](https://jasonformat.com/islands-architecture/) by Preact creator Jason Miller on August 11, 2020. > The general idea of an ‚ÄúIslands‚Äù architecture is deceptively simple: render HTML pages on the server, and inject placeholders or slots around highly dynamic regions \[‚Ä¶] that can then be ‚Äúhydrated‚Äù on the client into small self-contained widgets, reusing their server-rendered initial HTML.\ > ‚Äî Jason Miller, Creator of Preact The technique that this architectural pattern builds on is also known as **partial** or **selective hydration.** In contrast, most JavaScript-based web frameworks hydrate & render an entire website as one large JavaScript application (also known as a single-page application, or SPA). SPAs provide simplicity and power but suffer from page-load performance problems due to heavy client-side JavaScript usage. SPAs have their place, even [embedded inside an Astro page](/en/guides/migrate-to-astro/from-create-react-app/). But, SPAs lack the native ability to selectively and strategically hydrate, making them a heavy-handed choice for most projects on the web today. Astro became popular as the first mainstream JavaScript web framework with selective hydration built-in, using that same component islands pattern first coined by Sylor-Miller. We‚Äôve since expanded and evolved on Sylor-Miller‚Äôs original work, which helped to inspire a similar component island approach to dynamically server-rendered content. ## What is an island? [Section titled ‚ÄúWhat is an island?‚Äù](#what-is-an-island) In Astro, an island is an enhanced UI component on an otherwise static page of HTML. A [**client island**](#client-islands) is an interactive JavaScript UI component that is hydrated separately from the rest of the page, while a [**server island**](#server-islands) is a UI component that server-renders its dynamic content separately from the rest of the page. Both islands run expensive or slower processes independently, on a per-component basis, for optimized page loads. ## Island components [Section titled ‚ÄúIsland components‚Äù](#island-components) Astro components are the building blocks of your page template. They render to static HTML with no client-side runtime. Think of a client island as an interactive widget floating in a sea of otherwise static, lightweight, server-rendered HTML. Server islands can be added for personalized or dynamic server-rendered elements, such as a logged in visitor‚Äôs profile picture. Header (interactive island) Sidebar (static HTML) Static content like text, images, etc. Image carousel (interactive island) Footer (static HTML) Source: [Islands Architecture: Jason Miller](https://jasonformat.com/islands-architecture/) An island always runs in isolation from other islands on the page, and multiple islands can exist on a page. Client islands can still share state and communicate with each other, even though they run in different component contexts. This flexibility allows Astro to support multiple UI frameworks like [React](https://react.dev/), [Preact](https://preactjs.com/), [Svelte](https://svelte.dev/), [Vue](https://vuejs.org/), and [SolidJS](https://www.solidjs.com/). Because they are independent, you can even mix several frameworks on each page. ## Client Islands [Section titled ‚ÄúClient Islands‚Äù](#client-islands) By default, Astro will automatically render every UI component to just HTML & CSS, **stripping out all client-side JavaScript automatically.** src/pages/index.astro ```astro <MyReactComponent /> ``` This may sound strict, but this behavior is what keeps Astro websites fast by default and protects developers from accidentally sending unnecessary or unwanted JavaScript that might slow down their website. Turning any static UI component into an interactive island requires only a `client:*` directive. Astro then automatically builds and bundles your client-side JavaScript for optimized performance. src/pages/index.astro ```astro <!-- This component is now interactive on the page! The rest of your website remains static. --> <MyReactComponent client:load /> ``` With islands, client-side JavaScript is only loaded for the explicit interactive components that you mark using `client:*` directives. And because interaction is configured at the component-level, you can handle different loading priorities for each component based on its usage. For example, `client:idle` tells a component to load when the browser becomes idle, and `client:visible` tells a component to load only once it enters the viewport. ### Benefits of client islands The most obvious benefit of building with Astro Islands is performance: the majority of your website is converted to fast, static HTML and JavaScript is only loaded for the individual components that need it. JavaScript is one of the slowest assets that you can load per-byte, so every byte counts. Another benefit is parallel loading. In the example illustration above, the low-priority ‚Äúimage carousel‚Äù island doesn‚Äôt need to block the high-priority ‚Äúheader‚Äù island. The two load in parallel and hydrate in isolation, meaning that the header becomes interactive immediately without having to wait for the heavier carousel lower down the page. Even better, you can tell Astro exactly how and when to render each component. If that image carousel is really expensive to load, you can attach a special [client directive](/en/reference/directives-reference/#client-directives) that tells Astro to only load the carousel when it becomes visible on the page. If the user never sees it, it never loads. In Astro, it‚Äôs up to you as the developer to explicitly tell Astro which components on the page need to also run in the browser. Astro will only hydrate exactly what‚Äôs needed on the page and leave the rest of your site as static HTML. **Client islands are the secret to Astro‚Äôs fast-by-default performance story!** Read more about [using JavaScript framework components](/en/guides/framework-components/) in your project. ## Server islands [Section titled ‚ÄúServer islands‚Äù](#server-islands) Server islands are a way to move expensive or slow server-side code out of the way of the main rendering process, making it easy to combine high-performance static HTML and dynamic server-generated components. Add the [`server:defer` directive](/en/reference/directives-reference/#server-directives) to any Astro component on your page to turn it into its own server island: src/pages/index.astro ```astro --- import Avatar from "../components/Avatar.astro"; --- <Avatar server:defer /> ``` This breaks up your page with smaller areas of server-rendered content that each load in parallel. Your page‚Äôs main content can be rendered immediately with placeholder content, such as a generic avatar until your island‚Äôs own content is available. With server islands, having small components of personalized content does not delay the rendering of an otherwise static page. This rendering pattern was built to be portable. It does not depend on any server infrastructure so it will work with any host, from a Node.js server in a Docker container to the serverless provider of your choice. ### Benefits of server islands One benefit of server islands is the ability to render the more highly dynamic parts of your page on the fly. This allows the outer shell and main content to be more aggressively cached, providing faster performance. Another benefit is providing a great visitor experience. Server islands are optimized and load quickly, often even before the browser has even painted the page. But in the short time it takes for your islands to render, you can display custom fallback content and prevent any layout shift. An example of a site that benefits from Astro‚Äôs server islands is an e-commerce storefront. Although the main content of product pages change infrequently, these pages typically have some dynamic pieces: * The user‚Äôs avatar in the header. * Special deals and sales for the product. * User reviews. Using server islands for these elements, your visitor will see the most important part of the page, your product, immediately. Generic avatars, loading spinners, and store announcements can be displayed as fallback content until the personalized parts are available. Read more about [using server islands](/en/guides/server-islands/) in your project.

# Install Astro

> How to install Astro and start a new project.

The [`create astro` CLI command](#install-from-the-cli-wizard) is the fastest way to start a new Astro project from scratch. It will walk you through every step of setting up your new Astro project and allow you to choose from a few different official starter templates. You can also run the CLI command with the `template` flag to begin your project using any existing theme or starter template. Explore our [themes and starters showcase](https://astro.build/themes/) where you can browse themes for blogs, portfolios, documentation sites, landing pages, and more! To install Astro manually instead, see our [step-by-step manual installation guide](#manual-setup). ## Prerequisites [Section titled ‚ÄúPrerequisites‚Äù](#prerequisites) * **Node.js** - `v18.20.8` or `v20.3.0`, `v22.0.0` or higher. (`v19` and `v21` are not supported.) * **Text editor** - We recommend [VS Code](https://code.visualstudio.com/) with our [Official Astro extension](https://marketplace.visualstudio.com/items?itemName=astro-build.astro-vscode). * **Terminal** - Astro is accessed through its command-line interface (CLI). ## Browser compatibility [Section titled ‚ÄúBrowser compatibility‚Äù](#browser-compatibility) Astro is built with Vite which targets browsers with modern JavaScript support by default. For a complete reference, you can see the [list of currently supported browser versions in Vite](https://vite.dev/guide/build.html#browser-compatibility). ## Install from the CLI wizard [Section titled ‚ÄúInstall from the CLI wizard‚Äù](#install-from-the-cli-wizard) You can run `create astro` anywhere on your machine, so there‚Äôs no need to create a new empty directory for your project before you begin. If you don‚Äôt have an empty directory yet for your new project, the wizard will help create one for you automatically. 1. Run the following command in your terminal to start the install wizard: * npm ```shell # create a new project with npm npm create astro@latest ``` * pnpm ```shell # create a new project with pnpm pnpm create astro@latest ``` * Yarn ```shell # create a new project with yarn yarn create astro ``` If all goes well, you will see a success message followed by some recommended next steps. 2. Now that your project has been created, you can `cd` into your new project directory to begin using Astro. 3. If you skipped the ‚ÄúInstall dependencies?‚Äù step during the CLI wizard, then be sure to install your dependencies before continuing. * npm ```shell npm install ``` * pnpm ```shell pnpm install ``` * Yarn ```shell yarn install ``` 4. You can now [start the Astro dev server](/en/develop-and-build/#start-the-astro-dev-server) and see a live preview of your project while you build! ## CLI installation flags [Section titled ‚ÄúCLI installation flags‚Äù](#cli-installation-flags) You can run the `create astro` command with additional flags to customize the setup process (e.g. answering ‚Äúyes‚Äù to all questions, skipping the Houston animation) or your new project (e.g. install git or not, add integrations). See [all the available `create astro` command flags](https://github.com/withastro/astro/blob/main/packages/create-astro/README.md). ### Add integrations [Section titled ‚ÄúAdd integrations‚Äù](#add-integrations) You can start a new Astro project and install any [official integrations](/en/guides/integrations-guide/) or community integrations that support the `astro add` command at the same time by passing the `--add` argument to the `create astro` command. Run the following command in your terminal, substituting any integration that supports the `astro add` command: * npm ```shell # create a new project with React and Partytown npm create astro@latest -- --add react --add partytown ``` * pnpm ```shell # create a new project with React and Partytown pnpm create astro@latest --add react --add partytown ``` * Yarn ```shell # create a new project with React and Partytown yarn create astro --add react --add partytown ``` ### Use a theme or starter template [Section titled ‚ÄúUse a theme or starter template‚Äù](#use-a-theme-or-starter-template) You can start a new Astro project based on an [official example](https://github.com/withastro/astro/tree/main/examples) or the `main` branch of any GitHub repository by passing a `--template` argument to the `create astro` command. Run the following command in your terminal, substituting the official Astro starter template name, or the GitHub username and repository of the theme you want to use: * npm ```shell # create a new project with an official example npm create astro@latest -- --template <example-name> # create a new project based on a GitHub repository‚Äôs main branch npm create astro@latest -- --template <github-username>/<github-repo> ``` * pnpm ```shell # create a new project with an official example pnpm create astro@latest --template <example-name> # create a new project based on a GitHub repository‚Äôs main branch pnpm create astro@latest --template <github-username>/<github-repo> ``` * Yarn ```shell # create a new project with an official example yarn create astro --template <example-name> # create a new project based on a GitHub repository‚Äôs main branch yarn create astro --template <github-username>/<github-repo> ``` By default, this command will use the template repository‚Äôs `main` branch. To use a different branch name, pass it as part of the `--template` argument: `<github-username>/<github-repo>#<branch>`. ## Manual Setup [Section titled ‚ÄúManual Setup‚Äù](#manual-setup) This guide will walk you through the steps to manually install and configure a new Astro project. If you prefer not to use our automatic `create astro` CLI tool, you can set up your project yourself by following the guide below. 1. Create your directory Create an empty directory with the name of your project, and then navigate into it. ```bash mkdir my-astro-project cd my-astro-project ``` Once you are in your new directory, create your project `package.json` file. This is how you will manage your project dependencies, including Astro. If you aren‚Äôt familiar with this file format, run the following command to create one. * npm ```shell npm init --yes ``` * pnpm ```shell pnpm init ``` * Yarn ```shell yarn init --yes ``` 2. Install Astro First, install the Astro project dependencies inside your project. * npm ```shell npm install astro ``` * pnpm ```shell pnpm add astro ``` * Yarn ```shell yarn add astro ``` Then, replace any placeholder ‚Äúscripts‚Äù section of your `package.json` with the following: package.json ```diff { "scripts": { -"test": "echo \"Error: no test specified\" && exit 1", +"dev": "astro dev", +"build": "astro build", +"preview": "astro preview" }, } ``` You‚Äôll use these scripts later in the guide to start Astro and run its different commands. 3. Create your first page In your text editor, create a new file in your directory at `src/pages/index.astro`. This will be your first Astro page in the project. For this guide, copy and paste the following code snippet (including `---` dashes) into your new file: src/pages/index.astro ```astro --- // Welcome to Astro! Everything between these triple-dash code fences // is your "component frontmatter". It never runs in the browser. console.log('This runs in your terminal, not the browser!'); --- <!-- Below is your "component template." It's just HTML, but with some magic sprinkled in to help you build great templates. --> <html> <body> <h1>Hello, World!</h1> </body> </html> <style> h1 { color: orange; } </style> ``` 4. Create your first static asset You will also want to create a `public/` directory to store your static assets. Astro will always include these assets in your final build, so you can safely reference them from inside your component templates. In your text editor, create a new file in your directory at `public/robots.txt`. `robots.txt` is a simple file that most sites will include to tell search bots like Google how to treat your site. For this guide, copy and paste the following code snippet into your new file: public/robots.txt ```diff # Example: Allow all bots to scan and index your site. # Full syntax: https://developers.google.com/search/docs/advanced/robots/create-robots-txt User-agent: * Allow: / ``` 5. Create `astro.config.mjs` Astro is configured using `astro.config.mjs`. This file is optional if you do not need to configure Astro, but you may wish to create it now. Create `astro.config.mjs` at the root of your project, and copy the code below into it: astro.config.mjs ```js import { defineConfig } from "astro/config"; // https://astro.build/config export default defineConfig({}); ``` If you want to include [UI framework components](/en/guides/framework-components/) such as React, Svelte, etc. or use other tools such as MDX or Partytown in your project, here is where you will [manually import and configure integrations](/en/guides/integrations-guide/). Read Astro‚Äôs [API configuration reference](/en/reference/configuration-reference/) for more information. 6. Add TypeScript support TypeScript is configured using `tsconfig.json`. Even if you don‚Äôt write TypeScript code, this file is important so that tools like Astro and VS Code know how to understand your project. Some features (like npm package imports) aren‚Äôt fully supported in the editor without a `tsconfig.json` file. If you do intend to write TypeScript code, using Astro‚Äôs `strict` or `strictest` template is recommended. You can view and compare the three template configurations at [astro/tsconfigs/](https://github.com/withastro/astro/blob/main/packages/astro/tsconfigs/). Create `tsconfig.json` at the root of your project, and copy the code below into it. (You can use `base`, `strict`, or `strictest` for your TypeScript template): tsconfig.json ```json { "extends": "astro/tsconfigs/base" } ``` Read Astro‚Äôs [TypeScript setup guide](/en/guides/typescript/#setup) for more information. 7. Next Steps If you have followed the steps above, your project directory should now look like this: * astro.config.mjs * package-lock.json or `yarn.lock`, `pnpm-lock.yaml`, etc. * package.json * tsconfig.json 8. You can now [start the Astro dev server](/en/develop-and-build/#start-the-astro-dev-server) and see a live preview of your project while you build!

# Project structure

> An introduction to the basic file structure of an Astro project.

Your new Astro project generated from the `create astro` CLI wizard already includes some files and folders. Others, you will create yourself and add to Astro‚Äôs existing file structure. Here‚Äôs how an Astro project is organized, and some files you will find in your new project. ## Directories and Files [Section titled ‚ÄúDirectories and Files‚Äù](#directories-and-files) Astro leverages an opinionated folder layout for your project. Every Astro project root should include the following directories and files: * `src/*` - Your project source code (components, pages, styles, images, etc.) * `public/*` - Your non-code, unprocessed assets (fonts, icons, etc.) * `package.json` - A project manifest. * `astro.config.mjs` - An Astro configuration file. (recommended) * `tsconfig.json` - A TypeScript configuration file. (recommended) ### Example Project Tree [Section titled ‚ÄúExample Project Tree‚Äù](#example-project-tree) A common Astro project directory might look like this: * astro.config.mjs * package.json * tsconfig.json ### `src/` [Section titled ‚Äúsrc/‚Äù](#src) The `src/` folder is where most of your project source code lives. This includes: * [Pages](/en/basics/astro-pages/) * [Layouts](/en/basics/layouts/) * [Astro components](/en/basics/astro-components/) * [UI framework components (React, etc.)](/en/guides/framework-components/) * [Styles (CSS, Sass)](/en/guides/styling/) * [Markdown](/en/guides/markdown-content/) * [Images to be optimized and processed by Astro](/en/guides/images/) Astro processes, optimizes, and bundles your `src/` files to create the final website that is shipped to the browser. Unlike the static `public/` directory, your `src/` files are built and handled for you by Astro. Some files (like Astro components) are not even sent to the browser as written but are instead rendered to static HTML. Other files (like CSS) are sent to the browser but may be optimized or bundled with other CSS files for performance. ### `src/pages` [Section titled ‚Äúsrc/pages‚Äù](#srcpages) Pages routes are created for your site by adding [supported file types](/en/basics/astro-pages/#supported-page-files) to this directory. Caution `src/pages` is a **required** sub-directory in your Astro project. Without it, your site will have no pages or routes! ### `src/components` [Section titled ‚Äúsrc/components‚Äù](#srccomponents) **Components** are reusable units of code for your HTML pages. These could be [Astro components](/en/basics/astro-components/), or [UI framework components](/en/guides/framework-components/) like React or Vue. It is common to group and organize all of your project components together in this folder. This is a common convention in Astro projects, but it is not required. Feel free to organize your components however you like! ### `src/layouts` [Section titled ‚Äúsrc/layouts‚Äù](#srclayouts) [Layouts](/en/basics/layouts/) are Astro components that define the UI structure shared by one or more [pages](/en/basics/astro-pages/). Just like `src/components`, this directory is a common convention but not required. ### `src/styles` [Section titled ‚Äúsrc/styles‚Äù](#srcstyles) It is a common convention to store your CSS or Sass files in a `src/styles` directory, but this is not required. As long as your styles live somewhere in the `src/` directory and are imported correctly, Astro will handle and optimize them. ### `public/` [Section titled ‚Äúpublic/‚Äù](#public) The `public/` directory is for files and assets in your project that do not need to be processed during Astro‚Äôs build process. The files in this folder will be copied into the build folder untouched, and then your site will be built. This behavior makes `public/` ideal for common assets that do not require any processing, like some images and fonts, or special files such as `robots.txt` and `manifest.webmanifest`. You can place CSS and JavaScript in your `public/` directory, but be aware that those files will not be bundled or optimized in your final build. ### `package.json` [Section titled ‚Äúpackage.json‚Äù](#packagejson) This is a file used by JavaScript package managers to manage your dependencies. It also defines the scripts that are commonly used to run Astro (ex: `npm run dev`, `npm run build`). There are [two kinds of dependencies](https://docs.npmjs.com/specifying-dependencies-and-devdependencies-in-a-package-json-file) you can specify in a `package.json`: `dependencies` and `devDependencies`. In most cases, these work the same: Astro needs all dependencies at build time, and your package manager will install both. We recommend putting all of your dependencies in `dependencies` to start, and only use `devDependencies` if you find a specific need to do so. For help creating a new `package.json` file for your project, check out the [manual setup](/en/install-and-setup/#manual-setup) instructions. ### `astro.config.mjs` [Section titled ‚Äúastro.config.mjs‚Äù](#astroconfigmjs) This file is generated in every starter template and includes configuration options for your Astro project. Here you can specify integrations to use, build options, server options, and more. Astro supports several file formats for its JavaScript configuration file: `astro.config.js`, `astro.config.mjs`, `astro.config.cjs` and `astro.config.ts`. We recommend using `.mjs` in most cases or `.ts` if you want to write TypeScript in your config file. TypeScript config file loading is handled using [`tsm`](https://github.com/lukeed/tsm) and will respect your project‚Äôs `tsconfig` options. See the [configuration reference](/en/reference/configuration-reference/) for complete details. ### `tsconfig.json` [Section titled ‚Äútsconfig.json‚Äù](#tsconfigjson) This file is generated in every starter template and includes TypeScript configuration options for your Astro project. Some features (like npm package imports) aren‚Äôt fully supported in the editor without a `tsconfig.json` file. See the [TypeScript Guide](/en/guides/typescript/) for details on setting configurations.

# Develop and build

> How to start working on a new project.

Once you have an Astro project, now you‚Äôre ready to build with Astro! üöÄ ## Edit your project [Section titled ‚ÄúEdit your project‚Äù](#edit-your-project) To make changes to your project, open your project folder in your code editor. Working in development mode with the dev server running allows you to see updates to your site as you edit the code. You can also [customize aspects of your development environment](#configure-your-dev-environment) such as configuring TypeScript or installing the official Astro editor extensions. ### Start the Astro dev server [Section titled ‚ÄúStart the Astro dev server‚Äù](#start-the-astro-dev-server) Astro comes with a built-in development server that has everything you need for project development. The `astro dev` CLI command will start the local development server so that you can see your new website in action for the very first time. Every starter template comes with a pre-configured script that will run `astro dev` for you. After navigating into your project directory, use your favorite package manager to run this command and start the Astro development server. * npm ```shell npm run dev ``` * pnpm ```shell pnpm run dev ``` * Yarn ```shell yarn run dev ``` If all goes well, Astro will now be serving your project on <http://localhost:4321/>. Visit that link in your browser and see your new site! ### Work in development mode [Section titled ‚ÄúWork in development mode‚Äù](#work-in-development-mode) Astro will listen for live file changes in your `src/` directory and update your site preview as you build, so you will not need to restart the server as you make changes during development. You will always be able to see an up-to-date version of your site in your browser when the dev server is running. When viewing your site in the browser, you‚Äôll have access to the [Astro dev toolbar](/en/guides/dev-toolbar/). As you build, it will help you inspect your [islands](/en/concepts/islands/), spot accessibility issues, and more. If you aren‚Äôt able to open your project in the browser after starting the dev server, go back to the terminal where you ran the `dev` command and check the message displayed. It should tell you if an error occurred, or if your project is being served at a different URL than <http://localhost:4321/>. ## Build and preview your site [Section titled ‚ÄúBuild and preview your site‚Äù](#build-and-preview-your-site) To check the version of your site that will be created at build time, quit the dev server (`Ctrl` + `C`) and run the appropriate build command for your package manager in your terminal: * npm ```shell npm run build ``` * pnpm ```shell pnpm build ``` * Yarn ```shell yarn run build ``` Astro will build a deploy-ready version of your site in a separate folder (`dist/` by default) and you can watch its progress in the terminal. This will alert you to any build errors in your project before you deploy to production. If TypeScript is configured to `strict` or `strictest`, the `build` script will also check your project for type errors. When the build is finished, run the appropriate `preview` command (e.g. `npm run preview`) in your terminal and you can view the built version of your site locally in the same browser preview window. Note that this previews your code as it existed when the build command was last run. This is meant to give you a preview of how your site will look when it is deployed to the web. Any later changes you make to your code after building will **not** be reflected while you preview your site until you run the build command again. Use (`Ctrl` + `C`) to quit the preview and run another terminal command, such as restarting the dev server to go back to [working in development mode](#work-in-development-mode) which does update as you edit to show a live preview of your code changes. Read more about [the Astro CLI](/en/reference/cli-reference/) and the terminal commands you will use as you build with Astro. ## Next Steps [Section titled ‚ÄúNext Steps‚Äù](#next-steps) Success! You are now ready to start building with Astro! ü•≥ Here are a few things that we recommend exploring next. You can read them in any order. You can even leave our documentation for a bit and go play in your new Astro project codebase, coming back here whenever you run into trouble or have a question. ### Configure your dev environment [Section titled ‚ÄúConfigure your dev environment‚Äù](#configure-your-dev-environment) Explore the guides below to customize your development experience. [Editor Setup ](/en/editor-setup/)Customize your code editor to improve the Astro developer experience and unlock new features. [Dev Toolbar ](/en/guides/dev-toolbar/)Explore the helpful features of the dev toolbar. [TypeScript Configuration ](/en/guides/typescript/)Configure options for type-checking, IntelliSense, and more. ### Explore Astro‚Äôs Features [Section titled ‚ÄúExplore Astro‚Äôs Features‚Äù](#explore-astros-features) [Understand your codebase ](/en/basics/project-structure/)Learn about Astro‚Äôs file structure in our Project Structure guide. [Create content collections ](/en/guides/content-collections/)Add content to your new site with frontmatter validation and automatic type-safety. [Add view transitions ](/en/guides/view-transitions/)Create seamless page transitions and animations. [Learn about Islands ](/en/concepts/islands/)Read about Astro's islands architecture. ### Take the introductory tutorial [Section titled ‚ÄúTake the introductory tutorial‚Äù](#take-the-introductory-tutorial) Build a fully functional Astro blog starting from a single blank page in our [introductory tutorial](/en/tutorial/0-introduction/). This is a great way to see how Astro works and walks you through the basics of pages, layouts, components, routing, islands, and more. It also includes an optional, beginner-friendly unit for those newer to web development concepts in general, which will guide you through installing the necessary applications on your computer, creating a GitHub account, and deploying your site.

# Configuration overview

> Get to know the ways you can configure and customize your new project and your development experience.

Astro is a flexible, unopinionated framework that allows you to configure your project in many different ways. This means that getting started with a new project might feel overwhelming: there is no ‚Äúone best way‚Äù to set up your Astro project! The guides in this ‚ÄúConfiguration‚Äù section will help you familiarize yourself with the various files that allow you to configure and customize aspects of your project and development environment. If this is your first Astro project, or if it‚Äôs been a while since you‚Äôve set up a new project, use the following guides and reference in the documentation for assistance. ## The Astro config File [Section titled ‚ÄúThe Astro config File‚Äù](#the-astro-config-file) The [Astro config file](/en/reference/configuration-reference/) is a JavaScript file included at the root of every starter project: astro.config.mjs ```js import { defineConfig } from "astro/config"; export default defineConfig({ // your configuration options here... }); ``` It is only required if you have something to configure, but most projects will use this file. The `defineConfig()` helper provides automatic IntelliSense in your IDE and is where you will add all your configuration options to tell Astro how to build and render your project to HTML. We recommend using the default file format `.mjs` in most cases, or `.ts` if you want to write TypeScript in your config file. However, `astro.config.js` and `astro.config.cjs` are also supported. Read Astro‚Äôs [configuration reference](/en/reference/configuration-reference/) for a full overview of all supported configuration options. ## The TypeScript config File [Section titled ‚ÄúThe TypeScript config File‚Äù](#the-typescript-config-file) Every Astro starter project includes a `tsconfig.json` file in your project. Astro‚Äôs [component script](/en/basics/astro-components/#the-component-script) is Typescript, which provides Astro‚Äôs editor tooling and allows you to optionally add syntax to your JavaScript for type checking of your own project code. Use the `tsconfig.json` file to configure the TypeScript template that will perform type checks on your code, configure TypeScript plugins, set import aliases, and more. Read Astro‚Äôs [TypeScript guide](/en/guides/typescript/) for a full overview of TypeScript options and Astro‚Äôs built-in utility types. ## Development Experience [Section titled ‚ÄúDevelopment Experience‚Äù](#development-experience) While you work in development mode, you can take advantage of your code editor and other tools to improve the Astro developer experience. Astro provides its own official VS Code extension and is compatible with several other popular editor tools. Astro also provides a customizable toolbar that displays in your browser preview while the dev server is running. You can install and even build your own toolbar apps for additional functionality. Read Astro‚Äôs guides to [editor setup options](/en/editor-setup/) and [using the dev toolbar](/en/guides/dev-toolbar/) to learn how to customize your development experience. ## Common new project tasks [Section titled ‚ÄúCommon new project tasks‚Äù](#common-new-project-tasks) Here are some first steps you might choose to take with a new Astro project. ### Add your deployment domain [Section titled ‚ÄúAdd your deployment domain‚Äù](#add-your-deployment-domain) For generating your sitemap and creating canonical URLs, configure your deployment URL in the [`site`](/en/reference/configuration-reference/#site) option. If you are deploying to a path (e.g. `www.example.com/docs`), you can also configure a [`base`](/en/reference/configuration-reference/#base) for the root of your project. Additionally, different deployment hosts may have different behavior regarding trailing slashes at the end of your URLs. (e.g. `example.com/about` vs `example.com/about/`). Once your site is deployed, you may need to configure your [`trailingSlash`](/en/reference/configuration-reference/#trailingslash) preference. astro.config.mjs ```js import { defineConfig } from "astro/config"; export default defineConfig({ site: "https://www.example.com", base: "/docs", trailingSlash: "always", }); ``` ### Add site metadata [Section titled ‚ÄúAdd site metadata‚Äù](#add-site-metadata) Astro does not use its configuration file for common SEO or meta data, only for information required to build your project code and render it to HTML. Instead, this information is added to your page `<head>` using standard HTML `<link>` and `<meta>` tags, just as if you were writing plain HTML pages. One common pattern for Astro sites is to create a `<Head />` [`.astro` component](/en/basics/astro-components/) that can be added to a common [layout component](/en/basics/layouts/) so it can apply to all your pages. src/components/MainLayout.astro ```astro --- import Head from "./Head.astro"; const { ...props } = Astro.props; --- <html> <head> <meta charset="utf-8"> <Head /> <!-- Additional head elements --> </head> <body> <!-- Page content goes here --> </body> </html> ``` Because `Head.astro` is just a regular Astro component, you can import files and receive props passed from other components, such as a specific page title. src/components/Head.astro ```astro --- import Favicon from "../assets/Favicon.astro"; import SomeOtherTags from "./SomeOtherTags.astro"; const { title = "My Astro Website", ...props } = Astro.props; --- <link rel="sitemap" href="/sitemap-index.xml"> <title>{title}</title> <meta name="description" content="Welcome to my new Astro site!"> <!-- Web analytics --> <script data-goatcounter="https://my-account.goatcounter.com/count" async src="//gc.zgo.at/count.js"></script> <!-- Open Graph tags --> <meta property="og:title" content="My New Astro Website" /> <meta property="og:type" content="website" /> <meta property="og:url" content="http://www.example.com/" /> <meta property="og:description" content="Welcome to my new Astro site!" /> <meta property="og:image" content="https://www.example.com/_astro/seo-banner.BZD7kegZ.webp"> <meta property="og:image:alt" content=""> <SomeOtherTags /> <Favicon /> ```

# Astro Courses

> Learn Astro with out-of-this-world courses and tutorials.

Want to get started learning Astro with a course or tutorial? You can learn the basics of Astro with our [official docs Build a Blog tutorial](/en/tutorial/0-introduction/), or explore our collection of recommended Astro educational content. ## Education Partners [Section titled ‚ÄúEducation Partners‚Äù](#education-partners) Learn Astro from trusted Astro educators, with video lessons, interactive challenges, and projects! [Learn Astro with Coding in Public ](https://learnastro.dev/?code=ASTRO_PROMO)A premium interactive course with 150+ video lessons that teaches you how to use Astro‚Äôs built-in tooling and features. [Learn Astro with James Q Quick ](https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro)Build your first Astro site with 35 interactive Scrimba lessons, with video and IDE merged into one unique learning platform. ## Community learning resources [Section titled ‚ÄúCommunity learning resources‚Äù](#community-learning-resources) Learn from your fellow astronauts with curated collections of guides, articles, and blog posts. [Astro Tips ](https://astro-tips.dev/)Advanced, unusual, experimental, and community-written recipes, tutorials, and quick tips. [Astro Support Squid ](https://get.supportsquid.ink/)An open, public Astro support forum and knowledge base outside of the Astro Discord.

# Components

> An introduction to Astro components.

**Astro components** are the basic building blocks of any Astro project. They are HTML-only templating components with no client-side runtime and use the `.astro` file extension. Astro components are extremely flexible. An Astro component can be as small as a snippet of HTML, like a collection of common `<meta>` tags that make SEO easy to work with. Components can be reusable UI elements, like a header or a profile card. Astro components can even contain an entire page layout or, when located in the special `src/pages/` folder, be an entire page itself. The most important thing to know about Astro components is that they **don‚Äôt render on the client**. They render to HTML either at build-time or on-demand. You can include JavaScript code inside of your component frontmatter, and all of it will be stripped from the final page sent to your users‚Äô browsers. The result is a faster site, with zero JavaScript footprint added by default. When your Astro component does need client-side interactivity, you can add [standard HTML `<script>` tags](/en/guides/client-side-scripts/) or [UI Framework components](/en/guides/framework-components/#hydrating-interactive-components) as ‚Äúclient islands‚Äù. For components that need to render personalized or dynamic content, you can defer their server rendering by adding a [server directive](/en/reference/directives-reference/#server-directives). These ‚Äúserver islands‚Äù will render their content when it is available, without delaying the entire page load. ## Component Structure [Section titled ‚ÄúComponent Structure‚Äù](#component-structure) An Astro component is made up of two main parts: the **Component Script** and the **Component Template**. Each part performs a different job, but together they provide a framework that is both easy to use and expressive enough to handle whatever you might want to build. src/components/EmptyComponent.astro ```astro --- // Component Script (JavaScript) --- <!-- Component Template (HTML + JS Expressions) --> ``` ### The Component Script [Section titled ‚ÄúThe Component Script‚Äù](#the-component-script) Astro uses a code fence (`---`) to identify the component script in your Astro component. If you‚Äôve ever written Markdown before, you may already be familiar with a similar concept called *frontmatter.* Astro‚Äôs idea of a component script was directly inspired by this concept. You can use the component script to write any JavaScript code that you need to render your template. This can include: * importing other Astro components * importing other framework components, like React * importing data, like a JSON file * fetching content from an API or database * creating variables that you will reference in your template src/components/MyComponent.astro ```astro --- import SomeAstroComponent from '../components/SomeAstroComponent.astro'; import SomeReactComponent from '../components/SomeReactComponent.jsx'; import someData from '../data/pokemon.json'; // Access passed-in component props, like `<X title="Hello, World" />` const { title } = Astro.props; // Fetch external data, even from a private API or database const data = await fetch('SOME_SECRET_API_URL/users').then(r => r.json()); --- <!-- Your template here! --> ``` The code fence is designed to guarantee that the JavaScript that you write in it is ‚Äúfenced in.‚Äù It won‚Äôt escape into your frontend application, or fall into your user‚Äôs hands. You can safely write code here that is expensive or sensitive (like a call to your private database) without worrying about it ever ending up in your user‚Äôs browser. ### The Component Template [Section titled ‚ÄúThe Component Template‚Äù](#the-component-template) The component template is below the code fence and determines the HTML output of your component. If you write plain HTML here, your component will render that HTML in any Astro page it is imported and used. However, [Astro‚Äôs component template syntax](/en/reference/astro-syntax/) also supports **JavaScript expressions**, Astro [`<style>`](/en/guides/styling/#styling-in-astro) and [`<script>`](/en/guides/client-side-scripts/) tags, **imported components**, and [**special Astro directives**](/en/reference/directives-reference/). Data and values defined in the component script can be used in the component template to produce dynamically-created HTML. src/components/MyFavoritePokemon.astro ```astro --- // Your component script here! import Banner from '../components/Banner.astro'; import Avatar from '../components/Avatar.astro'; import ReactPokemonComponent from '../components/ReactPokemonComponent.jsx'; const myFavoritePokemon = [/* ... */]; const { title } = Astro.props; --- <!-- HTML comments supported! --> {/* JS comment syntax is also valid! */} <Banner /> <h1>Hello, world!</h1> <!-- Use props and other variables from the component script: --> <p>{title}</p> <!-- Delay component rendering and provide fallback loading content: --> <Avatar server:defer> <svg slot="fallback" class="generic-avatar" transition:name="avatar">...</svg> </Avatar> <!-- Include other UI framework components with a `client:` directive to hydrate: --> <ReactPokemonComponent client:visible /> <!-- Mix HTML with JavaScript expressions, similar to JSX: --> <ul> {myFavoritePokemon.map((data) => <li>{data.name}</li>)} </ul> <!-- Use a template directive to build class names from multiple strings or even objects! --> <p class:list={["add", "dynamic", { classNames: true }]} /> ``` ## Component-based design [Section titled ‚ÄúComponent-based design‚Äù](#component-based-design) Components are designed to be **reusable** and **composable**. You can use components inside of other components to build more and more advanced UI. For example, a `Button` component could be used to create a `ButtonGroup` component: src/components/ButtonGroup.astro ```astro --- import Button from './Button.astro'; --- <div> <Button title="Button 1" /> <Button title="Button 2" /> <Button title="Button 3" /> </div> ``` ## Component Props [Section titled ‚ÄúComponent Props‚Äù](#component-props) An Astro component can define and accept props. These props then become available to the component template for rendering HTML. Props are available on the `Astro.props` global in your frontmatter script. Here is an example of a component that receives a `greeting` prop and a `name` prop. Notice that the props to be received are destructured from the global `Astro.props` object. src/components/GreetingHeadline.astro ```astro --- // Usage: <GreetingHeadline greeting="Howdy" name="Partner" /> const { greeting, name } = Astro.props; --- <h2>{greeting}, {name}!</h2> ``` This component, when imported and rendered in other Astro components, layouts or pages, can pass these props as attributes: src/components/GreetingCard.astro ```astro --- import GreetingHeadline from './GreetingHeadline.astro'; const name = 'Astro'; --- <h1>Greeting Card</h1> <GreetingHeadline greeting="Hi" name={name} /> <p>I hope you have a wonderful day!</p> ``` You can also define your props with TypeScript with a `Props` type interface. Astro will automatically pick up the `Props` interface in your frontmatter and give type warnings/errors. These props can also be given default values when destructured from `Astro.props`. src/components/GreetingHeadline.astro ```diff --- +interface Props { + name: string; + greeting?: string; +} const { greeting = "Hello", name } = Astro.props; --- <h2>{greeting}, {name}!</h2> ``` Component props can be given default values to use when none are provided. src/components/GreetingHeadline.astro ```astro --- const { greeting = "Hello", name = "Astronaut" } = Astro.props; --- <h2>{greeting}, {name}!</h2> ``` ## Slots [Section titled ‚ÄúSlots‚Äù](#slots) The `<slot />` element is a placeholder for external HTML content, allowing you to inject (or ‚Äúslot‚Äù) child elements from other files into your component template. By default, all child elements passed to a component will be rendered in its `<slot />`. src/components/Wrapper.astro ```astro --- import Header from './Header.astro'; import Logo from './Logo.astro'; import Footer from './Footer.astro'; const { title } = Astro.props; --- <div id="content-wrapper"> <Header /> <Logo /> <h1>{title}</h1> <slot /> <!-- children will go here --> <Footer /> </div> ``` src/pages/fred.astro ```astro --- import Wrapper from '../components/Wrapper.astro'; --- <Wrapper title="Fred's Page"> <h2>All about Fred</h2> <p>Here is some stuff about Fred.</p> </Wrapper> ``` This pattern is the basis of an [Astro layout component](/en/basics/layouts/): an entire page of HTML content can be ‚Äúwrapped‚Äù with `<SomeLayoutComponent></SomeLayoutComponent>` tags and sent to the component to render inside of common page elements defined there. See the [`Astro.slots` utility functions](/en/reference/astro-syntax/#astroslots) for more ways to access and render slot content. ### Named Slots [Section titled ‚ÄúNamed Slots‚Äù](#named-slots) An Astro component can also have named slots. This allows you to pass only HTML elements with the corresponding slot name into a slot‚Äôs location. Slots are named using the `name` attribute: src/components/Wrapper.astro ```astro --- import Header from './Header.astro'; import Logo from './Logo.astro'; import Footer from './Footer.astro'; const { title } = Astro.props; --- <div id="content-wrapper"> <Header /> <!-- children with the `slot="after-header"` attribute will go here --> <slot name="after-header" /> <Logo /> <h1>{title}</h1> <!-- children without a `slot`, or with `slot="default"` attribute will go here --> <slot /> <Footer /> <!-- children with the `slot="after-footer"` attribute will go here --> <slot name="after-footer" /> </div> ``` To inject HTML content into a particular slot, use the `slot` attribute on any child element to specify the name of the slot. All other child elements of the component will be injected into the default (unnamed) `<slot />`. src/pages/fred.astro ```astro --- import Wrapper from '../components/Wrapper.astro'; --- <Wrapper title="Fred's Page"> <img src="https://my.photo/fred.jpg" slot="after-header" /> <h2>All about Fred</h2> <p>Here is some stuff about Fred.</p> <p slot="after-footer">Copyright 2022</p> </Wrapper> ``` To pass multiple HTML elements into a component‚Äôs `<slot/>` placeholder without a wrapping `<div>`, use the `slot=""` attribute on [Astro‚Äôs `<Fragment/>` component](/en/reference/astro-syntax/#fragments): src/components/CustomTable.astro ```astro --- // Create a custom table with named slot placeholders for header and body content --- <table class="bg-white"> <thead class="sticky top-0 bg-white"><slot name="header" /></thead> <tbody class="[&_tr:nth-child(odd)]:bg-gray-100"><slot name="body" /></tbody> </table> ``` Inject multiple rows and columns of HTML content using a `slot=""` attribute to specify the `"header"` and `"body"` content. Individual HTML elements can also be styled: src/components/StockTable.astro ```astro --- import CustomTable from './CustomTable.astro'; --- <CustomTable> <Fragment slot="header"> <!-- pass table header --> <tr><th>Product name</th><th>Stock units</th></tr> </Fragment> <Fragment slot="body"> <!-- pass table body --> <tr><td>Flip-flops</td><td>64</td></tr> <tr><td>Boots</td><td>32</td></tr> <tr><td>Sneakers</td><td class="text-red-500">0</td></tr> </Fragment> </CustomTable> ``` Note that named slots must be an immediate child of the component. You cannot pass named slots through nested elements. ### Fallback Content for Slots [Section titled ‚ÄúFallback Content for Slots‚Äù](#fallback-content-for-slots) Slots can also render **fallback content**. When there are no matching children passed to a slot, a `<slot />` element will render its own placeholder children. src/components/Wrapper.astro ```astro --- import Header from './Header.astro'; import Logo from './Logo.astro'; import Footer from './Footer.astro'; const { title } = Astro.props; --- <div id="content-wrapper"> <Header /> <Logo /> <h1>{title}</h1> <slot> <p>This is my fallback content, if there is no child passed into slot</p> </slot> <Footer /> </div> ``` Fallback content will only be displayed when there are no matching elements with the `slot="name"` attribute being passed in to a named slot. Astro will pass an empty slot when a slot element exists but has no content to pass. Fallback content cannot be used as a default when an empty slot is passed. Fallback content is only displayed when no slot element can be found. ### Transferring slots [Section titled ‚ÄúTransferring slots‚Äù](#transferring-slots) Slots can be transferred to other components. For example, when creating nested layouts: src/layouts/BaseLayout.astro ```astro --- --- <html lang="en"> <head> <meta charset="utf-8" /> <link rel="icon" type="image/svg+xml" href="/favicon.svg" /> <meta name="viewport" content="width=device-width" /> <meta name="generator" content={Astro.generator} /> <slot name="head" /> </head> <body> <slot /> </body> </html> ``` src/layouts/HomeLayout.astro ```astro --- import BaseLayout from './BaseLayout.astro'; --- <BaseLayout> <slot name="head" slot="head" /> <slot /> </BaseLayout> ``` Now, the default and `head` slots passed to `HomeLayout` will be transferred to the `BaseLayout` parent. src/pages/index.astro ```astro --- import HomeLayout from '../layouts/HomeLayout.astro'; --- <HomeLayout> <title slot="head">Astro</title> <h1>Astro</h1> </HomeLayout> ``` ## HTML Components [Section titled ‚ÄúHTML Components‚Äù](#html-components) Astro supports importing and using `.html` files as components or placing these files within the `src/pages/` subdirectory as pages. You may want to use HTML components if you‚Äôre reusing code from an existing site built without a framework, or if you want to ensure that your component has no dynamic features. HTML components must contain only valid HTML, and therefore lack key Astro component features: * They don‚Äôt support frontmatter, server-side imports, or dynamic expressions. * Any `<script>` tags are left unbundled, treated as if they had an [`is:inline` directive](/en/reference/directives-reference/#isinline). * They can only [reference assets that are in the `public/` folder](/en/basics/project-structure/#public). ## Next Steps [Section titled ‚ÄúNext Steps‚Äù](#next-steps) Read more about using [UI framework components](/en/guides/framework-components/) in your Astro project.

# Pages

> An introduction to Astro pages.

**Pages** are files that live in the `src/pages/` subdirectory of your Astro project. They are responsible for handling routing, data loading, and overall page layout for every page in your website. ## Supported page files [Section titled ‚ÄúSupported page files‚Äù](#supported-page-files) Astro supports the following file types in the `src/pages/` directory: * [`.astro`](#astro-pages) * [`.md`](#markdownmdx-pages) * `.mdx` (with the [MDX Integration installed](/en/guides/integrations-guide/mdx/#installation)) * [`.html`](#html-pages) * `.js`/`.ts` (as [endpoints](/en/guides/endpoints/)) ## File-based routing [Section titled ‚ÄúFile-based routing‚Äù](#file-based-routing) Astro leverages a routing strategy called **file-based routing**. Each file in your `src/pages/` directory becomes an endpoint on your site based on its file path. A single file can also generate multiple pages using [dynamic routing](/en/guides/routing/#dynamic-routes). This allows you to create pages even if your content lives outside of the special `/pages/` directory, such as in a [content collection](/en/guides/content-collections/) or a [CMS](/en/guides/cms/). Read more about [Routing in Astro](/en/guides/routing/). ### Link between pages [Section titled ‚ÄúLink between pages‚Äù](#link-between-pages) Write standard HTML [`<a>` elements](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a) in your Astro pages to link to other pages on your site. Use a **URL path relative to your root domain** as your link, not a relative file path. For example, to link to `https://example.com/authors/sonali/` from any other page on `example.com`: src/pages/index.astro ```astro Read more <a href="/authors/sonali/">about Sonali</a>. ``` ## Astro Pages [Section titled ‚ÄúAstro Pages‚Äù](#astro-pages) Astro pages use the `.astro` file extension and support the same features as [Astro components](/en/basics/astro-components/). src/pages/index.astro ```astro --- --- <html lang="en"> <head> <title>My Homepage</title> </head> <body> <h1>Welcome to my website!</h1> </body> </html> ``` A page must produce a full HTML document. If not explicitly included, Astro will add the necessary `<!DOCTYPE html>` declaration and `<head>` content to any `.astro` component located within `src/pages/` by default. You can opt-out of this behavior on a per-component basis by marking it as a [partial](#page-partials) page. To avoid repeating the same HTML elements on every page, you can move common `<head>` and `<body>` elements into your own [layout components](/en/basics/layouts/). You can use as many or as few layout components as you‚Äôd like. src/pages/index.astro ```astro --- import MySiteLayout from "../layouts/MySiteLayout.astro"; --- <MySiteLayout> <p>My page content, wrapped in a layout!</p> </MySiteLayout> ``` Read more about [layout components](/en/basics/layouts/) in Astro. ## Markdown/MDX Pages [Section titled ‚ÄúMarkdown/MDX Pages‚Äù](#markdownmdx-pages) Astro also treats any Markdown (`.md`) files inside of `src/pages/` as pages in your final website. If you have the [MDX Integration installed](/en/guides/integrations-guide/mdx/#installation), it also treats MDX (`.mdx`) files the same way. Markdown files can use the special `layout` frontmatter property to specify a [layout component](/en/basics/layouts/) that will wrap their Markdown content in a full `<html>...</html>` page document. src/pages/page.md ```md --- layout: ../layouts/MySiteLayout.astro title: My Markdown page --- # Title This is my page, written in **Markdown.** ``` Read more about [Markdown](/en/guides/markdown-content/) in Astro. ## HTML Pages [Section titled ‚ÄúHTML Pages‚Äù](#html-pages) Files with the `.html` file extension can be placed in the `src/pages/` directory and used directly as pages on your site. Note that some key Astro features are not supported in [HTML Components](/en/basics/astro-components/#html-components). ## Custom 404 Error Page [Section titled ‚ÄúCustom 404 Error Page‚Äù](#custom-404-error-page) For a custom 404 error page, you can create a `404.astro` or `404.md` file in `src/pages`. This will build to a `404.html` page. Most [deploy services](/en/guides/deploy/) will find and use it. ## Custom 500 Error Page [Section titled ‚ÄúCustom 500 Error Page‚Äù](#custom-500-error-page) For a custom 500 error page to show for pages that are [rendered on demand](/en/guides/on-demand-rendering/), create the file `src/pages/500.astro`. This custom page is not available for prerendered pages. If an error occurs rendering this page, your host‚Äôs default 500 error page will be shown to your visitor. **Added in:** `astro@4.10.3` During development, if you have a `500.astro`, the error thrown at runtime is logged in your terminal, as opposed to being shown in the error overlay. ### `error` [Section titled ‚Äúerror‚Äù](#error) **Added in:** `astro@4.11.0` `src/pages/500.astro` is a special page that is automatically passed an `error` prop for any error thrown during rendering. This allows you to use the details of an error (e.g. from a page, from middleware, etc.) to display information to your visitor. The `error` prop‚Äôs data type can be anything, which may affect how you type or use the value in your code: src/pages/500.astro ```astro --- interface Props { error: unknown; } const { error } = Astro.props; --- <div>{error instanceof Error ? error.message : "Unknown error"}</div> ``` To avoid leaking sensitive information when displaying content from the `error` prop, consider evaluating the error first, and returning appropriate content based on the error thrown. For example, you should avoid displaying the error‚Äôs stack as it contains information about how your code is structured on the server. ## Page Partials [Section titled ‚ÄúPage Partials‚Äù](#page-partials) **Added in:** `astro@3.4.0` Caution Page partials are intended to be used in conjunction with a front-end library, such as [htmx](https://htmx.org/) or [Unpoly](https://unpoly.com/). You can also use them if you are comfortable writing low-level front-end JavaScript. For this reason they are an advanced feature. Additionally, partials should not be used if the component contains scoped styles or scripts, as these elements will be stripped from the HTML output. If you need scoped styles, it is better to use regular, non-partial pages along with a frontend library that knows how to merge the contents into the head. Partials are page components located within `src/pages/` that are not intended to render as full pages. Like components located outside of this folder, these files do not automatically include the `<!DOCTYPE html>` declaration, nor any `<head>` content such as scoped styles and scripts. However, because they are located in the special `src/pages/` directory, the generated HTML is available at a URL corresponding to its file path. This allows a rendering library (e.g. [htmx](https://htmx.org/), [Stimulus](https://stimulus.hotwired.dev/), [jQuery](https://jquery.com/)) to access it on the client and load sections of HTML dynamically on a page without a browser refresh or page navigation. Partials, when combined with a rendering library, provide an alternative to [Astro islands](/en/concepts/islands/) and [`<script>` tags](/en/guides/client-side-scripts/) for building dynamic content in Astro. Page files that can export a value for [`partial`](/en/reference/routing-reference/#partial) (e.g. `.astro` and `.mdx`, but not `.md`) can be marked as partials. src/pages/partial.astro ```diff --- +export const partial = true; --- <li>I'm a partial!</li> ``` ### Using with a library [Section titled ‚ÄúUsing with a library‚Äù](#using-with-a-library) Partials are used to dynamically update a section of a page using a library such as [htmx](https://htmx.org/). The following example shows an `hx-post` attribute set to a partial‚Äôs URL. The content from the partial page will be used to update the targeted HTML element on this page. src/pages/index.astro ```astro <html> <head> <title>My page</title> <script src="https://unpkg.com/htmx.org@1.9.6" integrity="sha384-FhXw7b6AlE/jyjlZH5iHa/tTe9EpJ1Y55RjcgPbjeWMskSxZt1v9qkxLJWNJaGni" crossorigin="anonymous"></script> </head> <body> <section> <div id="parent-div">Target here</div> <button hx-post="/partials/clicked/" hx-trigger="click" hx-target="#parent-div" hx-swap="innerHTML" > Click Me! </button> </section> </body> </html> ``` The `.astro` partial must exist at the corresponding file path, and include an export defining the page as a partial: src/pages/partials/clicked.astro ```astro --- export const partial = true; --- <div>I was clicked!</div> ``` See the [htmx documentation](https://htmx.org/docs/) for more details on using htmx.

# Layouts

> An introduction to layouts in Astro.

**Layouts** are [Astro components](/en/basics/astro-components/) used to provide a reusable UI structure, such as a page template. We conventionally use the term ‚Äúlayout‚Äù for Astro components that provide common UI elements shared across pages such as headers, navigation bars, and footers. A typical Astro layout component provides [Astro, Markdown or MDX pages](/en/basics/astro-pages/) with: * a **page shell** (`<html>`, `<head>` and `<body>` tags) * a [**`<slot />`**](/en/basics/astro-components/#slots) to specify where individual page content should be injected. But, there is nothing special about a layout component! They can [accept props](/en/basics/astro-components/#component-props) and [import and use other components](/en/basics/astro-components/#component-structure) like any other Astro component. They can include [UI frameworks components](/en/guides/framework-components/) and [client-side scripts](/en/guides/client-side-scripts/). They do not even have to provide a full page shell, and can instead be used as partial UI templates. However, if a layout component does contain a page shell, its `<html>` element must be the parent of all other elements in the component. Layout components are commonly placed in a `src/layouts` directory in your project for organization, but this is not a requirement; you can choose to place them anywhere in your project. You can even colocate layout components alongside your pages by [prefixing the layout names with `_`](/en/guides/routing/#excluding-pages). ## Sample Layout [Section titled ‚ÄúSample Layout‚Äù](#sample-layout) src/layouts/MySiteLayout.astro ```astro --- import BaseHead from '../components/BaseHead.astro'; import Footer from '../components/Footer.astro'; const { title } = Astro.props; --- <html lang="en"> <head> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1"> <BaseHead title={title}/> </head> <body> <nav> <a href="#">Home</a> <a href="#">Posts</a> <a href="#">Contact</a> </nav> <h1>{title}</h1> <article> <slot /> <!-- your content is injected here --> </article> <Footer /> </body> <style> h1 { font-size: 2rem; } </style> </html> ``` src/pages/index.astro ```astro --- import MySiteLayout from '../layouts/MySiteLayout.astro'; --- <MySiteLayout title="Home Page"> <p>My page content, wrapped in a layout!</p> </MySiteLayout> ``` Learn more about [slots](/en/basics/astro-components/#slots). ## Using TypeScript with layouts [Section titled ‚ÄúUsing TypeScript with layouts‚Äù](#using-typescript-with-layouts) Any Astro layout can be modified to introduce type safety & autocompletion by providing the types for your props: src/components/MyLayout.astro ```diff --- +interface Props { + title: string; + description: string; + publishDate: string; + viewCount: number; +} const { title, description, publishDate, viewCount } = Astro.props; --- <html lang="en"> <head> <meta charset="UTF-8"> <meta name="description" content={description}> <title>{title}</title> </head> <body> <header> <p>Published on {publishDate}</p> <p>Viewed by {viewCount} folks</p> </header> <main> <slot /> </main> </body> </html> ``` ## Markdown Layouts [Section titled ‚ÄúMarkdown Layouts‚Äù](#markdown-layouts) Page layouts are especially useful for individual Markdown pages which otherwise would not have any page formatting. Astro provides a special `layout` frontmatter property intended for [individual `.md` files located within `src/pages/` using file-based routing](/en/guides/markdown-content/#individual-markdown-pages) to specify which `.astro` component to use as the page layout. This component allows you to provide `<head>` content like meta tags (e.g. `<meta charset="utf-8">`) and styles for the Markdown page. By default, this specified component can automatically access data from the Markdown file. This is not recognized as a special property when using [content collections](/en/guides/content-collections/) to query and render your content. src/pages/page.md ```markdown --- layout: ../layouts/BlogPostLayout.astro title: "Hello, World!" author: "Matthew Phillips" date: "09 Aug 2022" --- All frontmatter properties are available as props to an Astro layout component. The `layout` property is the only special one provided by Astro. You can use it in Markdown files located within `src/pages/`. ``` A typical layout for a Markdown page includes: 1. The `frontmatter` prop to access the Markdown page‚Äôs frontmatter and other data. 2. A default [`<slot />`](/en/basics/astro-components/#slots) to indicate where the page‚Äôs Markdown content should be rendered. src/layouts/BlogPostLayout.astro ```astro --- // 1. The frontmatter prop gives access to frontmatter and other data const { frontmatter } = Astro.props; --- <html> <head> <!-- Add other Head elements here, like styles and meta tags. --> <meta name="viewport" content="width=device-width, initial-scale=1"> <meta charset="utf-8"> <title>{frontmatter.title}</title> </head> <body> <!-- Add other UI components here, like common headers and footers. --> <h1>{frontmatter.title} by {frontmatter.author}</h1> <!-- 2. Rendered HTML will be passed into the default slot. --> <slot /> <p>Written on: {frontmatter.date}</p> </body> </html> ``` You can set a layout‚Äôs [`Props` type](/en/guides/typescript/#component-props) with the `MarkdownLayoutProps` helper: src/layouts/BlogPostLayout.astro ```diff --- +import type { MarkdownLayoutProps } from 'astro'; +type Props = MarkdownLayoutProps<{ +// Define frontmatter props here + title: string; + author: string; + date: string; +}>; // Now, `frontmatter`, `url`, and other Markdown layout properties // are accessible with type safety const { frontmatter, url } = Astro.props; --- <html> <head> <meta charset="utf-8"> <link rel="canonical" href={new URL(url, Astro.site).pathname}> <title>{frontmatter.title}</title> </head> <body> <h1>{frontmatter.title} by {frontmatter.author}</h1> <slot /> <p>Written on: {frontmatter.date}</p> </body> </html> ``` ### Markdown Layout Props [Section titled ‚ÄúMarkdown Layout Props‚Äù](#markdown-layout-props) A Markdown layout will have access to the following information via `Astro.props`: * **`file`** - The absolute path of this file (e.g. `/home/user/projects/.../file.md`). * **`url`** - The URL of the page (e.g. `/en/guides/markdown-content`). * **`frontmatter`** - All frontmatter from the Markdown or MDX document. * **`frontmatter.file`** - The same as the top-level `file` property. * **`frontmatter.url`** - The same as the top-level `url` property. * **`headings`** - A list of headings (`h1 -> h6`) in the Markdown or MDX document with associated metadata. This list follows the type: `{ depth: number; slug: string; text: string }[]`. * **`rawContent()`** - A function that returns the raw Markdown document as a string. * **`compiledContent()`** - An async function that returns the Markdown document compiled to an HTML string. ### Importing Layouts Manually (MDX) [Section titled ‚ÄúImporting Layouts Manually (MDX)‚Äù](#importing-layouts-manually-mdx) You can also use the special Markdown layout property in the frontmatter of MDX files to pass `frontmatter` and `headings` props directly to a specified layout component in the same way. To pass information to your MDX layout that does not (or cannot) exist in your frontmatter, you can instead import and use a `<Layout />` component. This works like any other Astro component, and will not receive any props automatically. Pass it any necessary props directly: src/pages/posts/first-post.mdx ```diff --- -layout: ../../layouts/BaseLayout.astro title: 'My first MDX post' publishDate: '21 September 2022' --- +import BaseLayout from '../../layouts/BaseLayout.astro'; export function fancyJsHelper() { return "Try doing that with YAML!"; } <BaseLayout title={frontmatter.title} fancyJsHelper={fancyJsHelper}> Welcome to my new Astro blog, using MDX! </BaseLayout> ``` Then, your values are available to you through `Astro.props` in your layout, and your MDX content will be injected into the page where your `<slot />` component is written: src/layouts/BaseLayout.astro ```astro --- const { title, fancyJsHelper } = Astro.props; --- <html> <head> <!-- --> <meta charset="utf-8"> </head> <body> <!-- --> <h1>{title}</h1> <slot /> <!-- your content is injected here --> <p>{fancyJsHelper()}</p> <!-- --> </body> </html> ``` When using any layout (either through the frontmatter `layout` property or by importing a layout), you must include the `<meta charset="utf-8">` tag in your layout as Astro will no longer add it automatically to your MDX page. Learn more about Astro‚Äôs Markdown and MDX support in our [Markdown guide](/en/guides/markdown-content/). ## Nesting Layouts [Section titled ‚ÄúNesting Layouts‚Äù](#nesting-layouts) Layout components do not need to contain an entire page worth of HTML. You can break your layouts into smaller components, and combine layout components to create even more flexible, page templates. This pattern is useful when you want to share some code across multiple layouts. For example, a `BlogPostLayout.astro` layout component could style a post‚Äôs title, date and author. Then, a site-wide `BaseLayout.astro` could handle the rest of your page template, like navigation, footers, SEO meta tags, global styles, and fonts. You can also pass props received from your post to another layout, just like any other nested component. src/layouts/BlogPostLayout.astro ```astro --- import BaseLayout from './BaseLayout.astro'; const { frontmatter } = Astro.props; --- <BaseLayout url={frontmatter.url}> <h1>{frontmatter.title}</h1> <h2>Post author: {frontmatter.author}</h2> <slot /> </BaseLayout> ```

# Editor setup

> Set up your code editor to build with Astro.

Customize your code editor to improve the Astro developer experience and unlock new features. ## VS Code [Section titled ‚ÄúVS Code‚Äù](#vs-code) [VS Code](https://code.visualstudio.com/) is a popular code editor for web developers, built by Microsoft. The VS Code engine also powers popular in-browser code editors like [GitHub Codespaces](https://github.com/features/codespaces). Astro works with any code editor. However, VS Code is our recommended editor for Astro projects. We maintain an official [Astro VS Code Extension](https://marketplace.visualstudio.com/items?itemName=astro-build.astro-vscode) that unlocks several key features and developer experience improvements for Astro projects. * Syntax highlighting for `.astro` files. * TypeScript type information for `.astro` files. * [VS Code Intellisense](https://code.visualstudio.com/docs/editor/intellisense) for code completion, hints and more. To get started, install the [Astro VS Code Extension](https://marketplace.visualstudio.com/items?itemName=astro-build.astro-vscode) today. See how to [set up TypeScript](/en/guides/typescript/) in your Astro project. ## Zed [Section titled ‚ÄúZed‚Äù](#zed) [Zed](https://zed.dev/) is a high-performance, multiplayer code editor that is optimized for speed and large projects. Their [Astro extension](https://zed.dev/extensions/astro) includes features like syntax highlighting for `.astro` files, code completion, formatting, diagnostics, and go-to-definition. ## JetBrains IDEs [Section titled ‚ÄúJetBrains IDEs‚Äù](#jetbrains-ides) [Webstorm](https://www.jetbrains.com/webstorm/) is a JavaScript and TypeScript IDE that added support for the Astro Language Server in version 2024.2. This update brings features like syntax highlighting, code completion, and formatting. Install the official plugin through [JetBrains Marketplace](https://plugins.jetbrains.com/plugin/20959-astro) or by searching for ‚ÄúAstro‚Äù in the IDE‚Äôs Plugins tab. You can toggle the language server in `Settings | Languages & Frameworks | TypeScript | Astro`. For more information on Astro support in Webstorm, check out [the official Webstorm Astro Documentation](https://www.jetbrains.com/help/webstorm/astro.html). ## Other Code Editors [Section titled ‚ÄúOther Code Editors‚Äù](#other-code-editors) Our amazing community maintains several extensions for other popular editors, including: * [VS Code Extension on Open VSX](https://open-vsx.org/extension/astro-build/astro-vscode) Official - The official Astro VS Code Extension, available on the Open VSX registry for editors like [Cursor](https://cursor.com) or [VSCodium](https://vscodium.com/). * [Vim Plugin](https://github.com/wuelnerdotexe/vim-astro) Community - Provides syntax highlighting, indentation, and code folding support for Astro inside of Vim or Neovim * Neovim [LSP](https://github.com/neovim/nvim-lspconfig/blob/master/doc/configs.md#astro) and [TreeSitter](https://github.com/virchau13/tree-sitter-astro) Plugins Community - Provides syntax highlighting, treesitter parsing, and code completion for Astro inside of Neovim * Emacs - See instructions for [Configuring Emacs and Eglot](https://medium.com/@jrmjrm/configuring-emacs-and-eglot-to-work-with-astro-language-server-9408eb709ab0) Community to work with Astro * [Astro syntax highlighting for Sublime Text](https://packagecontrol.io/packages/Astro) Community - The Astro package for Sublime Text, available on the Sublime Text package manager. * [Nova Extension](https://extensions.panic.com/extensions/sciencefidelity/sciencefidelity.astro/) Community - Provides syntax highlighting and code completion for Astro inside of Nova ## In-Browser Editors [Section titled ‚ÄúIn-Browser Editors‚Äù](#in-browser-editors) In addition to local editors, Astro also runs well on in-browser hosted editors, including: * [StackBlitz](https://stackblitz.com/) and [CodeSandbox](https://codesandbox.io/) - online editors that run in your browser, with built-in syntax highlighting support for `.astro` files. No installation or configuration required! * [GitHub.dev](https://github.dev/) - allows you to install the Astro VS Code extension as a [web extension](https://code.visualstudio.com/api/extension-guides/web-extensions), which gives you access to only some of the full extension features. Currently, only syntax highlighting is supported. * [Firebase Studio](https://firebase.studio/) - a full dev environment in the cloud that can install the official Astro VS Code Extension from Open VSX. ## Other tools [Section titled ‚ÄúOther tools‚Äù](#other-tools) ### ESLint [Section titled ‚ÄúESLint‚Äù](#eslint) [ESLint](https://eslint.org/) is a popular linter for JavaScript and JSX. For Astro support, [a community maintained plugin](https://github.com/ota-meshi/eslint-plugin-astro) can be installed. See [the project‚Äôs User Guide](https://ota-meshi.github.io/eslint-plugin-astro/user-guide/) for more information on how to install and set up ESLint for your project. ### Stylelint [Section titled ‚ÄúStylelint‚Äù](#stylelint) [Stylelint](https://stylelint.io/) is a popular linter for CSS. [A community maintained Stylelint configuration](https://github.com/ota-meshi/stylelint-config-html) provides Astro support. Installation instructions, editor integration, and additional information can be found in the project‚Äôs README. ### Biome [Section titled ‚ÄúBiome‚Äù](#biome) [Biome](https://biomejs.dev/) is an all-in-one linter and formatter for the web. [Biome currently has experimental support for `.astro` files](https://biomejs.dev/internals/language-support/#html-super-languages-support), and can be used to lint and format the frontmatter in `.astro` files. ### Prettier [Section titled ‚ÄúPrettier‚Äù](#prettier) [Prettier](https://prettier.io/) is a popular formatter for JavaScript, HTML, CSS, and more. If you‚Äôre using the [Astro VS Code Extension](https://marketplace.visualstudio.com/items?itemName=astro-build.astro-vscode), code formatting with Prettier is included. To add support for formatting `.astro` files outside of the editor (e.g. CLI) or inside editors that don‚Äôt support our editor tooling, install [the official Astro Prettier plugin](https://github.com/withastro/prettier-plugin-astro). 1. Install `prettier` and `prettier-plugin-astro`. * npm ```shell npm install --save-dev --save-exact prettier prettier-plugin-astro ``` * pnpm ```shell pnpm add --save-dev --save-exact prettier prettier-plugin-astro ``` * Yarn ```shell yarn add --dev --exact prettier prettier-plugin-astro ``` 2. Create a `.prettierrc` configuration file (or `.prettierrc.json`, `.prettierrc.mjs`, or [other supported formats](https://prettier.io/docs/configuration)) in the root of your project and add `prettier-plugin-astro` to it. In this file, also manually specify the parser for Astro files. .prettierrc ```json { "plugins": ["prettier-plugin-astro"], "overrides": [ { "files": "*.astro", "options": { "parser": "astro" } } ] } ``` 3. Optionally, install other Prettier plugins for your project, and add them to the configuration file. These additional plugins may need to be listed in a specific order. For example, if you use Tailwind, `prettier-plugin-tailwindcss` must be [the last Prettier plugin in the plugins array](https://github.com/tailwindlabs/prettier-plugin-tailwindcss#compatibility-with-other-prettier-plugins). .prettierrc ```json { "plugins": [ "prettier-plugin-astro", "prettier-plugin-tailwindcss" // needs to be last ], "overrides": [ { "files": "*.astro", "options": { "parser": "astro" } } ] } ``` 4. Run the following command in your terminal to format your files. * npm ```shell npx prettier . --write ``` * pnpm ```shell pnpm exec prettier . --write ``` * Yarn ```shell yarn exec prettier . --write ``` See the [Prettier plugin‚Äôs README](https://github.com/withastro/prettier-plugin-astro/blob/main/README.md) for more information about its supported options, how to set up Prettier inside VS Code, and more. ### dprint [Section titled ‚Äúdprint‚Äù](#dprint) [dprint](https://dprint.dev/) is a highly-configurable code formatter that supports many languages, including JavaScript, TypeScript, CSS, and more. Support for `.astro` files can be added using the [markup\_fmt plugin](https://github.com/g-plane/markup_fmt).

# Actions

> Learn how to create type-safe server functions you can call from anywhere.

**Added in:** `astro@4.15` Astro Actions allow you to define and call backend functions with type-safety. Actions perform data fetching, JSON parsing, and input validation for you. This can greatly reduce the amount of boilerplate needed compared to using an [API endpoint](/en/guides/endpoints/). Use actions instead of API endpoints for seamless communication between your client and server code and to: * Automatically validate JSON and form data inputs using [Zod validation](/en/reference/modules/astro-zod/). * Generate type-safe functions to call your backend from the client and even [from HTML form actions](#call-actions-from-an-html-form-action). No need for manual `fetch()` calls. * Standardize backend errors with the [`ActionError`](/en/reference/modules/astro-actions/#actionerror) object. ## Basic usage [Section titled ‚ÄúBasic usage‚Äù](#basic-usage) Actions are defined in a `server` object exported from `src/actions/index.ts`: src/actions/index.ts ```ts import { defineAction } from 'astro:actions'; import { z } from 'astro/zod'; export const server = { myAction: defineAction({ /* ... */ }) } ``` Your actions are available as functions from the `astro:actions` module. Import `actions` and call them client-side within a [UI framework component](/en/guides/framework-components/), [a form POST request](#call-actions-from-an-html-form-action), or by using a `<script>` tag in an Astro component. When you call an action, it returns an object with either `data` containing the JSON-serialized result, or `error` containing thrown errors. src/pages/index.astro ```astro --- --- <script> import { actions } from 'astro:actions'; async () => { const { data, error } = await actions.myAction({ /* ... */ }); } </script> ``` ### Write your first action [Section titled ‚ÄúWrite your first action‚Äù](#write-your-first-action) Follow these steps to define an action and call it in a `script` tag in your Astro page. 1. Create a `src/actions/index.ts` file and export a `server` object. src/actions/index.ts ```ts export const server = { // action declarations } ``` 2. Import the `defineAction()` utility from `astro:actions`, and the `z` object from `astro/zod`. src/actions/index.ts ```diff +import { defineAction } from 'astro:actions'; +import { z } from 'astro/zod'; export const server = { // action declarations } ``` 3. Use the `defineAction()` utility to define a `getGreeting` action. The `input` property will be used to validate input parameters with a [Zod schema](/en/reference/modules/astro-zod/#common-data-type-validators) and the `handler()` function includes the backend logic to run on the server. src/actions/index.ts ```diff import { defineAction } from 'astro:actions'; import { z } from 'astro/zod'; export const server = { getGreeting: defineAction({ input: z.object({ name: z.string(), }), +handler: async (input) => { return `Hello, ${input.name}!` } }) } ``` 4. Create an Astro component with a button that will fetch a greeting using your `getGreeting` action when clicked. src/pages/index.astro ```astro --- --- <button>Get greeting</button> <script> const button = document.querySelector('button'); button?.addEventListener('click', async () => { // Show alert pop-up with greeting from action }); </script> ``` 5. To use your action, import `actions` from `astro:actions` and then call `actions.getGreeting()` in the click handler. The `name` option will be sent to your action‚Äôs `handler()` on the server and, if there are no errors, the result will be available as the `data` property. src/pages/index.astro ```diff --- --- <button>Get greeting</button> <script> +import { actions } from 'astro:actions'; const button = document.querySelector('button'); button?.addEventListener('click', async () => { // Show alert pop-up with greeting from action +const { data, error } = await actions.getGreeting({ name: "Houston" }); +if (!error) alert(data); }) </script> ``` See the full Actions API documentation for details on [`defineAction()`](/en/reference/modules/astro-actions/#defineaction) and its properties. ## Organizing actions [Section titled ‚ÄúOrganizing actions‚Äù](#organizing-actions) All actions in your project must be exported from the `server` object in the `src/actions/index.ts` file. You can define actions inline or you can move action definitions to separate files and import them. You can even group related functions in nested objects. For example, to colocate all of your user actions, you can create a `src/actions/user.ts` file and nest the definitions of both `getUser` and `createUser` inside a single `user` object. src/actions/user.ts ```ts import { defineAction } from 'astro:actions'; export const user = { getUser: defineAction(/* ... */), createUser: defineAction(/* ... */), } ``` Then, you can import this `user` object into your `src/actions/index.ts` file and add it as a top-level key to the `server` object alongside any other actions: src/actions/index.ts ```diff +import { user } from './user'; export const server = { myAction: defineAction({ /* ... */ }), +user, } ``` Now, all of your user actions are callable from the `actions.user` object: * `actions.user.getUser()` * `actions.user.createUser()` ## Handling returned data [Section titled ‚ÄúHandling returned data‚Äù](#handling-returned-data) Actions return an object containing either `data` with the type-safe return value of your `handler()`, or an `error` with any backend errors. Errors may come from validation errors on the `input` property or thrown errors within the `handler()`. Actions return a custom data format that can handle Dates, Maps, Sets, and URLs [using the Devalue library](https://github.com/Rich-Harris/devalue). Therefore, you can‚Äôt easily inspect the response from the network like you can with regular JSON. For debugging, you can instead inspect the `data` object returned by actions. [See the `handler()` API reference](/en/reference/modules/astro-actions/#handler-property) for full details. ### Checking for errors [Section titled ‚ÄúChecking for errors‚Äù](#checking-for-errors) It‚Äôs best to check if an `error` is present before using the `data` property. This allows you to handle errors in advance and ensures `data` is defined without an `undefined` check. ```ts const { data, error } = await actions.example(); if (error) { // handle error cases return; } // use `data` ``` ### Accessing `data` directly without an error check [Section titled ‚ÄúAccessing data directly without an error check‚Äù](#accessing-data-directly-without-an-error-check) To skip error handling, for example while prototyping or using a library that will catch errors for you, use the `.orThrow()` property on your action call to throw errors instead of returning an `error`. This will return the action‚Äôs `data` directly. This example calls a `likePost()` action that returns the updated number of likes as a `number` from the action `handler`: ```ts const updatedLikes = await actions.likePost.orThrow({ postId: 'example' }); // ^ type: number ``` ### Handling backend errors in your action [Section titled ‚ÄúHandling backend errors in your action‚Äù](#handling-backend-errors-in-your-action) You can use the provided `ActionError` to throw an error from your action `handler()`, such as ‚Äúnot found‚Äù when a database entry is missing, or ‚Äúunauthorized‚Äù when a user is not logged in. This has two main benefits over returning `undefined`: * You can set a status code like `404 - Not found` or `401 - Unauthorized`. This improves debugging errors in both development and in production by letting you see the status code of each request. * In your application code, all errors are passed to the `error` object on an action result. This avoids the need for `undefined` checks on data, and allows you to display targeted feedback to the user depending on what went wrong. #### Creating an `ActionError` [Section titled ‚ÄúCreating an ActionError‚Äù](#creating-an-actionerror) To throw an error, import the [`ActionError()` class](/en/reference/modules/astro-actions/#actionerror) from the `astro:actions` module. Pass it a human-readable status `code` (e.g. `"NOT_FOUND"` or `"BAD_REQUEST"`), and an optional `message` to provide further information about the error. This example throws an error from a `likePost` action when a user is not logged in, after checking a hypothetical ‚Äúuser-session‚Äù cookie for authentication: src/actions/index.ts ```diff import { defineAction, ActionError } from "astro:actions"; import { z } from "astro/zod"; export const server = { likePost: defineAction({ input: z.object({ postId: z.string() }), handler: async (input, ctx) => { if (!ctx.cookies.has('user-session')) { throw new ActionError({ code: "UNAUTHORIZED", message: "User must be logged in.", }); } // Otherwise, like the post }, }), }; ``` #### Handling an `ActionError` [Section titled ‚ÄúHandling an ActionError‚Äù](#handling-an-actionerror) To handle this error, you can call the action from your application and check whether an `error` property is present. This property will be of type `ActionError` and will contain your `code` and `message`. In the following example, a `LikeButton.tsx` component calls the `likePost()` action when clicked. If an authentication error occurs, the `error.code` attribute is used to determine whether to display a login link: src/components/LikeButton.tsx ```tsx import { actions } from 'astro:actions'; import { useState } from 'preact/hooks'; export function LikeButton({ postId }: { postId: string }) { const [showLogin, setShowLogin] = useState(false); return ( <> { showLogin && <a href="/signin">Log in to like a post.</a> } <button onClick={async () => { const { data, error } = await actions.likePost({ postId }); if (error?.code === 'UNAUTHORIZED') setShowLogin(true); // Early return for unexpected errors else if (error) return; // update likes }}> Like </button> </> ) } ``` ### Handling client redirects [Section titled ‚ÄúHandling client redirects‚Äù](#handling-client-redirects) When calling actions from the client, you can integrate with a client-side library like `react-router`, or you can use Astro‚Äôs [`navigate()` function](/en/guides/view-transitions/#trigger-navigation) to redirect to a new page when an action succeeds. This example navigates to the homepage after a `logout` action returns successfully: src/pages/LogoutButton.tsx ```tsx import { actions } from 'astro:actions'; import { navigate } from 'astro:transitions/client'; export function LogoutButton() { return ( <button onClick={async () => { const { error } = await actions.logout(); if (!error) navigate('/'); }}> Logout </button> ); } ``` ## Accepting form data from an action [Section titled ‚ÄúAccepting form data from an action‚Äù](#accepting-form-data-from-an-action) Actions accept JSON data by default. To accept form data from an HTML form, set `accept: 'form'` in your `defineAction()` call: src/actions/index.ts ```diff import { defineAction } from 'astro:actions'; import { z } from 'astro/zod'; export const server = { comment: defineAction({ accept: 'form', input: z.object(/* ... */), handler: async (input) => { /* ... */ }, }) } ``` ### Using validators with form inputs [Section titled ‚ÄúUsing validators with form inputs‚Äù](#using-validators-with-form-inputs) When your action is [configured to accept form data](/en/reference/modules/astro-actions/#accept-property), you can use any Zod validators to validate your fields (e.g. `z.coerce.date()` for date inputs). Extension functions including `.refine()`, `.transform()`, and `.pipe()` are also supported on the `z.object()` validator. Additionally, Astro provides special handling under the hood for your convenience to validate the following types of field inputs: * Inputs of type `number` can be validated using `z.number()` * Inputs of type `checkbox` can be validated using `z.coerce.boolean()` * Inputs of type `file` can be validated using `z.instanceof(File)` * Multiple inputs of the same `name` can be validated using `z.array(/* validator */)` * All other inputs can be validated using `z.string()` When your form is submitted with empty inputs, the output type may not match your `input` validator. Empty values are converted to `null` except when validating arrays or booleans. For example, if an input of type `text` is submitted with an empty value, the result will be `null` instead of an empty string (`""`). To apply a union of different validators, use the `z.discriminatedUnion()` wrapper to narrow the type based on a specific form field. This example accepts a form submission to either ‚Äúcreate‚Äù or ‚Äúupdate‚Äù a user, using the form field with the name `type` to determine which object to validate against: src/actions/index.ts ```ts import { defineAction } from 'astro:actions'; import { z } from 'astro/zod'; export const server = { changeUser: defineAction({ accept: 'form', input: z.discriminatedUnion('type', [ z.object({ // Matches when the `type` field has the value `create` type: z.literal('create'), name: z.string(), email: z.string().email(), }), z.object({ // Matches when the `type` field has the value `update` type: z.literal('update'), id: z.number(), name: z.string(), email: z.string().email(), }), ]), async handler(input) { if (input.type === 'create') { // input is { type: 'create', name: string, email: string } } else { // input is { type: 'update', id: number, name: string, email: string } } }, }), }; ``` ### Validating form data [Section titled ‚ÄúValidating form data‚Äù](#validating-form-data) Actions will parse submitted form data to an object, using the value of each input‚Äôs `name` attribute as the object keys. For example, a form containing `<input name="search">` will be parsed to an object like `{ search: 'user input' }`. Your action‚Äôs `input` schema will be used to validate this object. To receive the raw `FormData` object in your action handler instead of a parsed object, omit the `input` property in your action definition. The following example shows a validated newsletter registration form that accepts a user‚Äôs email and requires a ‚Äúterms of service‚Äù agreement checkbox. 1. Create an HTML form component with unique `name` attributes on each input: src/components/Newsletter.astro ```astro <form> <label for="email">E-mail</label> <input id="email" required type="email" name="email" /> <label> <input required type="checkbox" name="terms"> I agree to the terms of service </label> <button>Sign up</button> </form> ``` 2. Define a `newsletter` action to handle the submitted form. Validate the `email` field using the `z.string().email()` validator, and the `terms` checkbox using `z.boolean()`: src/actions/index.ts ```diff import { defineAction } from 'astro:actions'; import { z } from 'astro/zod'; export const server = { newsletter: defineAction({ accept: 'form', input: z.object({ email: z.string().email(), terms: z.boolean(), }), +handler: async ({ email, terms }) => { /* ... */ }, }) } ``` See the [`input` API reference](/en/reference/modules/astro-actions/#input-validator) for all available form validators. 3. Add a `<script>` to the HTML form to submit the user input. This example overrides the form‚Äôs default submit behavior to call `actions.newsletter()`, and redirects to `/confirmation` using the `navigate()` function: src/components/Newsletter.astro ```diff <form> </form> <script> +import { actions } from 'astro:actions'; +import { navigate } from 'astro:transitions/client'; +const form = document.querySelector('form'); +form?.addEventListener('submit', async (event) => { +event.preventDefault(); +const formData = new FormData(form); +const { error } = await actions.newsletter(formData); +if (!error) navigate('/confirmation'); + }) </script> ``` See [‚ÄúCall actions from an HTML form action‚Äù](#call-actions-from-an-html-form-action) for an alternative way to submit form data. ### Displaying form input errors [Section titled ‚ÄúDisplaying form input errors‚Äù](#displaying-form-input-errors) You can validate form inputs before submission using [native HTML form validation attributes](https://developer.mozilla.org/en-US/docs/Learn/Forms/Form_validation#using_built-in_form_validation) like `required`, `type="email"`, and `pattern`. For more complex `input` validation on the backend, you can use the provided [`isInputError()`](/en/reference/modules/astro-actions/#isinputerror) utility function. To retrieve input errors, use the `isInputError()` utility to check whether an error was caused by invalid input. Input errors contain a `fields` object with messages for each input name that failed to validate. You can use these messages to prompt your user to correct their submission. The following example checks the error with `isInputError()`, then checks whether the error is in the email field, before finally creating a message from the errors. You can use JavaScript DOM manipulation or your preferred UI framework to display this message to users. ```js import { actions, isInputError } from 'astro:actions'; const form = document.querySelector('form'); const formData = new FormData(form); const { error } = await actions.newsletter(formData); if (isInputError(error)) { // Handle input errors. if (error.fields.email) { const message = error.fields.email.join(', '); } } ``` ## Call actions from an HTML form action [Section titled ‚ÄúCall actions from an HTML form action‚Äù](#call-actions-from-an-html-form-action) You can enable zero-JS form submissions with standard attributes on any `<form>` element. Form submissions without client-side JavaScript may be useful both as a fallback for when JavaScript fails to load, or if you prefer to handle forms entirely from the server. Calling [Astro.getActionResult()](/en/reference/api-reference/#getactionresult) on the server returns the result of your form submission (`data` or `error`), and can be used to dynamically redirect, handle form errors, update the UI, and more. To call an action from an HTML form, add `method="POST"` to your `<form>`, then set the form‚Äôs `action` attribute using your action, for example `action={actions.logout}`. This will set the `action` attribute to use a query string that is handled by the server automatically. For example, this Astro component calls the `logout` action when the button is clicked and reloads the current page: src/components/LogoutButton.astro ```astro --- import { actions } from 'astro:actions'; --- <form method="POST" action={actions.logout}> <button>Log out</button> </form> ``` Additional attributes on the `<form>` element may be necessary for proper schema validation with Zod. For example, to include file uploads, add `enctype="multipart/form-data"` to ensure that files are sent in a format correctly recognized by `z.instanceof(File)`: src/components/FileUploadForm.astro ```astro --- import { actions } from 'astro:actions'; --- <form method="POST" action={actions.upload} enctype="multipart/form-data" > <label for="file">Upload File</label> <input type="file" id="file" name="file" /> <button type="submit">Submit</button> </form> ``` ### Redirect on action success [Section titled ‚ÄúRedirect on action success‚Äù](#redirect-on-action-success) If you need to redirect to a new route on success, you can use an action‚Äôs result on the server. A common example is creating a product record and redirecting to the new product‚Äôs page, e.g. `/products/[id]`. For example, say you have a `createProduct` action that returns the generated product id: src/actions/index.ts ```ts import { defineAction } from 'astro:actions'; import { z } from 'astro/zod'; export const server = { createProduct: defineAction({ accept: 'form', input: z.object({ /* ... */ }), handler: async (input) => { const product = await persistToDatabase(input); return { id: product.id }; }, }) } ``` You can retrieve the action result from your Astro component by calling `Astro.getActionResult()`. This returns an object containing `data` or `error` properties when an action is called, or `undefined` if the action was not called during this request. Use the `data` property to construct a URL to use with `Astro.redirect()`: src/pages/products/create.astro ```astro --- import { actions } from 'astro:actions'; const result = Astro.getActionResult(actions.createProduct); if (result && !result.error) { return Astro.redirect(`/products/${result.data.id}`); } --- <form method="POST" action={actions.createProduct}> <!--...--> </form> ``` ### Handle form action errors [Section titled ‚ÄúHandle form action errors‚Äù](#handle-form-action-errors) Calling `Astro.getActionResult()` in the Astro component containing your form gives you access to the `data` and `error` objects for custom error handling. The following example displays a general failure message when a `newsletter` action fails: src/pages/index.astro ```astro --- import { actions } from 'astro:actions'; const result = Astro.getActionResult(actions.newsletter); --- {result?.error && ( <p class="error">Unable to sign up. Please try again later.</p> )} <form method="POST" action={actions.newsletter}> <label> E-mail <input required type="email" name="email" /> </label> <button>Sign up</button> </form> ``` For more customization, you can [use the `isInputError()` utility](#displaying-form-input-errors) to check whether an error is caused by invalid input. The following example renders an error banner under the `email` input field when an invalid email is submitted: src/pages/index.astro ```diff --- import { actions, isInputError } from 'astro:actions'; const result = Astro.getActionResult(actions.newsletter); +const inputErrors = isInputError(result?.error) ? result.error.fields : {}; --- <form method="POST" action={actions.newsletter}> <label> E-mail <input required type="email" name="email" aria-describedby="error" /> </label> +{inputErrors.email && <p id="error">{inputErrors.email.join(',')}</p>} <button>Sign up</button> </form> ``` #### Preserve input values on error [Section titled ‚ÄúPreserve input values on error‚Äù](#preserve-input-values-on-error) Inputs will be cleared whenever a form is submitted. To persist input values, you can [enable view transitions](/en/guides/view-transitions/#enabling-view-transitions-spa-mode) and apply the `transition:persist` directive to each input: ```astro <input transition:persist required type="email" name="email" /> ``` ### Update the UI with a form action result [Section titled ‚ÄúUpdate the UI with a form action result‚Äù](#update-the-ui-with-a-form-action-result) To use an action‚Äôs return value to display a notification to the user on success, pass the action to `Astro.getActionResult()`. Use the returned `data` property to render the UI you want to display. This example uses the `productName` property returned by an `addToCart` action to show a success message. src/pages/products/\[slug].astro ```astro --- import { actions } from 'astro:actions'; const result = Astro.getActionResult(actions.addToCart); --- {result && !result.error && ( <p class="success">Added {result.data.productName} to cart</p> )} <!--...--> ``` ### Advanced: Persist action results with a session [Section titled ‚ÄúAdvanced: Persist action results with a session‚Äù](#advanced-persist-action-results-with-a-session) **Added in:** `astro@5.0.0` Action results are displayed as a POST submission. This means that the result will be reset to `undefined` when a user closes and revisits the page. The user will also see a ‚Äúconfirm form resubmission?‚Äù dialog if they attempt to refresh the page. To customize this behavior, you can add middleware to handle the result of the action manually. You may choose to persist the action result using a cookie or session storage. Start by [creating a middleware file](/en/guides/middleware/) and importing [the `getActionContext()` utility](/en/reference/modules/astro-actions/#getactioncontext) from `astro:actions`. This function returns an `action` object with information about the incoming action request, including the action handler and whether the action was called from an HTML form. `getActionContext()` also returns the `setActionResult()` and `serializeActionResult()` functions to programmatically set the value returned by `Astro.getActionResult()`: src/middleware.ts ```ts import { defineMiddleware } from 'astro:middleware'; import { getActionContext } from 'astro:actions'; export const onRequest = defineMiddleware(async (context, next) => { const { action, setActionResult, serializeActionResult } = getActionContext(context); if (action?.calledFrom === 'form') { const result = await action.handler(); // ... handle the action result setActionResult(action.name, serializeActionResult(result)); } return next(); }); ``` A common practice to persist HTML form results is the [POST / Redirect / GET pattern](https://en.wikipedia.org/wiki/Post/Redirect/Get). This redirect removes the ‚Äúconfirm form resubmission?‚Äù dialog when the page is refreshed, and allows action results to be persisted throughout the user‚Äôs session. This example applies the POST / Redirect / GET pattern to all form submissions using session storage with the [Netlify server adapter](/en/guides/integrations-guide/netlify/) installed. Action results are written to a session store using [Netlify Blob](https://docs.netlify.com/blobs/overview/), and retrieved after a redirect using a session ID: src/middleware.ts ```ts import { defineMiddleware } from 'astro:middleware'; import { getActionContext } from 'astro:actions'; import { randomUUID } from "node:crypto"; import { getStore } from "@netlify/blobs"; export const onRequest = defineMiddleware(async (context, next) => { // Skip requests for prerendered pages if (context.isPrerendered) return next(); const { action, setActionResult, serializeActionResult } = getActionContext(context); // Create a Blob store to persist action results with Netlify Blob const actionStore = getStore("action-session"); // If an action result was forwarded as a cookie, set the result // to be accessible from `Astro.getActionResult()` const sessionId = context.cookies.get("action-session-id")?.value; const session = sessionId ? await actionStore.get(sessionId, { type: "json", }) : undefined; if (session) { setActionResult(session.actionName, session.actionResult); // Optional: delete the session after the page is rendered. // Feel free to implement your own persistence strategy await actionStore.delete(sessionId); context.cookies.delete("action-session-id"); return next(); } // If an action was called from an HTML form action, // call the action handler and redirect to the destination page if (action?.calledFrom === "form") { const actionResult = await action.handler(); // Persist the action result using session storage const sessionId = randomUUID(); await actionStore.setJSON(sessionId, { actionName: action.name, actionResult: serializeActionResult(actionResult), }); // Pass the session ID as a cookie // to be retrieved after redirecting to the page context.cookies.set("action-session-id", sessionId); // Redirect back to the previous page on error if (actionResult.error) { const referer = context.request.headers.get("Referer"); if (!referer) { throw new Error( "Internal: Referer unexpectedly missing from Action POST request.", ); } return context.redirect(referer); } // Redirect to the destination page on success return context.redirect(context.originPathname); } return next(); }); ``` ## Security when using actions [Section titled ‚ÄúSecurity when using actions‚Äù](#security-when-using-actions) Actions are accessible as public endpoints based on the name of the action. For example, the action `blog.like()` will be accessible from `/_actions/blog.like`. This is useful for unit testing action results and debugging production errors. However, this means you **must** use same authorization checks that you would consider for API endpoints and on-demand rendered pages. ### Authorize users from an action handler [Section titled ‚ÄúAuthorize users from an action handler‚Äù](#authorize-users-from-an-action-handler) To authorize action requests, add an authentication check to your action handler. You may want to use [an authentication library](/en/guides/authentication/) to handle session management and user information. Actions expose [a subset of the `APIContext` object](/en/reference/modules/astro-actions/#actionapicontext) to access properties passed from middleware using `context.locals`. When a user is not authorized, you can raise an `ActionError` with the `UNAUTHORIZED` code: src/actions/index.ts ```ts import { defineAction, ActionError } from 'astro:actions'; export const server = { getUserSettings: defineAction({ handler: async (_input, context) => { if (!context.locals.user) { throw new ActionError({ code: 'UNAUTHORIZED' }); } return { /* data on success */ }; } }) } ``` ### Gate actions from middleware [Section titled ‚ÄúGate actions from middleware‚Äù](#gate-actions-from-middleware) **Added in:** `astro@5.0.0` Astro recommends authorizing user sessions from your action handler to respect permission levels and rate-limiting on a per-action basis. However, you can also gate requests to all actions (or a subset of actions) from middleware. Use the [`getActionContext()` function](/en/reference/modules/astro-actions/#getactioncontext) from your middleware to retrieve information about any inbound action requests. This includes the action name and whether that action was called using a client-side remote procedure call (RPC) function (e.g. `actions.blog.like()`) or an HTML form. The following example rejects all action requests that do not have a valid session token. If the check fails, a ‚ÄúForbidden‚Äù response is returned. Note: this method ensures that actions are only accessible when a session is present, but is *not* a substitute for secure authorization. src/middleware.ts ```ts import { defineMiddleware } from 'astro:middleware'; import { getActionContext } from 'astro:actions'; export const onRequest = defineMiddleware(async (context, next) => { const { action } = getActionContext(context); // Check if the action was called from a client-side function if (action?.calledFrom === 'rpc') { // If so, check for a user session token if (!context.cookies.has('user-session')) { return new Response('Forbidden', { status: 403 }); } } context.cookies.set('user-session', /* session token */); return next(); }); ``` ## Call actions from Astro components and server endpoints [Section titled ‚ÄúCall actions from Astro components and server endpoints‚Äù](#call-actions-from-astro-components-and-server-endpoints) You can call actions directly from Astro component scripts using the `Astro.callAction()` wrapper (or `context.callAction()` when using a [server endpoint](/en/guides/endpoints/#server-endpoints-api-routes)). This is common to reuse logic from your actions in other server code. Pass the action as the first argument and any input parameters as the second argument. This returns the same `data` and `error` objects you receive when calling actions on the client: src/pages/products.astro ```astro --- import { actions } from 'astro:actions'; const searchQuery = Astro.url.searchParams.get('search'); if (searchQuery) { const { data, error } = await Astro.callAction(actions.findProduct, { query: searchQuery }); // handle result } --- ```

# Astro DB

> Learn how to use Astro DB, a fully-managed SQL database designed exclusively for Astro.

Astro DB is a fully-managed SQL database designed for the Astro ecosystem. Develop locally in Astro and deploy to any libSQL-compatible database. Astro DB is a complete solution to configuring, developing, and querying your data. A local database is created in `.astro/content.db` whenever you run `astro dev` to manage your data without the need for Docker or a network connection. ## Installation [Section titled ‚ÄúInstallation‚Äù](#installation) Install the [`@astrojs/db` integration](/en/guides/integrations-guide/db/) using the built-in `astro add` command: * npm ```sh npx astro add db ``` * pnpm ```sh pnpm astro add db ``` * Yarn ```sh yarn astro add db ``` ## Define your database [Section titled ‚ÄúDefine your database‚Äù](#define-your-database) Installing `@astrojs/db` with the `astro add` command will automatically create a `db/config.ts` file in your project where you will define your database tables: db/config.ts ```ts import { defineDb } from 'astro:db'; export default defineDb({ tables: { }, }) ``` ### Tables [Section titled ‚ÄúTables‚Äù](#tables) Data in Astro DB is stored using SQL tables. Tables structure your data into rows and columns, where columns enforce the type of each row value. Define your tables in your `db/config.ts` file by providing the structure of the data in your existing libSQL database, or the data you will collect in a new database. This will allow Astro to generate a TypeScript interface to query that table from your project. The result is full TypeScript support when you access your data with property autocompletion and type-checking. To configure a database table, import and use the `defineTable()` and `column` utilities from `astro:db`. Then, define a name (case-sensitive) for your table and the type of data in each column. This example configures a `Comment` table with required text columns for `author` and `body`. Then, makes it available to your project through the `defineDb()` export. db/config.ts ```ts import { defineDb, defineTable, column } from 'astro:db'; const Comment = defineTable({ columns: { author: column.text(), body: column.text(), } }) export default defineDb({ tables: { Comment }, }) ``` See the [table configuration reference](/en/guides/integrations-guide/db/#table-configuration-reference) for a complete reference of table options. ### Columns [Section titled ‚ÄúColumns‚Äù](#columns) Astro DB supports the following column types: db/config.ts ```ts import { defineTable, column } from 'astro:db'; const Comment = defineTable({ columns: { // A string of text. author: column.text(), // A whole integer value. likes: column.number(), // A true or false value. flagged: column.boolean(), // Date/time values queried as JavaScript Date objects. published: column.date(), // An untyped JSON object. metadata: column.json(), } }); ``` See the [table columns reference](/en/guides/integrations-guide/db/#table-configuration-reference) for more details. ### Table References [Section titled ‚ÄúTable References‚Äù](#table-references) Relationships between tables are a common pattern in database design. For example, a `Blog` table may be closely related to other tables of `Comment`, `Author`, and `Category`. You can define these relations between tables and save them into your database schema using **reference columns**. To establish a relationship, you will need: * An **identifier column** on the referenced table. This is usually an `id` column with the `primaryKey` property. * A column on the base table to **store the referenced `id`**. This uses the `references` property to establish a relationship. This example shows a `Comment` table‚Äôs `authorId` column referencing an `Author` table‚Äôs `id` column. db/config.ts ```ts const Author = defineTable({ columns: { id: column.number({ primaryKey: true }), name: column.text(), } }); const Comment = defineTable({ columns: { authorId: column.number({ references: () => Author.columns.id }), body: column.text(), } }); ``` ## Seed your database for development [Section titled ‚ÄúSeed your database for development‚Äù](#seed-your-database-for-development) In development, Astro will use your DB config to generate local types according to your schemas. These will be generated fresh from your seed file each time the dev server is started, and will allow you to query and work with the shape of your data with type safety and autocompletion. You will not have access to production data during development unless you [connect to a remote database](#connecting-to-remote-databases) during development. This protects your data while allowing you to test and develop with a working database with type-safety. To seed development data for testing and debugging into your Astro project, create a `db/seed.ts` file. Import both the `db` object and your tables defined in `astro:db`. `insert` some initial data into each table. This development data should match the form of both your database schema and production data. The following example defines two rows of development data for a `Comment` table, and an `Author` table: db/seed.ts ```ts import { db, Comment, Author } from 'astro:db'; export default async function() { await db.insert(Author).values([ { id: 1, name: "Kasim" }, { id: 2, name: "Mina" }, ]); await db.insert(Comment).values([ { authorId: 1, body: 'Hope you like Astro DB!' }, { authorId: 2, body: 'Enjoy!'}, ]) } ``` Your development server will automatically restart your database whenever this file changes, regenerating your types and seeding this development data from `seed.ts` fresh each time. ## Connect a libSQL database for production [Section titled ‚ÄúConnect a libSQL database for production‚Äù](#connect-a-libsql-database-for-production) Astro DB can connect to any local libSQL database or to any server that exposes the libSQL remote protocol, whether managed or self-hosted. To connect Astro DB to a libSQL database, set the following environment variables obtained from your database provider: * `ASTRO_DB_REMOTE_URL`: the connection URL to the location of your local or remote libSQL DB. This may include [URL configuration options](#remote-url-configuration-options) such as sync and encryption as parameters. * `ASTRO_DB_APP_TOKEN`: the auth token to your libSQL server. This is required for remote databases, and not needed for [local DBs like files or in-memory](#url-scheme-and-host) databases Depending on your service, you may have access to a CLI or web UI to retrieve these values. The following section will demonstrate connecting to Turso and setting these values as an example, but you are free to use any provider. ### Getting started with Turso [Section titled ‚ÄúGetting started with Turso‚Äù](#getting-started-with-turso) Turso is the company behind [libSQL](https://github.com/tursodatabase/libsql), the open-source fork of SQLite that powers Astro DB. They provide a fully managed libSQL database platform and are fully compatible with Astro. The steps below will guide you through the process of installing the Turso CLI, logging in (or signing up), creating a new database, getting the required environmental variables, and pushing the schema to the remote database. 1. Install the [Turso CLI](https://docs.turso.tech/cli/installation). 2. [Log in or sign up](https://docs.turso.tech/cli/authentication) to Turso. 3. Create a new database. In this example the database name is `andromeda`. ```sh turso db create andromeda ``` 4. Run the `show` command to see information about the newly created database: ```sh turso db show andromeda ``` Copy the `URL` value and set it as the value for `ASTRO_DB_REMOTE_URL`. .env ```dotenv ASTRO_DB_REMOTE_URL=libsql://andromeda-houston.turso.io ``` 5. Create a new token to authenticate requests to the database: ```sh turso db tokens create andromeda ``` Copy the output of the command and set it as the value for `ASTRO_DB_APP_TOKEN`. .env ```diff ASTRO_DB_REMOTE_URL=libsql://andromeda-houston.turso.io +ASTRO_DB_APP_TOKEN=eyJhbGciOiJF...3ahJpTkKDw ``` 6. Push your DB schema and metadata to the new Turso database. ```sh astro db push --remote ``` 7. Congratulations, now you have a database connected! Give yourself a break. üëæ ```sh turso relax ``` To explore more features of Turso, check out the [Turso docs](https://docs.turso.tech). ### Connecting to remote databases [Section titled ‚ÄúConnecting to remote databases‚Äù](#connecting-to-remote-databases) Astro DB allows you to connect to both local and remote databases. By default, Astro uses a local database file for `dev` and `build` commands, recreating tables and inserting development seed data each time. To connect to a hosted remote database, use the `--remote` flag. This flag enables both readable and writable access to your remote database, allowing you to [accept and persist user data](#insert) in production environments. Configure your build command to use the `--remote` flag: package.json ```json { "scripts": { "build": "astro build --remote" } } ``` You can also use the flag directly in the command line: ```bash # Build with a remote connection astro build --remote # Develop with a remote connection astro dev --remote ``` Caution Be careful when using `--remote` in development. This connects to your live production database, and all changes (inserts, updates, deletions) will be persisted. The `--remote` flag uses the connection to the remote DB both locally during the build and on the server. Ensure you set the necessary environment variables in both your local development environment and your deployment platform. Additionally, you may need to [configure web mode](/en/guides/integrations-guide/db/#mode) for non-Node.js runtimes such as Cloudflare Workers or Deno. When deploying your Astro DB project, make sure your deployment platform‚Äôs build command is set to `npm run build` (or the equivalent for your package manager) to utilize the `--remote` flag configured in your `package.json`. ### Remote URL configuration options [Section titled ‚ÄúRemote URL configuration options‚Äù](#remote-url-configuration-options) The `ASTRO_DB_REMOTE_URL` environment variable configures the location of your database as well as other options like sync and encryption. #### URL scheme and host [Section titled ‚ÄúURL scheme and host‚Äù](#url-scheme-and-host) libSQL supports both HTTP and WebSockets as the transport protocol for a remote server. It also supports using a local file or an in-memory DB. Those can be configured using the following URL schemes in the connection URL: * `memory:` will use an in-memory DB. The host must be empty in this case. * `file:` will use a local file. The host is the path to the file (`file:path/to/file.db`). * `libsql:` will use a remote server through the protocol preferred by the library (this might be different across versions). The host is the address of the server (`libsql://your.server.io`). * `http:` will use a remote server through HTTP. `https:` can be used to enable a secure connection. The host is the same as for `libsql:`. * `ws:` will use a remote server through WebSockets. `wss:` can be used to enable a secure connection. The host is the same as for `libsql:`. Details of the libSQL connection (e.g. encryption key, replication, sync interval) can be configured as query parameters in the remote connection URL. For example, to have an encrypted local file work as an embedded replica to a libSQL server, you can set the following environment variables: .env ```dotenv ASTRO_DB_REMOTE_URL=file://local-copy.db?encryptionKey=your-encryption-key&syncInterval=60&syncUrl=libsql%3A%2F%2Fyour.server.io ASTRO_DB_APP_TOKEN=token-to-your-remote-url ``` Caution Using a database file is an advanced feature, and care should be taken when deploying to prevent overriding your database and losing your production data. Additionally, this method will not work in serverless deployments, as the file system is not persisted in those environments. #### `encryptionKey` [Section titled ‚ÄúencryptionKey‚Äù](#encryptionkey) libSQL has native support for encrypted databases. Passing this search parameter will enable encryption using the given key: .env ```dotenv ASTRO_DB_REMOTE_URL=file:path/to/file.db?encryptionKey=your-encryption-key ``` #### `syncUrl` [Section titled ‚ÄúsyncUrl‚Äù](#syncurl) Embedded replicas are a feature of libSQL clients that creates a full synchronized copy of your database on a local file or in memory for ultra-fast reads. Writes are sent to a remote database defined on the `syncUrl` and synchronized with the local copy. Use this property to pass a separate connection URL to turn the database into an embedded replica of another database. This should only be used with the schemes `file:` and `memory:`. The parameter must be URL encoded. For example, to have an in-memory embedded replica of a database on `libsql://your.server.io`, you can set the connection URL as such: .env ```dotenv ASTRO_DB_REMOTE_URL=memory:?syncUrl=libsql%3A%2F%2Fyour.server.io ``` #### `syncInterval` [Section titled ‚ÄúsyncInterval‚Äù](#syncinterval) Interval between embedded replica synchronizations in seconds. By default it only synchronizes on startup and after writes. This property is only used when `syncUrl` is also set. For example, to set an in-memory embedded replica to synchronize every minute set the following environment variable: .env ```dotenv ASTRO_DB_REMOTE_URL=memory:?syncUrl=libsql%3A%2F%2Fyour.server.io&syncInterval=60 ``` ## Query your database [Section titled ‚ÄúQuery your database‚Äù](#query-your-database) You can query your database from any [Astro page](/en/basics/astro-pages/#astro-pages), [endpoint](/en/guides/endpoints/), or [action](/en/guides/actions/) in your project using the provided `db` ORM and query builder. ### Drizzle ORM [Section titled ‚ÄúDrizzle ORM‚Äù](#drizzle-orm) ```ts import { db } from 'astro:db'; ``` Astro DB includes a built-in [Drizzle ORM](https://orm.drizzle.team/) client. There is no setup or manual configuration required to use the client. The Astro DB `db` client is automatically configured to communicate with your database (local or remote) when you run Astro. It uses your exact database schema definition for type-safe SQL queries with TypeScript errors when you reference a column or table that doesn‚Äôt exist. ### Select [Section titled ‚ÄúSelect‚Äù](#select) The following example selects all rows of a `Comment` table. This returns the complete array of seeded development data from `db/seed.ts` which is then available for use in your page template: src/pages/index.astro ```astro --- import { db, Comment } from 'astro:db'; const comments = await db.select().from(Comment); --- <h2>Comments</h2> { comments.map(({ author, body }) => ( <article> <p>Author: {author}</p> <p>{body}</p> </article> )) } ``` See the [Drizzle `select()` API reference](https://orm.drizzle.team/docs/select) for a complete overview. ### Insert [Section titled ‚ÄúInsert‚Äù](#insert) To accept user input, such as handling form requests and inserting data into your remote hosted database, configure your Astro project for [on-demand rendering](/en/guides/on-demand-rendering/) and [add an adapter](/en/guides/on-demand-rendering/#add-an-adapter) for your deployment environment. This example inserts a row into a `Comment` table based on a parsed form POST request: src/pages/index.astro ```astro --- import { db, Comment } from 'astro:db'; if (Astro.request.method === 'POST') { // Parse form data const formData = await Astro.request.formData(); const author = formData.get('author'); const body = formData.get('body'); if (typeof author === 'string' && typeof body === 'string') { // Insert form data into the Comment table await db.insert(Comment).values({ author, body }); } } // Render the new list of comments on each request const comments = await db.select().from(Comment); --- <form method="POST" style="display: grid"> <label for="author">Author</label> <input id="author" name="author" /> <label for="body">Body</label> <textarea id="body" name="body"></textarea> <button type="submit">Submit</button> </form> <!-- Render `comments` --> ``` You can also use [Astro actions](/en/guides/actions/) to insert data into an Astro DB table. The following example inserts a row into a `Comment` table using an action: src/actions/index.ts ```ts import { db, Comment } from 'astro:db'; import { defineAction } from 'astro:actions'; import { z } from 'astro/zod'; export const server = { addComment: defineAction({ // Actions include type safety with Zod, removing the need // to check if typeof {value} === 'string' in your pages input: z.object({ author: z.string(), body: z.string(), }), handler: async (input) => { const updatedComments = await db .insert(Comment) .values(input) .returning(); // Return the updated comments return updatedComments; }, }), }; ``` See the [Drizzle `insert()` API reference](https://orm.drizzle.team/docs/insert) for a complete overview. ### Delete [Section titled ‚ÄúDelete‚Äù](#delete) You can also query your database from an API endpoint. This example deletes a row from a `Comment` table by the `id` parameter: src/pages/api/comments/\[id].ts ```ts import type { APIRoute } from "astro"; import { db, Comment, eq } from 'astro:db'; export const DELETE: APIRoute = async (ctx) => { await db.delete(Comment).where(eq(Comment.id, ctx.params.id )); return new Response(null, { status: 204 }); } ``` See the [Drizzle `delete()` API reference](https://orm.drizzle.team/docs/delete) for a complete overview. ### Filtering [Section titled ‚ÄúFiltering‚Äù](#filtering) To query for table results by a specific property, use [Drizzle options for partial selects](https://orm.drizzle.team/docs/select#partial-select). For example, add [a `.where()` call](https://orm.drizzle.team/docs/select#filtering) to your `select()` query and pass the comparison you want to make. The following example queries for all rows in a `Comment` table that contain the phrase ‚ÄúAstro DB.‚Äù Use [the `like()` operator](https://orm.drizzle.team/docs/operators#like) to check if a phrase is present within the `body`: src/pages/index.astro ```astro --- import { db, Comment, like } from 'astro:db'; const comments = await db.select().from(Comment).where( like(Comment.body, '%Astro DB%') ); --- ``` ### Drizzle utilities [Section titled ‚ÄúDrizzle utilities‚Äù](#drizzle-utilities) All Drizzle utilities for building queries are exposed from the `astro:db` module. This includes: * [Filter operators](https://orm.drizzle.team/docs/operators) like `eq()` and `gt()` * [Aggregation helpers](https://orm.drizzle.team/docs/select#aggregations-helpers) like `count()` * [The `sql` helper](https://orm.drizzle.team/docs/sql) for writing raw SQL queries ```ts import { eq, gt, count, sql } from 'astro:db'; ``` ### Relationships [Section titled ‚ÄúRelationships‚Äù](#relationships) You can query related data from multiple tables using a SQL join. To create a join query, extend your `db.select()` statement with a join operator. Each function accepts a table to join with and a condition to match rows between the two tables. This example uses an `innerJoin()` function to join `Comment` authors with their related `Author` information based on the `authorId` column. This returns an array of objects with each `Author` and `Comment` row as top-level properties: src/pages/index.astro ```astro --- import { db, eq, Comment, Author } from 'astro:db'; const comments = await db.select() .from(Comment) .innerJoin(Author, eq(Comment.authorId, Author.id)); --- <h2>Comments</h2> { comments.map(({ Author, Comment }) => ( <article> <p>Author: {Author.name}</p> <p>{Comment.body}</p> </article> )) } ``` See the [Drizzle join reference](https://orm.drizzle.team/docs/joins#join-types) for all available join operators and config options. ### Batch Transactions [Section titled ‚ÄúBatch Transactions‚Äù](#batch-transactions) All remote database queries are made as a network request. You may need to ‚Äúbatch‚Äù queries together into a single transaction when making a large number of queries, or to have automatic rollbacks if any query fails. This example seeds multiple rows in a single request using the `db.batch()` method: db/seed.ts ```ts import { db, Author, Comment } from 'astro:db'; export default async function () { const queries = []; // Seed 100 sample comments into your remote database // with a single network request. for (let i = 0; i < 100; i++) { queries.push(db.insert(Comment).values({ body: `Test comment ${i}` })); } await db.batch(queries); } ``` See the [Drizzle `db.batch()`](https://orm.drizzle.team/docs/batch-api) docs for more details. ## Pushing changes to your database [Section titled ‚ÄúPushing changes to your database‚Äù](#pushing-changes-to-your-database) You can push changes made during development to your database. ### Pushing table schemas [Section titled ‚ÄúPushing table schemas‚Äù](#pushing-table-schemas) Your table schema may change over time as your project grows. You can safely test configuration changes locally and push to your remote database when you deploy. You can push your local schema changes to your remote database via the CLI using the `astro db push --remote` command: * npm ```sh npm run astro db push --remote ``` * pnpm ```sh pnpm astro db push --remote ``` * Yarn ```sh yarn astro db push --remote ``` This command will verify that your local changes can be made without data loss and, if necessary, suggest how to safely make changes to your schema in order to resolve conflicts. #### Pushing breaking schema changes [Section titled ‚ÄúPushing breaking schema changes‚Äù](#pushing-breaking-schema-changes) Danger **This will destroy your database**. Only perform this command if you do not need your production data. If you must change your table schema in a way that is incompatible with your existing data hosted on your remote database, you will need to reset your production database. To push a table schema update that includes a breaking change, add the `--force-reset` flag to reset all production data: * npm ```sh npm run astro db push --remote --force-reset ``` * pnpm ```sh pnpm astro db push --remote --force-reset ``` * Yarn ```sh yarn astro db push --remote --force-reset ``` ### Renaming tables [Section titled ‚ÄúRenaming tables‚Äù](#renaming-tables) It is possible to rename a table after pushing your schema to your remote database. If you **do not have any important production data**, then you can [reset your database](#pushing-breaking-schema-changes) using the `--force-reset` flag. This flag will drop all of the tables in the database and create new ones so that it matches your current schema exactly. To rename a table while preserving your production data, you must perform a series of non-breaking changes to push your local schema to your remote database safely. The following example renames a table from `Comment` to `Feedback`: 1. In your database config file, add the `deprecated: true` property to the table you want to rename: db/config.ts ```diff const Comment = defineTable({ deprecated: true, columns: { author: column.text(), body: column.text(), } }); ``` 2. Add a new table schema (matching the existing table‚Äôs properties exactly) with the new name: db/config.ts ```diff const Comment = defineTable({ deprecated: true, columns: { author: column.text(), body: column.text(), } }); +const Feedback = defineTable({ columns: { author: column.text(), body: column.text(), } +}); ``` 3. [Push to your remote database](#pushing-table-schemas) with `astro db push --remote`. This will add the new table and mark the old as deprecated. 4. Update any of your local project code to use the new table instead of the old table. You might need to migrate data to the new table as well. 5. Once you are confident that the old table is no longer used in your project, you can remove the schema from your `config.ts`: db/config.ts ```diff -const Comment = defineTable({ deprecated: true, columns: { author: column.text(), body: column.text(), } -}); const Feedback = defineTable({ columns: { author: column.text(), body: column.text(), } }); ``` 6. Push to your remote database again with `astro db push --remote`. The old table will be dropped, leaving only the new, renamed table. ### Pushing table data [Section titled ‚ÄúPushing table data‚Äù](#pushing-table-data) You may need to push data to your remote database for seeding or data migrations. You can author a `.ts` file with the `astro:db` module to write type-safe queries. Then, execute the file against your remote database using the command `astro db execute <file-path> --remote`: The following Comments can be seeded using the command `astro db execute db/seed.ts --remote`: db/seed.ts ```ts import { Comment } from 'astro:db'; export default async function () { await db.insert(Comment).values([ { authorId: 1, body: 'Hope you like Astro DB!' }, { authorId: 2, body: 'Enjoy!' }, ]) } ``` See the [CLI reference](/en/guides/integrations-guide/db/#astro-db-cli-reference) for a complete list of commands. ## Building Astro DB integrations [Section titled ‚ÄúBuilding Astro DB integrations‚Äù](#building-astro-db-integrations) [Astro integrations](/en/reference/integrations-reference/) can extend user projects with additional Astro DB tables and seed data. Use the `extendDb()` method in the `astro:db:setup` hook to register additional Astro DB config and seed files. The `defineDbIntegration()` helper provides TypeScript support and auto-complete for the `astro:db:setup` hook. my-integration/index.ts ```js import { defineDbIntegration } from '@astrojs/db/utils'; export default function MyIntegration() { return defineDbIntegration({ name: 'my-astro-db-powered-integration', hooks: { 'astro:db:setup': ({ extendDb }) => { extendDb({ configEntrypoint: '@astronaut/my-package/config', seedEntrypoint: '@astronaut/my-package/seed', }); }, // Other integration hooks... }, }); } ``` Integration [config](#define-your-database) and [seed](#seed-your-database-for-development) files follow the same format as their user-defined equivalents. ### Type safe operations in integrations [Section titled ‚ÄúType safe operations in integrations‚Äù](#type-safe-operations-in-integrations) While working on integrations, you may not be able to benefit from Astro‚Äôs generated table types exported from `astro:db`. For full type safety, use the `asDrizzleTable()` utility to create a table reference object you can use for database operations. For example, given an integration setting up the following `Pets` database table: my-integration/config.ts ```js import { defineDb, defineTable, column } from 'astro:db'; export const Pets = defineTable({ columns: { name: column.text(), species: column.text(), }, }); export default defineDb({ tables: { Pets } }); ``` The seed file can import `Pets` and use `asDrizzleTable()` to insert rows into your table with type checking: my-integration/seed.ts ```js import { asDrizzleTable } from '@astrojs/db/utils'; import { db } from 'astro:db'; import { Pets } from './config'; export default async function() { const typeSafePets = asDrizzleTable('Pets', Pets); await db.insert(typeSafePets).values([ { name: 'Palomita', species: 'cat' }, { name: 'Pan', species: 'dog' }, ]); } ``` The value returned by `asDrizzleTable('Pets', Pets)` is equivalent to `import { Pets } from 'astro:db'`, but is available even when Astro‚Äôs type generation can‚Äôt run. You can use it in any integration code that needs to query or insert into the database. ## Migrate from Astro Studio to Turso [Section titled ‚ÄúMigrate from Astro Studio to Turso‚Äù](#migrate-from-astro-studio-to-turso) 1. In the [Studio dashboard](https://studio.astro.build/), navigate to the project you wish to migrate. In the settings tab, use the ‚ÄúExport Database‚Äù button to download a dump of your database. 2. Follow the official instructions to [install the Turso CLI](https://docs.turso.tech/cli/installation) and [sign up or log in](https://docs.turso.tech/cli/authentication) to your Turso account. 3. Create a new database on Turso using the `turso db create` command. ```sh turso db create [database-name] ``` 4. Fetch the database URL using the Turso CLI, and use it as the environment variable `ASTRO_DB_REMOTE_URL`. ```sh turso db show [database-name] ``` ```dotenv ASTRO_DB_REMOTE_URL=[your-database-url] ``` 5. Create a token to access your database, and use it as the environment variable `ASTRO_DB_APP_TOKEN`. ```sh turso db tokens create [database-name] ``` ```dotenv ASTRO_DB_APP_TOKEN=[your-app-token] ``` 6. Push your DB schema and metadata to the new Turso database. ```sh astro db push --remote ``` 7. Import the database dump from step 1 into your new Turso DB. ```sh turso db shell [database-name] < ./path/to/dump.sql ``` 8. Once you have confirmed your project connects to the new database, you can safely delete the project from Astro Studio.

# Building Astro sites with AI tools

> Resources and tips for building Astro sites with AI assistance

AI-powered editors and agentic coding tools generally have good knowledge of Astro‚Äôs core APIs and concepts. However, some may use older APIs and may not be aware of newer features or recent changes to the framework. This guide covers how to enhance AI tools with up-to-date Astro knowledge and provides best practices for building Astro sites with AI assistance. ## Context files [Section titled ‚ÄúContext files‚Äù](#context-files) Astro provides [`llms.txt`](https://docs.astro.build/llms.txt) and [`llms-full.txt`](https://docs.astro.build/llms-full.txt) files that contains the full docs content in a format optimized for AI consumption. These are static files of the Astro Docs content in a streamlined Markdown format. Some AI tools can auto-discover these files if you provide `https://docs.astro.build` as a docs source. While these files provide a minimal, easy-to-parse version of Astro‚Äôs documentation, they are large files that will use a lot of tokens if used directly in context and will need to be updated regularly to stay current. They are best used as a fallback when the AI tool does not have access to the latest documentation in other ways. [The MCP server](#astro-docs-mcp-server) provides more efficient access to the full documentation with real-time search capabilities, making it the preferred option when available. ## Astro Docs MCP Server [Section titled ‚ÄúAstro Docs MCP Server‚Äù](#astro-docs-mcp-server) You can ensure your AI tools have current Astro knowledge through the Astro Docs MCP (Model Context Protocol) server. This provides real-time access to the latest documentation, helping AI tools avoid outdated recommendations and ensuring they understand current best practices. Unlike AI models trained on static data, the MCP server provides access to the latest Astro documentation. The server is free, open-source, and runs remotely with nothing to install locally. The Astro Docs MCP server uses the [kapa.ai](https://www.kapa.ai/) API to maintain an up-to-date index of the Astro documentation. ### Server Details [Section titled ‚ÄúServer Details‚Äù](#server-details) * **Name**: Astro Docs * **URL**: `https://mcp.docs.astro.build/mcp` * **Transport**: Streamable HTTP ### Installation [Section titled ‚ÄúInstallation‚Äù](#installation) The setup process varies depending on your AI development tool. You may see some tools refer to MCP servers as connectors, adapters, extensions, or plugins. #### Manual setup [Section titled ‚ÄúManual setup‚Äù](#manual-setup) Many tools support a common JSON configuration format for MCP servers. If there are not specific instructions for your chosen tool, you may be able to add the Astro Docs MCP server by including the following configuration in your tool‚Äôs MCP settings: * Streamable HTTP mcp.json ```json { "mcpServers": { "Astro docs": { "type": "http", "url": "https://mcp.docs.astro.build/mcp" } } } ``` * Local Proxy mcp.json ```json { "mcpServers": { "Astro docs": { "type": "stdio", "command": "npx", "args": ["-y", "mcp-remote", "https://mcp.docs.astro.build/mcp"] } } } ``` #### Claude Code CLI [Section titled ‚ÄúClaude Code CLI‚Äù](#claude-code-cli) [Claude Code](https://docs.anthropic.com/en/docs/claude-code/overview) is an agentic coding tool that runs on the command line. Enabling the Astro Docs MCP server allows it to access the latest documentation while generating Astro code. Install using the terminal command: ```shell claude mcp add --transport http astro-docs https://mcp.docs.astro.build/mcp ``` [More info on using MCP servers with Claude Code](https://docs.anthropic.com/en/docs/claude-code/mcp) #### Claude Code GitHub Action [Section titled ‚ÄúClaude Code GitHub Action‚Äù](#claude-code-github-action) Claude Code also provides a GitHub Action that can be used to run commands in response to GitHub events. Enabling the Astro Docs MCP server allows it to access the latest documentation while answering questions in comments or generating Astro code. You can configure it to use the Astro Docs MCP server for documentation access by adding the following to the workflow file: .github/workflows/claude.yml ```yaml # ...rest of your workflow configuration - uses: anthropics/claude-code-action@beta with: anthropic_api_key: ${{ secrets.ANTHROPIC_API_KEY }} mcp_config: | { "mcpServers": { "astro-docs": { "type": "http", "url": "https://mcp.docs.astro.build/mcp" } } } allowed_tools: "mcp__astro-docs__search_astro_docs" ``` [More info on using MCP servers with the Claude Code GitHub Action](https://github.com/anthropics/claude-code-action?tab=readme-ov-file#using-custom-mcp-configuration) #### Codex CLI [Section titled ‚ÄúCodex CLI‚Äù](#codex-cli) Codex CLI is a command-line AI coding tool that can use the Astro Docs MCP server to access documentation while generating Astro code. You can configure MCP servers at the global level in the `~/.codex/config.toml` file, or in a `.codex/config.toml` file in a project root. \~/.codex/config.toml ```toml [mcp_servers.astro-docs] command = "npx" args = ["-y", "mcp-remote", "https://mcp.docs.astro.build/mcp"] ``` [More info on using MCP servers with Codex CLI](https://developers.openai.com/codex/mcp) #### Cursor [Section titled ‚ÄúCursor‚Äù](#cursor) [Cursor](https://cursor.com) is an AI code editor. Adding the Astro Docs MCP server allows Cursor to access the latest Astro documentation while performing development tasks. Install by clicking the button below: [Add to Cursor](cursor://anysphere.cursor-deeplink/mcp/install?name=Astro%20docs\&config=eyJ1cmwiOiJodHRwczovL21jcC5kb2NzLmFzdHJvLmJ1aWxkL21jcCJ9) [More info on using MCP servers with Cursor](https://docs.cursor.com/context/mcp) #### Visual Studio Code [Section titled ‚ÄúVisual Studio Code‚Äù](#visual-studio-code) [Visual Studio Code](https://code.visualstudio.com) supports MCP servers when using Copilot Chat. Adding the Astro Docs MCP server allows VS Code to access the latest Astro documentation when answering questions or performing coding tasks. Install by clicking the button below: [Add to VS Code](vscode:mcp/install?%7B%22name%22%3A%22Astro%20docs%22%2C%22url%22%3A%22https%3A%2F%2Fmcp.docs.astro.build%2Fmcp%22%7D) [More info on using MCP servers with VS Code](https://code.visualstudio.com/docs/copilot/chat/mcp-servers#_add-an-mcp-server) #### Warp [Section titled ‚ÄúWarp‚Äù](#warp) [Warp](https://warp.dev) (formerly Warp Terminal) is an agent development environment built for coding with multiple AI agents. Adding the Astro Docs MCP server allows Warp to access the latest Astro documentation when answering questions or performing coding tasks. 1. Open your Warp settings and go to AI > MCP Servers > Manage MCP Servers. 2. Click ‚ÄúAdd‚Äù. 3. Enter the following configuration. You can optionally configure the Astro MCP server to activate on startup using the `start_on_launch` flag: MCP Configuration ```json { "mcpServers": { "Astro docs": { "command": "npx", "args": ["-y", "mcp-remote", "https://mcp.docs.astro.build/mcp"], "env": {}, "working_directory": null, "start_on_launch": true } } } ``` 4. Click ‚ÄúSave‚Äù. [More info on using MCP servers with Warp](https://docs.warp.dev/knowledge-and-collaboration/mcp) #### Claude.ai / Claude Desktop [Section titled ‚ÄúClaude.ai / Claude Desktop‚Äù](#claudeai--claude-desktop) [Claude.ai](https://claude.ai) is a general-purpose AI assistant. Adding the Astro Docs MCP server allows it to access the latest documentation when answering Astro questions or generating Astro code. 1. Navigate to the [Claude.ai connector settings](https://claude.ai/settings/connectors). 2. Click ‚ÄúAdd custom connector‚Äù. You may need to scroll down to find this option. 3. Enter the server URL: `https://mcp.docs.astro.build/mcp`. 4. Set the name to ‚ÄúAstro docs‚Äù. [More info on using MCP servers with Claude.ai](https://support.anthropic.com/en/articles/10168395-setting-up-integrations-on-claude-ai#h_cda40ecb32) #### Windsurf [Section titled ‚ÄúWindsurf‚Äù](#windsurf) [Windsurf](https://windsurf.com/) is an AI-powered agentic coding tool, available as editor plugins or a standalone editor. It can use the Astro Docs MCP server to access documentation while performing coding tasks. Windsurf doesn‚Äôt support streaming HTTP, so it requires a local proxy configuration: 1. Open `~/.codeium/windsurf/mcp_config.json` in your editor. 2. Add the following configuration to your Windsurf MCP settings: MCP Configuration ```json { "mcpServers": { "Astro docs": { "command": "npx", "args": ["-y", "mcp-remote", "https://mcp.docs.astro.build/mcp"] } } } ``` 3. Save the configuration and restart Windsurf. [More info on using MCP servers with Windsurf](https://docs.windsurf.com/windsurf/cascade/mcp#mcp-config-json) #### Gemini CLI [Section titled ‚ÄúGemini CLI‚Äù](#gemini-cli) Gemini CLI is a command-line AI coding tool that can use the Astro Docs MCP server to access documentation while generating Astro code. You can configure MCP servers at the global level in the `~/.gemini/settings.json` file, or in a `.gemini/settings.json` file in a project root. .gemini/settings.json ```json { "mcpServers": { "Astro docs": { "httpUrl": "https://mcp.docs.astro.build/mcp", } } } ``` [More info on using MCP servers with Gemini CLI](https://github.com/google-gemini/gemini-cli/blob/main/docs/tools/mcp-server.md) #### Google Antigravity [Section titled ‚ÄúGoogle Antigravity‚Äù](#google-antigravity) [Google Antigravity](https://antigravity.google/) is an agentic development platform. 1. Open `~/.gemini/antigravity/mcp_config.json` by following the [Connecting Custom MCP Servers guide](https://antigravity.google/docs/mcp#connecting-custom-mcp-servers). 2. Add the following configuration to `mcp_config.json`: mcp\_config.json ```json { "mcpServers": { "astro-docs": { "serverUrl": "https://mcp.docs.astro.build/mcp" } } } ``` 3. Save the file and click ‚ÄúRefresh‚Äù in the ‚ÄúManage MCPs‚Äù tab. #### Zed [Section titled ‚ÄúZed‚Äù](#zed) [Zed](https://zed.dev) supports MCP servers when using its AI capabilities. It can use the Astro Docs MCP server to access documentation while performing coding tasks. Zed doesn‚Äôt support streaming HTTP, so it requires a local proxy configuration: 1. Open `~/.config/zed/settings.json` in your editor. 2. Add the following configuration to your Zed MCP settings: MCP Configuration ```json { "context_servers": { "Astro docs": { "command": "npx", "args": ["-y", "mcp-remote", "https://mcp.docs.astro.build/mcp"] } } } ``` 3. Save the configuration. [More info on using MCP servers with Zed](https://zed.dev/docs/ai/mcp) #### ChatGPT [Section titled ‚ÄúChatGPT‚Äù](#chatgpt) Limited availability MCP server integration is only available for ChatGPT Pro, Team, and Enterprise users. The setup process is more complex than other tools. Refer to the [OpenAI MCP documentation](https://platform.openai.com/docs/mcp#test-and-connect-your-mcp-server) for specific setup instructions. #### Raycast [Section titled ‚ÄúRaycast‚Äù](#raycast) [Raycast](https://www.raycast.com/) can connect to MCP servers to enhance its AI capabilities. AI features such as MCP require a [Raycast Pro](https://www.raycast.com/pro) account, so ensure you have upgraded before trying to install. Adding the Astro Docs MCP server allows Raycast to access the latest Astro documentation while answering questions. Install by clicking the button below: [Add to Raycast](raycast://mcp/install?%7B%22name%22%3A%22Astro%20docs%22%2C%22type%22%3A%22stdio%22%2C%22command%22%3A%22npx%22%2C%22args%22%3A%5B%22-y%22%2C%20%22mcp-remote%22%2C%20%22https%3A%2F%2Fmcp.docs.astro.build%2Fmcp%22%5D%7D) [More info on using MCP servers with Raycast](https://manual.raycast.com/model-context-protocol) #### Opencode AI [Section titled ‚ÄúOpencode AI‚Äù](#opencode-ai) [Opencode AI](https://opencode.ai/) is an open-source, terminal-based AI coding tool that can use the Astro Docs MCP server to access documentation while generating Astro code. You can configure MCP servers in your Opencode configuration file, typically named `opencode.json`, located in your project root or your global configuration directory (e.g. `~/.config/opencode/opencode.json`). MCP Configuration ```json { "$schema": "https://opencode.ai/config.json", "mcp": { "Astro docs": { "type": "remote", "url": "https://mcp.docs.astro.build/mcp", "enabled": true } } } ``` [More info on using Opencode AI](https://opencode.ai/) #### GitHub Copilot Coding Agent [Section titled ‚ÄúGitHub Copilot Coding Agent‚Äù](#github-copilot-coding-agent) [GitHub Copilot](https://docs.github.com/en/copilot/concepts/agents/coding-agent/about-coding-agent) can be used as a coding agent powered by GitHub Actions. Enabling the Astro Docs MCP server allows it to access the latest Astro documentation when answering questions or performing coding tasks. You can configure it to use the Astro Docs MCP server for documentation access by adding the following to your repository‚Äôs Copilot coding agent settings available at `https://github.com/<your-org>/<your-repo>/settings/copilot/coding_agent`: MCP Configuration ```json { "mcpServers": { "astro-docs": { "type": "http", "url": "https://mcp.docs.astro.build/mcp", "tools": ["mcp__astro-docs__search_astro_docs"] } } } ``` Learn more about [extending GitHub Copilot coding agent with MCP servers](https://docs.github.com/en/copilot/how-tos/use-copilot-agents/coding-agent/extend-coding-agent-with-mcp). ### Usage [Section titled ‚ÄúUsage‚Äù](#usage) Once configured, you can ask your AI tool questions about Astro, and it will retrieve information directly from the latest docs. Coding agents will be able to consult the latest documentation when performing coding tasks, and chatbots will be able to accurately answer questions about Astro features, APIs, and best practices. ### Troubleshooting [Section titled ‚ÄúTroubleshooting‚Äù](#troubleshooting) If you encounter issues: * Verify that your tool supports streamable HTTP transport. * Check that the server URL is correct: `https://mcp.docs.astro.build/mcp`. * Ensure your tool has proper internet access. * Consult your specific tool‚Äôs MCP integration documentation. If you are still having problems, open an issue in the [Astro Docs MCP Server repository](https://github.com/withastro/docs-mcp/issues). ## Discord AI Support [Section titled ‚ÄúDiscord AI Support‚Äù](#discord-ai-support) The same technology that powers Astro‚Äôs MCP server is also available as a chatbot in the [Astro Discord](https://astro.build/chat) for self-serve support. Visit the `#support-ai` channel to ask questions about Astro or your project code in natural language. Your conversation is automatically threaded, and you can ask an unlimited number of follow-up questions. **Conversations with the chatbot are public, and are subject to the same server rules for language and behavior as the rest of our channels**, but they are not actively visited by our volunteer support members. For assistance from the community, please create a thread in our regular `#support` channel. ## Tips for AI-Powered Astro Development [Section titled ‚ÄúTips for AI-Powered Astro Development‚Äù](#tips-for-ai-powered-astro-development) * **Start with templates**: Rather than building from scratch, ask AI tools to start with an existing [Astro template](https://astro.build/themes/) or use `npm create astro@latest` with a template option. * **Use `astro add` for integrations**: Ask AI tools to use `astro add` for official integrations (e.g. `astro add tailwind`, `astro add react`). For other packages, install using the command for your preferred package manager rather than editing `package.json` directly. * **Verify current APIs**: AI tools may use outdated patterns. Ask them to check the latest documentation, especially for newer features like sessions and actions. This is also important for features that have seen significant changes since their initial launch, such as content collections, or previously experimental features that may no longer be experimental. * **Use project rules**: If your AI tool supports it, set up project rules to enforce best practices and coding standards, such as the ones listed above.

# Scripts and event handling

> How to add client-side interactivity to Astro components using native browser JavaScript APIs.

You can send JavaScript to the browser and add functionality to your Astro components using `<script>` tags in the component template. Scripts add interactivity to your site, such as handling events or updating content dynamically, without the need for a [UI framework](/en/guides/framework-components/) like React, Svelte, or Vue. This avoids the overhead of shipping framework JavaScript and doesn‚Äôt require you to know any additional framework to create a full-featured website or application. ## Client-Side Scripts [Section titled ‚ÄúClient-Side Scripts‚Äù](#client-side-scripts) Scripts can be used to add event listeners, send analytics data, play animations, and everything else JavaScript can do on the web. Astro automatically enhances the HTML standard `<script>` tag with bundling, TypeScript, and more. See [how astro processes scripts](#script-processing) for more details. src/components/ConfettiButton.astro ```astro <button data-confetti-button>Celebrate!</button> <script> // Import from npm package. import confetti from 'canvas-confetti'; // Find our component DOM on the page. const buttons = document.querySelectorAll('[data-confetti-button]'); // Add event listeners to fire confetti when a button is clicked. buttons.forEach((button) => { button.addEventListener('click', () => confetti()); }); </script> ``` See [when your scripts will not be processed](#unprocessed-scripts) to troubleshoot script behavior, or to learn how to opt-out of this processing intentionally. ## Script processing [Section titled ‚ÄúScript processing‚Äù](#script-processing) By default, Astro processes `<script>` tags that contain no attributes (other than `src`) in the following ways: * **TypeScript support:** All scripts are TypeScript by default. * **Import bundling:** Import local files or npm modules, which will be bundled together. * **Type Module:** Processed scripts become [`type="module"`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules) automatically. * **Deduplication:** If a component that contains a `<script>` is used multiple times on a page, the script will only be included once. * **Automatic inlining:** If the script is small enough, Astro will inline it directly into the HTML to reduce the number of requests. src/components/Example.astro ```astro <script> // Processed! Bundled! TypeScript! // Importing local scripts and from npm packages works. </script> ``` ### Unprocessed scripts [Section titled ‚ÄúUnprocessed scripts‚Äù](#unprocessed-scripts) Astro will not process a `<script>` tag if it has any attribute other than `src`. You can add the [`is:inline`](/en/reference/directives-reference/#isinline) directive to intentionally opt out of processing for a script. src/components/InlineScript.astro ```astro <script is:inline> // Will be rendered into the HTML exactly as written! // Not transformed: no TypeScript and no import resolution by Astro. // If used inside a component, this code is duplicated for each instance. </script> ``` ### Include JavaScript files on your page [Section titled ‚ÄúInclude JavaScript files on your page‚Äù](#include-javascript-files-on-your-page) You may want to write your scripts as separate `.js`/`.ts` files or need to reference an external script on another server. You can do this by referencing these in a `<script>` tag‚Äôs `src` attribute. #### Import local scripts [Section titled ‚ÄúImport local scripts‚Äù](#import-local-scripts) **When to use this:** when your script lives inside of `src/`. Astro will process these scripts according to the [script processing rules](#script-processing). src/components/LocalScripts.astro ```astro <!-- relative path to script at `src/scripts/local.js` --> <script src="../scripts/local.js"></script> <!-- also works for local TypeScript files --> <script src="./script-with-types.ts"></script> ``` #### Load external scripts [Section titled ‚ÄúLoad external scripts‚Äù](#load-external-scripts) **When to use this:** when your JavaScript file lives inside of `public/` or on a CDN. To load scripts outside of your project‚Äôs `src/` folder, include the `is:inline` directive. This approach skips the JavaScript processing, bundling, and optimizations that are provided by Astro when you import scripts as described above. src/components/ExternalScripts.astro ```astro <!-- absolute path to a script at `public/my-script.js` --> <script is:inline src="/my-script.js"></script> <!-- full URL to a script on a remote server --> <script is:inline src="https://my-analytics.com/script.js"></script> ``` ## Common script patterns [Section titled ‚ÄúCommon script patterns‚Äù](#common-script-patterns) ### Handle `onclick` and other events [Section titled ‚ÄúHandle onclick and other events‚Äù](#handle-onclick-and-other-events) Some UI frameworks use custom syntax for event handling like `onClick={...}` (React/Preact) or `@click="..."` (Vue). Astro follows standard HTML more closely and does not use custom syntax for events. Instead, you can use [`addEventListener`](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener) in a `<script>` tag to handle user interactions. src/components/AlertButton.astro ```astro <button class="alert">Click me!</button> <script> // Find all buttons with the `alert` class on the page. const buttons = document.querySelectorAll('button.alert'); // Handle clicks on each button. buttons.forEach((button) => { button.addEventListener('click', () => { alert('Button was clicked!'); }); }); </script> ``` If you have multiple `<AlertButton />` components on a page, Astro will not run the script multiple times. Scripts are bundled and only included once per page. Using `querySelectorAll` ensures that this script attaches the event listener to every button with the `alert` class found on the page. ### Web components with custom elements [Section titled ‚ÄúWeb components with custom elements‚Äù](#web-components-with-custom-elements) You can create your own HTML elements with custom behavior using the Web Components standard. Defining a [custom element](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_custom_elements) in a `.astro` component allows you to build interactive components without needing a UI framework library. In this example, we define a new `<astro-heart>` HTML element that tracks how many times you click the heart button and updates the `<span>` with the latest count. src/components/AstroHeart.astro ```astro <!-- Wrap the component elements in our custom element ‚Äúastro-heart‚Äù. --> <astro-heart> <button aria-label="Heart">üíú</button> √ó <span>0</span> </astro-heart> <script> // Define the behaviour for our new type of HTML element. class AstroHeart extends HTMLElement { connectedCallback() { let count = 0; const heartButton = this.querySelector('button'); const countSpan = this.querySelector('span'); // Each time the button is clicked, update the count. heartButton.addEventListener('click', () => { count++; countSpan.textContent = count.toString(); }); } } // Tell the browser to use our AstroHeart class for <astro-heart> elements. customElements.define('astro-heart', AstroHeart); </script> ``` There are two advantages to using a custom element here: 1. Instead of searching the whole page using `document.querySelector()`, you can use `this.querySelector()`, which only searches within the current custom element instance. This makes it easier to work with only the children of one component instance at a time. 2. Although a `<script>` only runs once, the browser will run our custom element‚Äôs `connectedCallback()` method each time it finds `<astro-heart>` on the page. This means you can safely write code for one component at a time, even if you intend to use this component multiple times on a page. You can learn more about custom elements in [web.dev‚Äôs Reusable Web Components guide](https://web.dev/custom-elements-v1/) and [MDN‚Äôs introduction to custom elements](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_custom_elements). ### Pass frontmatter variables to scripts [Section titled ‚ÄúPass frontmatter variables to scripts‚Äù](#pass-frontmatter-variables-to-scripts) In Astro components, the code in [the frontmatter](/en/basics/astro-components/#the-component-script) (between the `---` fences) runs on the server and is not available in the browser. To pass server-side variables to client-side scripts, store them in [`data-*` attributes](https://developer.mozilla.org/en-US/docs/Learn/HTML/Howto/Use_data_attributes) on HTML elements. Scripts can then access these values using the `dataset` property. In this example component, a `message` prop is stored in a `data-message` attribute, so the custom element can read `this.dataset.message` and get the value of the prop in the browser. src/components/AstroGreet.astro ```astro --- const { message = 'Welcome, world!' } = Astro.props; --- <!-- Store the message prop as a data attribute. --> <astro-greet data-message={message}> <button>Say hi!</button> </astro-greet> <script> class AstroGreet extends HTMLElement { connectedCallback() { // Read the message from the data attribute. const message = this.dataset.message; const button = this.querySelector('button'); button.addEventListener('click', () => { alert(message); }); } } customElements.define('astro-greet', AstroGreet); </script> ``` Now we can use our component multiple times and be greeted by a different message for each one. src/pages/example.astro ```astro --- import AstroGreet from '../components/AstroGreet.astro'; --- <!-- Use the default message: ‚ÄúWelcome, world!‚Äù --> <AstroGreet /> <!-- Use custom messages passed as a props. --> <AstroGreet message="Lovely day to build components!" /> <AstroGreet message="Glad you made it! üëã" /> ``` ### Combining scripts and UI Frameworks [Section titled ‚ÄúCombining scripts and UI Frameworks‚Äù](#combining-scripts-and-ui-frameworks) Elements rendered by a UI framework may not be available yet when a `<script>` tag executes. If your script also needs to handle [UI framework components](/en/guides/framework-components/), using a custom element is recommended.

# Content collections

> Manage your content with type safety.

**Added in:** `astro@2.0.0` **Content collections** are the best way to manage sets of content in any Astro project. Collections help to organize and query your documents, enable Intellisense and type checking in your editor, and provide automatic TypeScript type-safety for all of your content. Astro v5.0 introduced the Content Layer API for defining and querying content collections. This performant, scalable API provides built-in content loaders for your local collections. For remote content, you can use third-party and community-built loaders or create your own custom loader and pull in your data from any source. ## What are Content Collections? [Section titled ‚ÄúWhat are Content Collections?‚Äù](#what-are-content-collections) You can define a **collection** from a set of data that is structurally similar. This can be a directory of blog posts, a JSON file of product items, or any data that represents multiple items of the same shape. Collections stored locally in your project or on your filesystem can have entries of Markdown, MDX, Markdoc, YAML, TOML, or JSON files: With an appropriate collection loader, you can fetch remote data from any external source, such as a CMS, database, or headless payment system. ## TypeScript configuration for collections [Section titled ‚ÄúTypeScript configuration for collections‚Äù](#typescript-configuration-for-collections) Content collections rely on TypeScript to provide Zod validation, Intellisense and type checking in your editor. If you are not extending one of Astro‚Äôs `strict` or `strictest` TypeScript settings, you will need to ensure the following `compilerOptions` are set in your `tsconfig.json`: tsconfig.json ```diff { // Included with "astro/tsconfigs/strict" or "astro/tsconfigs/strictest" "extends": "astro/tsconfigs/base", "compilerOptions": { +"strictNullChecks": true, // add if using `base` template "allowJs": true // required, and included with all Astro templates } } ``` ## Defining Collections [Section titled ‚ÄúDefining Collections‚Äù](#defining-collections) Individual collections use `defineCollection()` to configure: * a `loader` for a data source (required) * a `schema` for type safety (optional, but highly recommended!) ### The collection config file [Section titled ‚ÄúThe collection config file‚Äù](#the-collection-config-file) To define collections, you must create a `src/content.config.ts` file in your project (`.js` and `.mjs` extensions are also supported.) This is a special file that Astro will use to configure your content collections based on the following structure: src/content.config.ts ```ts // 1. Import utilities from `astro:content` import { defineCollection } from 'astro:content'; // 2. Import loader(s) import { glob, file } from 'astro/loaders'; // 3. Import Zod import { z } from 'astro/zod'; // 4. Define your collection(s) const blog = defineCollection({ /* ... */ }); const dogs = defineCollection({ /* ... */ }); // 5. Export a single `collections` object to register your collection(s) export const collections = { blog, dogs }; ``` ### Defining the collection `loader` [Section titled ‚ÄúDefining the collection loader‚Äù](#defining-the-collection-loader) The Content Layer API allows you to fetch your content (whether stored locally in your project or remotely) and uses a `loader` property to retrieve your data. #### Built-in loaders [Section titled ‚ÄúBuilt-in loaders‚Äù](#built-in-loaders) Astro provides [two built-in loader functions](/en/reference/content-loader-reference/#built-in-loaders) (`glob()` and `file()`) for fetching your local content, as well as access to the API to construct your own loader and fetch remote data. The [`glob()` loader](/en/reference/content-loader-reference/#glob-loader) creates entries from directories of Markdown, MDX, Markdoc, JSON, YAML, or TOML files from anywhere on the filesystem. It accepts a `pattern` of entry files to match using glob patterns supported by [micromatch](https://github.com/micromatch/micromatch#matching-features), and a base file path of where your files are located. Each entry‚Äôs `id` will be automatically generated from its file name. Use this loader when you have one file per entry. The [`file()` loader](/en/reference/content-loader-reference/#file-loader) creates multiple entries from a single local file. Each entry in the file must have a unique `id` key property. It accepts a `base` file path to your file and optionally a [`parser` function](#parser-function) for data files it cannot parse automatically, or to parse data asynchronously. Use this loader when your data file can be parsed as an array of objects. src/content.config.ts ```ts import { defineCollection } from 'astro:content'; import { glob, file } from 'astro/loaders'; // Not available with legacy API import { z } from 'astro/zod'; const blog = defineCollection({ loader: glob({ pattern: "**/*.md", base: "./src/data/blog" }), schema: /* ... */ }); const dogs = defineCollection({ loader: file("src/data/dogs.json"), schema: /* ... */ }); const probes = defineCollection({ // `loader` can accept an array of multiple patterns as well as string patterns // Load all markdown files in the space-probes directory, except for those that start with "voyager-" loader: glob({ pattern: ['*.md', '!voyager-*'], base: 'src/data/space-probes' }), schema: z.object({ name: z.string(), type: z.enum(['Space Probe', 'Mars Rover', 'Comet Lander']), launch_date: z.date(), status: z.enum(['Active', 'Inactive', 'Decommissioned']), destination: z.string(), operator: z.string(), notable_discoveries: z.array(z.string()), }), }); export const collections = { blog, dogs, probes }; ``` ##### `parser` function [Section titled ‚Äúparser function‚Äù](#parser-function) The `file()` loader accepts a second argument that defines a `parser` function. This allows you to specify a custom parser (e.g. `csv-parse`) to create a collection from a file‚Äôs contents. The `file()` loader will automatically detect and parse (based on their file extension) a single array of objects from JSON and YAML files, and will treat each top-level table as an independent entry in TOML files. Support for these file types is built-in, and there is no need for a `parser` unless you have a [nested JSON document](#nested-json-documents). To use other files, such as `.csv`, you will need to create a parser function. The following example shows importing a CSV parser, then loading a `cats` collection into your project by passing both a file path and `parser` function to the `file()` loader: src/content.config.ts ```typescript import { defineCollection } from "astro:content"; import { file } from "astro/loaders"; import { parse as parseCsv } from "csv-parse/sync"; const cats = defineCollection({ loader: file("src/data/cats.csv", { parser: (text) => parseCsv(text, { columns: true, skipEmptyLines: true })}) }); ``` ###### Nested `.json` documents [Section titled ‚ÄúNested .json documents‚Äù](#nested-json-documents) The `parser` argument also allows you to load a single collection from a nested JSON document. For example, this JSON file contains multiple collections: src/data/pets.json ```json {"dogs": [{}], "cats": [{}]} ``` You can separate these collections by passing a custom `parser` to the `file()` loader for each collection: src/content.config.ts ```typescript const dogs = defineCollection({ loader: file("src/data/pets.json", { parser: (text) => JSON.parse(text).dogs }) }); const cats = defineCollection({ loader: file("src/data/pets.json", { parser: (text) => JSON.parse(text).cats }) }); ``` #### Building a custom loader [Section titled ‚ÄúBuilding a custom loader‚Äù](#building-a-custom-loader) You can build a custom loader to fetch remote content from any data source, such as a CMS, a database, or an API endpoint. Using a loader to fetch your data will automatically create a collection from your remote data. This gives you all the benefits of local collections, such as collection-specific API helpers such as `getCollection()` and `render()` to query and display your data, as well as schema validation. ##### Inline loaders [Section titled ‚ÄúInline loaders‚Äù](#inline-loaders) You can define a loader inline, inside your collection, as an async function that returns an array of entries. This is useful for loaders that don‚Äôt need to manually control how the data is loaded and stored. Whenever the loader is called, it will clear the store and reload all the entries. src/content.config.ts ```ts const countries = defineCollection({ loader: async () => { const response = await fetch("https://restcountries.com/v3.1/all"); const data = await response.json(); // Must return an array of entries with an id property, or an object with IDs as keys and entries as values return data.map((country) => ({ id: country.cca3, ...country, })); }, schema: /* ... */ }); ``` The returned entries are stored in the collection and can be queried using the `getCollection()` and `getEntry()` functions. ##### Loader objects [Section titled ‚ÄúLoader objects‚Äù](#loader-objects) For more control over the loading process, you can use the Content Loader API to create a loader object. For example, with access to the `load` method directly, you can create a loader that allows entries to be updated incrementally or clears the store only when necessary. Similar to creating an Astro integration or Vite plugin, you can [distribute your loader as an NPM package](/en/reference/publish-to-npm/) that others can use in their projects. See the full [Content Loader API](/en/reference/content-loader-reference/) and examples of how to build your own loader. ### Defining the collection schema [Section titled ‚ÄúDefining the collection schema‚Äù](#defining-the-collection-schema) Schemas enforce consistent frontmatter or entry data within a collection through Zod validation. A schema **guarantees** that this data exists in a predictable form when you need to reference or query it. If any file violates its collection schema, Astro will provide a helpful error to let you know. Schemas also power Astro‚Äôs automatic TypeScript typings for your content. When you define a schema for your collection, Astro will automatically generate and apply a TypeScript interface to it. The result is full TypeScript support when you query your collection, including property autocompletion and type-checking. Every frontmatter or data property of your collection entries must be defined using a [Zod data type](/en/reference/modules/astro-zod/#common-data-type-validators): src/content.config.ts ```ts import { defineCollection } from 'astro:content'; import { glob, file } from 'astro/loaders'; import { z } from 'astro/zod'; const blog = defineCollection({ loader: glob({ pattern: "**/*.md", base: "./src/data/blog" }), schema: z.object({ title: z.string(), description: z.string(), pubDate: z.coerce.date(), updatedDate: z.coerce.date().optional(), }) }); const dogs = defineCollection({ loader: file("src/data/dogs.json"), schema: z.object({ id: z.string(), breed: z.string(), temperament: z.array(z.string()), }), }); export const collections = { blog, dogs }; ``` #### Defining datatypes with Zod [Section titled ‚ÄúDefining datatypes with Zod‚Äù](#defining-datatypes-with-zod) Astro uses [Zod](https://github.com/colinhacks/zod) to power its content schemas. With Zod, Astro is able to validate every file‚Äôs data within a collection *and* provide automatic TypeScript types when you go to query content from inside your project. To use Zod in Astro, import the `z` utility from `"astro/zod"`. This is a re-export of the Zod library, and it supports all of the features of Zod. See the [`z` utility reference](/en/reference/modules/astro-zod/) for a cheatsheet of common datatypes and to learn how Zod works and what features are available. ##### Zod schema methods [Section titled ‚ÄúZod schema methods‚Äù](#zod-schema-methods) All [Zod schema methods](/en/reference/modules/astro-zod/#using-zod-methods) (e.g. `.parse()`, `.transform()`) are available, with some limitations. Notably, performing custom validation checks on images using `image().refine()` is unsupported. #### Defining collection references [Section titled ‚ÄúDefining collection references‚Äù](#defining-collection-references) Collection entries can also ‚Äúreference‚Äù other related entries. With the [`reference()` function](/en/reference/modules/astro-content/#reference) from the Collections API, you can define a property in a collection schema as an entry from another collection. For example, you can require that every `space-shuttle` entry includes a `pilot` property which uses the `pilot` collection‚Äôs own schema for type checking, autocomplete, and validation. A common example is a blog post that references reusable author profiles stored as JSON, or related post URLs stored in the same collection: src/content.config.ts ```ts import { defineCollection, reference } from 'astro:content'; import { glob } from 'astro/loaders'; import { z } from 'astro/zod'; const blog = defineCollection({ loader: glob({ pattern: '**/[^_]*.md', base: "./src/data/blog" }), schema: z.object({ title: z.string(), // Reference a single author from the `authors` collection by `id` author: reference('authors'), // Reference an array of related posts from the `blog` collection by `slug` relatedPosts: z.array(reference('blog')), }) }); const authors = defineCollection({ loader: glob({ pattern: '**/[^_]*.json', base: "./src/data/authors" }), schema: z.object({ name: z.string(), portfolio: z.string().url(), }) }); export const collections = { blog, authors }; ``` This example blog post specifies the `id`s of related posts and the `id` of the post author: src/data/blog/welcome.md ```yaml --- title: "Welcome to my blog" author: ben-holmes # references `src/data/authors/ben-holmes.json` relatedPosts: - about-me # references `src/data/blog/about-me.md` - my-year-in-review # references `src/data/blog/my-year-in-review.md` --- ``` These references will be transformed into objects containing a `collection` key and an `id` key, allowing you to easily [query them in your templates](/en/guides/content-collections/#accessing-referenced-data). ### Defining custom IDs [Section titled ‚ÄúDefining custom IDs‚Äù](#defining-custom-ids) When using the `glob()` loader with Markdown, MDX, Markdoc, or JSON files, every content entry [`id`](/en/reference/modules/astro-content/#id) is automatically generated in an URL-friendly format based on the content filename. The `id` is used to query the entry directly from your collection. It is also useful when creating new pages and URLs from your content. You can override an entry‚Äôs generated `id` by adding your own `slug` property to the file frontmatter or data object for JSON files. This is similar to the ‚Äúpermalink‚Äù feature of other web frameworks. src/blog/1.md ```md --- title: My Blog Post slug: my-custom-id/supports/slashes --- Your blog post content here. ``` src/categories/1.json ```json { "title": "My Category", "slug": "my-custom-id/supports/slashes", "description": "Your category description here." } ``` ## Querying Collections [Section titled ‚ÄúQuerying Collections‚Äù](#querying-collections) Astro provides helper functions to query a collection and return one (or more) content entries. * [`getCollection()`](/en/reference/modules/astro-content/#getcollection) fetches an entire collection and returns an array of entries. * [`getEntry()`](/en/reference/modules/astro-content/#getentry) fetches a single entry from a collection. These return entries with a unique `id`, a `data` object with all defined properties, and will also return a `body` containing the raw, uncompiled body of a Markdown, MDX, or Markdoc document. ```js import { getCollection, getEntry } from 'astro:content'; // Get all entries from a collection. // Requires the name of the collection as an argument. const allBlogPosts = await getCollection('blog'); // Get a single entry from a collection. // Requires the name of the collection and `id` const poodleData = await getEntry('dogs', 'poodle'); ``` The sort order of generated collections is non-deterministic and platform-dependent. This means that if you are calling `getCollection()` and need your entries returned in a specific order (e.g. blog posts sorted by date), you must sort the collection entries yourself: src/pages/blog.astro ```astro --- import { getCollection } from 'astro:content'; const posts = (await getCollection('blog')).sort( (a, b) => b.data.pubDate.valueOf() - a.data.pubDate.valueOf(), ); --- ``` See the full list of properties returned by the [`CollectionEntry` type](/en/reference/modules/astro-content/#collectionentry). ### Using content in Astro templates [Section titled ‚ÄúUsing content in Astro templates‚Äù](#using-content-in-astro-templates) After querying your collections, you can access each entry‚Äôs content directly inside of your Astro component template. For example, you can create a list of links to your blog posts, displaying information from your entry‚Äôs frontmatter using the `data` property. src/pages/index.astro ```astro --- import { getCollection } from 'astro:content'; const posts = await getCollection('blog'); --- <h1>My posts</h1> <ul> {posts.map(post => ( <li><a href={`/blog/${post.id}`}>{post.data.title}</a></li> ))} </ul> ``` #### Rendering body content [Section titled ‚ÄúRendering body content‚Äù](#rendering-body-content) Once queried, you can render Markdown and MDX entries to HTML using the [`render()`](/en/reference/modules/astro-content/#render) function property. Calling this function gives you access to rendered HTML content, including both a `<Content />` component and a list of all rendered headings. src/pages/blog/post-1.astro ```astro --- import { getEntry, render } from 'astro:content'; const entry = await getEntry('blog', 'post-1'); if (!entry) { // Handle Error, for example: throw new Error('Could not find blog post 1'); } const { Content, headings } = await render(entry); --- <p>Published on: {entry.data.published.toDateString()}</p> <Content /> ``` When working with MDX entries, you can also [pass your own components to `<Content />`](/en/guides/integrations-guide/mdx/#passing-components-to-mdx-content) to replace HTML elements with custom alternatives. #### Passing content as props [Section titled ‚ÄúPassing content as props‚Äù](#passing-content-as-props) A component can also pass an entire collection entry as a prop. You can use the [`CollectionEntry`](/en/reference/modules/astro-content/#collectionentry) utility to correctly type your component‚Äôs props using TypeScript. This utility takes a string argument that matches the name of your collection schema and will inherit all of the properties of that collection‚Äôs schema. src/components/BlogCard.astro ```astro --- import type { CollectionEntry } from 'astro:content'; interface Props { post: CollectionEntry<'blog'>; } // `post` will match your 'blog' collection schema type const { post } = Astro.props; --- ``` ### Filtering collection queries [Section titled ‚ÄúFiltering collection queries‚Äù](#filtering-collection-queries) `getCollection()` takes an optional ‚Äúfilter‚Äù callback that allows you to filter your query based on an entry‚Äôs `id` or `data` properties. You can use this to filter by any content criteria you like. For example, you can filter by properties like `draft` to prevent any draft blog posts from publishing to your blog: ```js // Example: Filter out content entries with `draft: true` import { getCollection } from 'astro:content'; const publishedBlogEntries = await getCollection('blog', ({ data }) => { return data.draft !== true; }); ``` You can also create draft pages that are available when running the dev server, but not built in production: ```js // Example: Filter out content entries with `draft: true` only when building for production import { getCollection } from 'astro:content'; const blogEntries = await getCollection('blog', ({ data }) => { return import.meta.env.PROD ? data.draft !== true : true; }); ``` The filter argument also supports filtering by nested directories within a collection. Since the `id` includes the full nested path, you can filter by the start of each `id` to only return items from a specific nested directory: ```js // Example: Filter entries by sub-directory in the collection import { getCollection } from 'astro:content'; const englishDocsEntries = await getCollection('docs', ({ id }) => { return id.startsWith('en/'); }); ``` ### Accessing referenced data [Section titled ‚ÄúAccessing referenced data‚Äù](#accessing-referenced-data) Any [references defined in your schema](/en/guides/content-collections/#defining-collection-references) must be queried separately after first querying your collection entry. Since the [`reference()` function](/en/reference/modules/astro-content/#reference) transforms a reference to an object with `collection` and `id` as keys, you can use the `getEntry()` function to return a single referenced item, or `getEntries()` to retrieve multiple referenced entries from the returned `data` object. src/pages/blog/welcome.astro ```astro --- import { getEntry, getEntries } from 'astro:content'; const blogPost = await getEntry('blog', 'welcome'); // Resolve a singular reference (e.g. `{collection: "authors", id: "ben-holmes"}`) const author = await getEntry(blogPost.data.author); // Resolve an array of references // (e.g. `[{collection: "blog", id: "about-me"}, {collection: "blog", id: "my-year-in-review"}]`) const relatedPosts = await getEntries(blogPost.data.relatedPosts); --- <h1>{blogPost.data.title}</h1> <p>Author: {author.data.name}</p> <!-- ... --> <h2>You might also like:</h2> {relatedPosts.map(post => ( <a href={post.id}>{post.data.title}</a> ))} ``` ## Generating Routes from Content [Section titled ‚ÄúGenerating Routes from Content‚Äù](#generating-routes-from-content) Content collections are stored outside of the `src/pages/` directory. This means that no pages or routes are generated for your collection items by default. You will need to manually create a new [dynamic route](/en/guides/routing/#dynamic-routes) if you want to generate HTML pages for each of your collection entries, such as individual blog posts. Your dynamic route will map the incoming request param (e.g. `Astro.params.slug` in `src/pages/blog/[...slug].astro`) to fetch the correct entry for each page. The exact method for generating routes will depend on whether your pages are prerendered (default) or rendered on demand by a server. ### Building for static output (default) [Section titled ‚ÄúBuilding for static output (default)‚Äù](#building-for-static-output-default) If you are building a static website (Astro‚Äôs default behavior), use the [`getStaticPaths()`](/en/reference/routing-reference/#getstaticpaths) function to create multiple pages from a single page component (e.g. `src/pages/[slug]`) during your build. Call `getCollection()` inside of `getStaticPaths()` to have your collection data available for building static routes. Then, create the individual URL paths using the `id` property of each content entry. Each page is passed the entire collection entry as a prop for [use in your page template](#using-content-in-astro-templates). src/pages/posts/\[id].astro ```astro --- import { getCollection, render } from 'astro:content'; // 1. Generate a new path for every collection entry export async function getStaticPaths() { const posts = await getCollection('blog'); return posts.map(post => ({ params: { id: post.id }, props: { post }, })); } // 2. For your template, you can get the entry directly from the prop const { post } = Astro.props; const { Content } = await render(post); --- <h1>{post.data.title}</h1> <Content /> ``` This will generate a page route for every entry in the `blog` collection. For example, an entry at `src/blog/hello-world.md` will have an `id` of `hello-world`, and therefore its final URL will be `/posts/hello-world/`. ### Building for server output (SSR) [Section titled ‚ÄúBuilding for server output (SSR)‚Äù](#building-for-server-output-ssr) If you are building a dynamic website (using Astro‚Äôs SSR support), you are not expected to generate any paths ahead of time during the build. Instead, your page should examine the request (using `Astro.request` or `Astro.params`) to find the `slug` on-demand, and then fetch it using [`getEntry()`](/en/reference/modules/astro-content/#getentry). src/pages/posts/\[id].astro ```astro --- import { getEntry, render } from "astro:content"; // 1. Get the slug from the incoming server request const { id } = Astro.params; if (id === undefined) { return Astro.redirect("/404"); } // 2. Query for the entry directly using the request slug const post = await getEntry("blog", id); // 3. Redirect if the entry does not exist if (post === undefined) { return Astro.redirect("/404"); } // 4. Render the entry to HTML in the template const { Content } = await render(post); --- <h1>{post.data.title}</h1> <Content /> ``` ## Collection JSON Schemas [Section titled ‚ÄúCollection JSON Schemas‚Äù](#collection-json-schemas) **Added in:** `astro@4.13.0` Astro auto-generates [JSON Schema](https://json-schema.org/) files for collections, which you can use in your editor to get IntelliSense and type-checking for data files. A JSON Schema file is generated for each collection in your project and output to the `.astro/collections/` directory. For example, if you have two collections, one named `authors` and another named `posts`, Astro will generate `.astro/collections/authors.schema.json` and `.astro/collections/posts.schema.json`. ### Use JSON Schemas in JSON files [Section titled ‚ÄúUse JSON Schemas in JSON files‚Äù](#use-json-schemas-in-json-files) You can manually point to an Astro-generated schema by setting the `$schema` field in your JSON file. The value should be a relative file path from the data file to the schema. In the following example, a data file in `src/data/authors/` uses the schema generated for the `authors` collection: src/data/authors/armand.json ```diff { +"$schema": "../../../.astro/collections/authors.schema.json", "name": "Armand", "skills": ["Astro", "Starlight"] } ``` #### Use a schema for a group of JSON files in VS Code [Section titled ‚ÄúUse a schema for a group of JSON files in VS Code‚Äù](#use-a-schema-for-a-group-of-json-files-in-vs-code) In VS Code, you can configure a schema to apply for all files in a collection using the [`json.schemas` setting](https://code.visualstudio.com/docs/languages/json#_json-schemas-and-settings). In the following example, all files in the `src/data/authors/` directory will use the schema generated for the `authors` collection: ```json { "json.schemas": [ { "fileMatch": ["/src/data/authors/**"], "url": "./.astro/collections/authors.schema.json" } ] } ``` ### Use schemas in YAML files in VS Code [Section titled ‚ÄúUse schemas in YAML files in VS Code‚Äù](#use-schemas-in-yaml-files-in-vs-code) In VS Code, you can add support for using JSON schemas in YAML files using the [Red Hat YAML](https://marketplace.visualstudio.com/items?itemName=redhat.vscode-yaml) extension. With this extension installed, you can reference a schema in a YAML file using a special comment syntax: src/data/authors/armand.yml ```diff +# yaml-language-server: $schema=../../../.astro/collections/authors.schema.json name: Armand skills: - Astro - Starlight ``` #### Use schemas for a group of YAML files in VS Code [Section titled ‚ÄúUse schemas for a group of YAML files in VS Code‚Äù](#use-schemas-for-a-group-of-yaml-files-in-vs-code) With the Red Hat YAML extension, you can configure a schema to apply for all YAML files in a collection using the `yaml.schemas` setting. In the following example, all YAML files in the `src/data/authors/` directory will use the schema generated for the `authors` collection: ```json { "yaml.schemas": { "./.astro/collections/authors.schema.json": ["/src/content/authors/*.yml"] } } ``` See [‚ÄúAssociating schemas‚Äù](https://marketplace.visualstudio.com/items?itemName=redhat.vscode-yaml#associating-schemas) in the Red Hat YAML extension documentation for more details. ## When to create a collection [Section titled ‚ÄúWhen to create a collection‚Äù](#when-to-create-a-collection) You can [create a collection](#defining-collections) any time you have a group of related data or content that shares a common structure. Much of the benefit of using collections comes from: * Defining a common data shape to validate that an individual entry is ‚Äúcorrect‚Äù or ‚Äúcomplete‚Äù, avoiding errors in production. * Content-focused APIs designed to make querying intuitive (e.g. `getCollection()` instead of `import.meta.glob()`) when importing and rendering content on your pages. * A [Content Loader API](/en/reference/content-loader-reference/) for retrieving your content that provides both built-in loaders and access to the low-level API. There are several third-party and community-built loaders available, and you can build your own custom loader to fetch data from anywhere. * Performance and scalability. The Content Layer API allows data to be cached between builds and is suitable for tens of thousands of content entries. [Define your data](#defining-collections) as a collection when: * You have multiple files or data to organize that share the same overall structure (e.g. blog posts written in Markdown which all have the same frontmatter properties). * You have existing content stored remotely, such as in a CMS, and want to take advantage of the collections helper functions and Content Layer API instead of using `fetch()` or SDKs. * You need to fetch (tens of) thousands of related pieces of data, and need a querying and caching method that handles at scale. ### When not to create a collection [Section titled ‚ÄúWhen not to create a collection‚Äù](#when-not-to-create-a-collection) Collections provide excellent structure, safety, and organization when you have **multiple pieces of content that must share the same properties**. Collections **may not be your solution** if: * You have only one or a small number of different pages. Consider [making individual page components](/en/basics/astro-pages/) such as `src/pages/about.astro` with your content directly instead. * You are displaying files that are not processed by Astro, such as PDFs. Place these static assets in the [`public/` directory](/en/basics/project-structure/#public) of your project instead. * Your data source has its own SDK/client library for imports that is incompatible with or does not offer a content loader and you prefer to use it directly. * You are using APIs that need to be updated in real time. Content collections are only updated at build time, so if you need live data, use other methods of [importing files](/en/guides/imports/#import-statements) or [fetching data](/en/guides/data-fetching/) with [on-demand rendering](/en/guides/on-demand-rendering/).

# Data fetching

> Learn how to fetch remote data with Astro using the fetch API.

`.astro` files can fetch remote data to help you generate your pages. ## `fetch()` in Astro [Section titled ‚Äúfetch() in Astro‚Äù](#fetch-in-astro) All [Astro components](/en/basics/astro-components/) have access to the [global `fetch()` function](https://developer.mozilla.org/en-US/docs/Web/API/fetch) in their component script to make HTTP requests to APIs using the full URL (e.g. `https://example.com/api`). Additionally, you can construct a URL to your project‚Äôs pages and endpoints that are rendered on demand on the server using [`new URL("/api", Astro.url)`](/en/reference/api-reference/#url). This fetch call will be executed at build time, and the data will be available to the component template for generating dynamic HTML. If [SSR](/en/guides/on-demand-rendering/) mode is enabled, any fetch calls will be executed at runtime. üí° Take advantage of [**top-level `await`**](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await#top_level_await) inside of your Astro component script. üí° Pass fetched data to both Astro and framework components, as props. src/components/User.astro ```astro --- import Contact from "../components/Contact.jsx"; import Location from "../components/Location.astro"; const response = await fetch("https://randomuser.me/api/"); const data = await response.json(); const randomUser = data.results[0]; --- <!-- Data fetched at build can be rendered in HTML --> <h1>User</h1> <h2>{randomUser.name.first} {randomUser.name.last}</h2> <!-- Data fetched at build can be passed to components as props --> <Contact client:load email={randomUser.email} /> <Location city={randomUser.location.city} /> ``` ## `fetch()` in Framework Components [Section titled ‚Äúfetch() in Framework Components‚Äù](#fetch-in-framework-components) The `fetch()` function is also globally available to any [framework components](/en/guides/framework-components/): src/components/Movies.tsx ```tsx import type { FunctionalComponent } from 'preact'; const data = await fetch('https://example.com/movies.json').then((response) => response.json()); // Components that are build-time rendered also log to the CLI. // When rendered with a `client:*` directive, they also log to the browser console. console.log(data); const Movies: FunctionalComponent = () => { // Output the result to the page return <div>{JSON.stringify(data)}</div>; }; export default Movies; ``` ## GraphQL queries [Section titled ‚ÄúGraphQL queries‚Äù](#graphql-queries) Astro can also use `fetch()` to query a GraphQL server with any valid GraphQL query. src/components/Film.astro ```astro --- const response = await fetch( "https://swapi-graphql.netlify.app/.netlify/functions/index", { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ query: ` query getFilm ($id:ID!) { film(id: $id) { title releaseDate } } `, variables: { id: "ZmlsbXM6MQ==", }, }), } ); const json = await response.json(); const { film } = json.data; --- <h1>Fetching information about Star Wars: A New Hope</h1> <h2>Title: {film.title}</h2> <p>Year: {film.releaseDate}</p> ``` ## Fetch from a Headless CMS [Section titled ‚ÄúFetch from a Headless CMS‚Äù](#fetch-from-a-headless-cms) Astro components can fetch data from your favorite CMS and then render it as your page content. Using [dynamic routes](/en/guides/routing/#dynamic-routes), components can even generate pages based on your CMS content. See our [CMS Guides](/en/guides/cms/) for full details on integrating Astro with headless CMSes including Storyblok, Contentful, and WordPress. ## Community resources [Section titled ‚ÄúCommunity resources‚Äù](#community-resources) * [Creating a fullstack app with Astro + GraphQL](https://robkendal.co.uk/blog/how-to-build-astro-site-with-graphql/)

# Dev toolbar

> A guide to using the dev toolbar in Astro

While the dev server is running, Astro includes a dev toolbar at the bottom of every page in your local browser preview. This toolbar includes a number of useful tools for debugging and inspecting your site during development and can be [extended with more dev toolbar apps](#extending-the-dev-toolbar) found in the integrations directory. You can even [build your own toolbar apps](/en/recipes/making-toolbar-apps/) using the [Dev Toolbar API](/en/reference/dev-toolbar-app-reference/)! This toolbar is enabled by default and appears when you hover over the bottom of the page. It is a development tool only and will not appear on your published site. ## Built-in apps [Section titled ‚ÄúBuilt-in apps‚Äù](#built-in-apps) ### Astro Menu [Section titled ‚ÄúAstro Menu‚Äù](#astro-menu) The Astro Menu app provides easy access to various information about the current project and links to extra resources. Notably, it provides one-click access to the Astro documentation, GitHub repository, and Discord server. This app also includes a ‚ÄúCopy debug info‚Äù button which will run the [`astro info`](/en/reference/cli-reference/#astro-info) command and copy the output to your clipboard. This can be useful when asking for help or reporting issues. ### Inspect [Section titled ‚ÄúInspect‚Äù](#inspect) The Inspect app provides information about any [islands](/en/concepts/islands/) on the current page. This will show you the properties passed to each island, and the client directive that is being used to render them. ### Audit [Section titled ‚ÄúAudit‚Äù](#audit) The Audit app automatically runs a series of audits on the current page, checking for the most common performance and accessibility issues. When an issue is found, a red dot will appear in the toolbar. Clicking on the app will pop up a list of results from the audit and will highlight the related elements directly in the page. ### Settings [Section titled ‚ÄúSettings‚Äù](#settings) The Settings app allows you to configure options for the dev toolbar, such as verbose logging, disabling notifications, and adjusting its placement on your screen. ## Extending the dev toolbar [Section titled ‚ÄúExtending the dev toolbar‚Äù](#extending-the-dev-toolbar) Astro integrations can add new apps to the dev toolbar, allowing you to extend it with custom tools that are specific to your project. You can find [more dev tool apps to install in the integrations directory](https://astro.build/integrations/?search=\&categories%5B%5D=toolbar) or using the [Astro Menu](#astro-menu). Install additional dev toolbar app integrations in your project just like any other [Astro integration](/en/guides/integrations-guide/) according to its own installation instructions. ![](/houston_chef.webp) **Related recipe:** [Create a dev toolbar app](/en/recipes/making-toolbar-apps/) ## Disabling the dev toolbar [Section titled ‚ÄúDisabling the dev toolbar‚Äù](#disabling-the-dev-toolbar) The dev toolbar is enabled by default for every site. You can choose to disable it for individual projects and/or users as needed. ### Per-project [Section titled ‚ÄúPer-project‚Äù](#per-project) To disable the dev toolbar for everyone working on a project, set `devToolbar: false` in the [Astro config file](/en/reference/configuration-reference/#devtoolbarenabled). astro.config.mjs ```diff import { defineConfig } from "astro/config"; export default defineConfig({ + devToolbar: { + enabled: false + } }); ``` To enable the dev toolbar again, remove these lines from your configuration, or set `enabled: true`. ### Per-user [Section titled ‚ÄúPer-user‚Äù](#per-user) To disable the dev toolbar for yourself on a specific project, run the [`astro preferences`](/en/reference/cli-reference/#astro-preferences) command. ```shell astro preferences disable devToolbar ``` To disable the dev toolbar in all Astro projects for a user on the current machine, add the `--global` flag when running `astro-preferences`: ```shell astro preferences disable --global devToolbar ``` The dev toolbar can later be enabled with: ```shell astro preferences enable devToolbar ```

# Endpoints

> Learn how to create endpoints that serve any kind of data

Astro lets you create custom endpoints to serve any kind of data. You can use this to generate images, expose an RSS document, or use them as API Routes to build a full API for your site. In statically-generated sites, your custom endpoints are called at build time to produce static files. If you opt in to [SSR](/en/guides/on-demand-rendering/) mode, custom endpoints turn into live server endpoints that are called on request. Static and SSR endpoints are defined similarly, but SSR endpoints support additional features. ## Static File Endpoints [Section titled ‚ÄúStatic File Endpoints‚Äù](#static-file-endpoints) To create a custom endpoint, add a `.js` or `.ts` file to the `/pages` directory. The `.js` or `.ts` extension will be removed during the build process, so the name of the file should include the extension of the data you want to create. For example, `src/pages/data.json.ts` will build a `/data.json` endpoint. Endpoints export a `GET` function (optionally `async`) that receives a [context object](/en/reference/api-reference/) with properties similar to the `Astro` global. Here, it returns a [`Response`](https://developer.mozilla.org/en-US/docs/Web/API/Response) object with a `name` and `url`, and Astro will call this at build time and use the contents of the body to generate the file. src/pages/builtwith.json.ts ```ts // Outputs: /builtwith.json export function GET({ params, request }) { return new Response( JSON.stringify({ name: "Astro", url: "https://astro.build/", }), ); } ``` Since Astro v3.0, the returned `Response` object doesn‚Äôt have to include the `encoding` property anymore. For example, to produce a binary `.png` image: src/pages/astro-logo.png.ts ```ts export async function GET({ params, request }) { const response = await fetch( "https://docs.astro.build/assets/full-logo-light.png", ); return new Response(await response.arrayBuffer()); } ``` You can also get type safety in your endpoint functions using the `APIRoute` type with the `satisfies` operator: ```ts import type { APIRoute } from "astro"; export const GET = (async ({ params, request }) => { /* ... */ }) satisfies APIRoute; ``` ### `params` and Dynamic routing [Section titled ‚Äúparams and Dynamic routing‚Äù](#params-and-dynamic-routing) Endpoints support the same [dynamic routing](/en/guides/routing/#dynamic-routes) features that pages do. Name your file with a bracketed parameter name and export a [`getStaticPaths()` function](/en/reference/routing-reference/#getstaticpaths). Then, you can access the parameter using the `params` property passed to the endpoint function: src/pages/api/\[id].json.ts ```ts import type { APIRoute } from "astro"; const usernames = ["Sarah", "Chris", "Yan", "Elian"]; export const GET = (({ params, request }) => { const id = params.id; return new Response( JSON.stringify({ name: usernames[id], }), ); }) satisfies APIRoute; export function getStaticPaths() { return [ { params: { id: "0" } }, { params: { id: "1" } }, { params: { id: "2" } }, { params: { id: "3" } }, ]; } ``` This will generate four JSON endpoints at build time: `/api/0.json`, `/api/1.json`, `/api/2.json` and `/api/3.json`. Dynamic routing with endpoints works the same as it does with pages. In static mode, you can [pass props to the endpoint using `getStaticPaths()`](/en/reference/routing-reference/#data-passing-with-props). However, with on-demand rendering, since the endpoint is a function and not a component, passing props is not supported. ### `request` [Section titled ‚Äúrequest‚Äù](#request) All endpoints receive a `request` property, but in static mode, you only have access to `request.url`. This returns the full URL of the current endpoint and works the same as [Astro.request.url](/en/reference/api-reference/#request) does for pages. src/pages/request-path.json.ts ```ts import type { APIRoute } from "astro"; export const GET = (({ params, request }) => { return new Response( JSON.stringify({ path: new URL(request.url).pathname, }), ); }) satisfies APIRoute; ``` ## Server Endpoints (API Routes) [Section titled ‚ÄúServer Endpoints (API Routes)‚Äù](#server-endpoints-api-routes) Everything described in the static file endpoints section can also be used in SSR mode: files can export a `GET` function which receives a [context object](/en/reference/api-reference/) with properties similar to the `Astro` global. But, unlike in `static` mode, when you enable on-demand rendering for a route, the endpoint will be built when it is requested. This unlocks new features that are unavailable at build time, and allows you to build API routes that listen for requests and securely execute code on the server at runtime. Your routes will be rendered on demand by default in `server` mode. In `static` mode, you must opt out of prerendering for each custom endpoint with `export const prerender = false`. ![](/houston_chef.webp) **Related recipe:** [Call endpoints from the server](/en/recipes/call-endpoints/) Server endpoints can access `params` without exporting `getStaticPaths`, and they can return a `Response` object, allowing you to set status codes and headers: src/pages/\[id].json.js ```js import { getProduct } from "../db"; export async function GET({ params }) { const id = params.id; const product = await getProduct(id); if (!product) { return new Response(null, { status: 404, statusText: "Not found", }); } return new Response(JSON.stringify(product), { status: 200, headers: { "Content-Type": "application/json", }, }); } ``` This will respond to any request that matches the dynamic route. For example, if we navigate to `/helmet.json`, `params.id` will be set to `helmet`. If `helmet` exists in the mock product database, the endpoint will use a `Response` object to respond with JSON and return a successful [HTTP status code](https://developer.mozilla.org/en-US/docs/Web/API/Response/status). If not, it will use a `Response` object to respond with a `404`. In SSR mode, certain providers require the `Content-Type` header to return an image. In this case, use a `Response` object to specify a `headers` property. For example, to produce a binary `.png` image: src/pages/astro-logo.png.ts ```ts export async function GET({ params, request }) { const response = await fetch( "https://docs.astro.build/assets/full-logo-light.png", ); const buffer = Buffer.from(await response.arrayBuffer()); return new Response(buffer, { headers: { "Content-Type": "image/png" }, }); } ``` ### HTTP methods [Section titled ‚ÄúHTTP methods‚Äù](#http-methods) In addition to the `GET` function, you can export a function with the name of any [HTTP method](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods). When a request comes in, Astro will check the method and call the corresponding function. You can also export an `ALL` function to match any method that doesn‚Äôt have a corresponding exported function. If there is a request with no matching method, it will redirect to your site‚Äôs [404 page](/en/basics/astro-pages/#custom-404-error-page). src/pages/methods.json.ts ```ts export const GET = (({ params, request }) => { return new Response( JSON.stringify({ message: "This was a GET!", }), ); }) satisfies APIRoute; export const POST = (({ request }) => { return new Response( JSON.stringify({ message: "This was a POST!", }), ); }) satisfies APIRoute; export const DELETE = (({ request }) => { return new Response( JSON.stringify({ message: "This was a DELETE!", }), ); }) satisfies APIRoute; export const ALL = (({ request }) => { return new Response( JSON.stringify({ message: `This was a ${request.method}!`, }), ); }) satisfies APIRoute; ``` If you define a `GET` function but no `HEAD` function, Astro will automatically handle `HEAD` requests by calling the `GET` function and stripping the body from the response. ![](/houston_chef.webp) **Related recipes** * [Verify a Captcha](/en/recipes/captcha/) * [Build forms with API routes](/en/recipes/build-forms-api/) ### `request` [Section titled ‚Äúrequest‚Äù](#request-1) In SSR mode, the `request` property returns a fully usable [`Request`](https://developer.mozilla.org/en-US/docs/Web/API/Request) object that refers to the current request. This allows you to accept data and check headers: src/pages/test-post.json.ts ```ts export const POST = (async ({ request }) => { if (request.headers.get("Content-Type") === "application/json") { const body = await request.json(); const name = body.name; return new Response( JSON.stringify({ message: "Your name was: " + name, }), { status: 200, }, ); } return new Response(null, { status: 400 }); }) satisfies APIRoute; ``` ### Redirects [Section titled ‚ÄúRedirects‚Äù](#redirects) The endpoint context exports a `redirect()` utility similar to `Astro.redirect`: src/pages/links/\[id].js ```js import { getLinkUrl } from "../db"; export async function GET({ params, redirect }) { const { id } = params; const link = await getLinkUrl(id); if (!link) { return new Response(null, { status: 404, statusText: "Not found", }); } return redirect(link, 307); } ```

# Using environment variables

> Learn how to use environment variables in an Astro project.

Astro gives you access to [Vite‚Äôs built-in environment variables support](#vites-built-in-support) and includes some [default environment variables for your project](#default-environment-variables) that allow you to access configuration values for your current project (e.g. `site`, `base`), whether your project is running in development or production, and more. Astro also provides a way to [use and organize your environment variables with type safety](#type-safe-environment-variables). It is available for use inside the Astro context (e.g. Astro components, routes and endpoints, UI framework components, middleware), and managed with [a schema in your Astro configuration](/en/reference/configuration-reference/#env). ## Vite‚Äôs built-in support [Section titled ‚ÄúVite‚Äôs built-in support‚Äù](#vites-built-in-support) Astro uses Vite‚Äôs built-in support for environment variables, which are statically replaced at build time, and lets you [use any of its methods](https://vite.dev/guide/env-and-mode.html) to work with them. Note that while *all* environment variables are available in server-side code, only environment variables prefixed with `PUBLIC_` are available in client-side code for security purposes. .env ```ini SECRET_PASSWORD=password123 PUBLIC_ANYBODY=there ``` In this example, `PUBLIC_ANYBODY` (accessible via `import.meta.env.PUBLIC_ANYBODY`) will be available in server or client code, while `SECRET_PASSWORD` (accessible via `import.meta.env.SECRET_PASSWORD`) will be server-side only. Caution `.env` files are not loaded inside [configuration files](#in-the-astro-config-file). ### IntelliSense for TypeScript [Section titled ‚ÄúIntelliSense for TypeScript‚Äù](#intellisense-for-typescript) By default, Astro provides a type definition for `import.meta.env` in `astro/client.d.ts`. While you can define more custom env variables in `.env.[mode]` files, you may want to get TypeScript IntelliSense for user-defined env variables which are prefixed with `PUBLIC_`. To achieve this, you can create an `env.d.ts` in `src/` to [extend the global types](/en/guides/typescript/#extending-global-types) and configure `ImportMetaEnv` like this: src/env.d.ts ```ts interface ImportMetaEnv { readonly DB_PASSWORD: string; readonly PUBLIC_POKEAPI: string; // more env variables... } interface ImportMeta { readonly env: ImportMetaEnv; } ``` ## Default environment variables [Section titled ‚ÄúDefault environment variables‚Äù](#default-environment-variables) Astro includes a few environment variables out of the box: * `import.meta.env.MODE`: The mode your site is running in. This is `development` when running `astro dev` and `production` when running `astro build`. * `import.meta.env.PROD`: `true` if your site is running in production; `false` otherwise. * `import.meta.env.DEV`: `true` if your site is running in development; `false` otherwise. Always the opposite of `import.meta.env.PROD`. * `import.meta.env.BASE_URL`: The base URL your site is being served from. This is determined by the [`base` config option](/en/reference/configuration-reference/#base). * `import.meta.env.SITE`: This is set to [the `site` option](/en/reference/configuration-reference/#site) specified in your project‚Äôs `astro.config`. * `import.meta.env.ASSETS_PREFIX`: The prefix for Astro-generated asset links if the [`build.assetsPrefix` config option](/en/reference/configuration-reference/#buildassetsprefix) is set. This can be used to create asset links not handled by Astro. Use them like any other environment variable. ```ts const isProd = import.meta.env.PROD; const isDev = import.meta.env.DEV; ``` ## Setting environment variables [Section titled ‚ÄúSetting environment variables‚Äù](#setting-environment-variables) ### `.env` files [Section titled ‚Äú.env files‚Äù](#env-files) Environment variables can be loaded from `.env` files in your project directory. Just create a `.env` file in the project directory and add some variables to it. .env ```ini # This will only be available when run on the server! DB_PASSWORD="foobar" # This will be available everywhere! PUBLIC_POKEAPI="https://pokeapi.co/api/v2" ``` You can also add `.production`, `.development` or a custom mode name to the filename itself (e.g `.env.testing`, `.env.staging`). This allows you to use different sets of environment variables at different times. The `astro dev` and `astro build` commands default to `"development"` and `"production"` modes, respectively. You can run these commands with the [`--mode` flag](/en/reference/cli-reference/#--mode-string) to pass a different value for `mode` and load the matching `.env` file. This allows you to run the dev server or build your site connecting to different APIs: * npm ```shell # Run the dev server connected to a "staging" API npm run astro dev -- --mode staging # Build a site that connects to a "production" API with additional debug information npm run astro build -- --devOutput # Build a site that connects to a "testing" API npm run astro build -- --mode testing ``` * pnpm ```shell # Run the dev server connected to a "staging" API pnpm astro dev --mode staging # Build a site that connects to a "production" API with additional debug information pnpm astro build --devOutput # Build a site that connects to a "testing" API pnpm astro build --mode testing ``` * Yarn ```shell # Run the dev server connected to a "staging" API yarn astro dev --mode staging # Build a site that connects to a "production" API with additional debug information yarn astro build --devOutput # Build a site that connects to a "testing" API yarn astro build --mode testing ``` For more on `.env` files, [see the Vite documentation](https://vite.dev/guide/env-and-mode.html#env-files). ### In the Astro config file [Section titled ‚ÄúIn the Astro config file‚Äù](#in-the-astro-config-file) Astro evaluates configuration files before it loads your other files. This means that you cannot use `import.meta.env` in `astro.config.mjs` to access environment variables that were set in `.env` files. You can use `process.env` in a configuration file to access other environment variables, like those [set by the CLI](#using-the-cli). You can also use [Vite‚Äôs `loadEnv` helper](https://main.vite.dev/config/#using-environment-variables-in-config) to manually load `.env` files. astro.config.mjs ```js import { loadEnv } from "vite"; const { SECRET_PASSWORD } = loadEnv(process.env.NODE_ENV, process.cwd(), ""); ``` ### Using the CLI [Section titled ‚ÄúUsing the CLI‚Äù](#using-the-cli) You can also add environment variables as you run your project: * npm ```shell PUBLIC_POKEAPI=https://pokeapi.co/api/v2 npm run dev ``` * pnpm ```shell PUBLIC_POKEAPI=https://pokeapi.co/api/v2 pnpm run dev ``` * Yarn ```shell PUBLIC_POKEAPI=https://pokeapi.co/api/v2 yarn run dev ``` ## Getting environment variables [Section titled ‚ÄúGetting environment variables‚Äù](#getting-environment-variables) Environment variables in Astro are accessed with `import.meta.env`, using the [`import.meta` feature added in ES2020](https://tc39.es/ecma262/2020/#prod-ImportMeta), instead of `process.env`. For example, use `import.meta.env.PUBLIC_POKEAPI` to get the `PUBLIC_POKEAPI` environment variable. ```js // When import.meta.env.SSR === true const data = await db(import.meta.env.DB_PASSWORD); // When import.meta.env.SSR === false const data = fetch(`${import.meta.env.PUBLIC_POKEAPI}/pokemon/squirtle`); ``` When using SSR, environment variables can be accessed at runtime based on the SSR adapter being used. With most adapters you can access environment variables with `process.env`, but some adapters work differently. For the Deno adapter, you will use `Deno.env.get()`. See how to [access the Cloudflare runtime](/en/guides/integrations-guide/cloudflare/#cloudflare-runtime) to handle environment variables when using the Cloudflare adapter. Astro will first check the server environment for variables, and if they don‚Äôt exist, Astro will look for them in `.env` files. ## Type safe environment variables [Section titled ‚ÄúType safe environment variables‚Äù](#type-safe-environment-variables) The `astro:env` API lets you configure a type-safe schema for [environment variables you have set](#setting-environment-variables). This allows you to indicate whether they should be available on the server or the client, and define their data type and additional properties. Developing an adapter? See how to [make an adapter compatible with `astro:env`](/en/reference/adapter-reference/#envgetsecret). ### Basic Usage [Section titled ‚ÄúBasic Usage‚Äù](#basic-usage) #### Define your schema [Section titled ‚ÄúDefine your schema‚Äù](#define-your-schema) To configure a schema, add the `env.schema` option to your Astro config: astro.config.mjs ```diff import { defineConfig } from "astro/config"; export default defineConfig({ + env: { + schema: { +// ... + } + } }) ``` You can then [register variables as a string, number, enum, or boolean](#data-types) using the `envField` helper. Define the [kind of environment variable](#variable-types) by providing a `context` (`"client"` or `"server"`) and `access` (`"secret"` or `"public"`) for each variable, and pass any additional properties such as `optional` or `default` in an object: astro.config.mjs ```js import { defineConfig, envField } from "astro/config"; export default defineConfig({ env: { schema: { API_URL: envField.string({ context: "client", access: "public", optional: true }), PORT: envField.number({ context: "server", access: "public", default: 4321 }), API_SECRET: envField.string({ context: "server", access: "secret" }), } } }) ``` Types will be generated for you when running `astro dev` or `astro build`, but you can run `astro sync` to generate types only. #### Use variables from your schema [Section titled ‚ÄúUse variables from your schema‚Äù](#use-variables-from-your-schema) Import and use your defined variables from the appropriate `/client` or `/server` module: ```astro --- import { API_URL } from "astro:env/client"; import { API_SECRET_TOKEN } from "astro:env/server"; const data = await fetch(`${API_URL}/users`, { method: "GET", headers: { "Content-Type": "application/json", "Authorization": `Bearer ${API_SECRET_TOKEN}` }, }) --- <script> import { API_URL } from "astro:env/client"; fetch(`${API_URL}/ping`) </script> ``` ### Variable types [Section titled ‚ÄúVariable types‚Äù](#variable-types) There are three kinds of environment variables, determined by the combination of `context` (`"client"` or `"server"`) and `access` (`"secret"` or `"public"`) settings defined in your schema: * **Public client variables**: These variables end up in both your final client and server bundles, and can be accessed from both client and server through the `astro:env/client` module: ```js import { API_URL } from "astro:env/client"; ``` * **Public server variables**: These variables end up in your final server bundle and can be accessed on the server through the `astro:env/server` module: ```js import { PORT } from "astro:env/server"; ``` * **Secret server variables**: These variables are not part of your final bundle and can be accessed on the server through the `astro:env/server` module: ```js import { API_SECRET } from "astro:env/server"; ``` By default, all secrets are validated whenever anything is imported from the `astro:env/server` module. This means, secrets may be validated even when they are not imported. You may need to [pass dummy environment variables](#setting-environment-variables) to satisfy this validation during the build. You can also enable validating secrets on start by [configuring `validateSecrets: true`](/en/reference/configuration-reference/#envvalidatesecrets). ### Data types [Section titled ‚ÄúData types‚Äù](#data-types) There are currently four data types supported: strings, numbers, enums, and booleans: ```js import { envField } from "astro/config"; envField.string({ // context & access optional: true, default: "foo", }) envField.number({ // context & access optional: true, default: 15, }) envField.boolean({ // context & access optional: true, default: true, }) envField.enum({ // context & access values: ["foo", "bar", "baz"], optional: true, default: "baz", }) ``` For a complete list of validation fields, see the [`envField` API reference](/en/reference/configuration-reference/#envschema). ### Retrieving secrets dynamically [Section titled ‚ÄúRetrieving secrets dynamically‚Äù](#retrieving-secrets-dynamically) Despite defining your schema, you may want to retrieve the raw value of a given secret or to retrieve secrets not defined in your schema. In this case, you can use `getSecret()` exported from `astro:env/server`: ```js import { FOO, // boolean getSecret } from "astro:env/server"; getSecret("FOO"); // string | undefined ``` Learn more in [the API reference](/en/reference/modules/astro-env/#getsecret). ### Limitations [Section titled ‚ÄúLimitations‚Äù](#limitations) `astro:env` is a virtual module which means it can only be used inside the Astro context. For example, you can use it in: * Middlewares * Astro routes and endpoints * Astro components * Framework components * Modules You cannot use it in the following and will have to resort to `process.env`: * `astro.config.mjs` * Scripts

# Using custom fonts

> Looking to add some custom typefaces to an Astro website? Use Google Fonts with Fontsource or add a font of your choice.

This guide will show you how to add web fonts to your project and use them in your components. ## Using a local font file [Section titled ‚ÄúUsing a local font file‚Äù](#using-a-local-font-file) This example will demonstrate adding a custom font using the font file `DistantGalaxy.woff`. 1. Add your font file to `public/fonts/`. 2. Add the following `@font-face` statement to your CSS. This could be in a global `.css` file you import, a `<style is:global>` block, or a `<style>` block in a specific layout or component where you want to use this font. ```css /* Register your custom font family and tell the browser where to find it. */ @font-face { font-family: 'DistantGalaxy'; src: url('/fonts/DistantGalaxy.woff') format('woff'); font-weight: normal; font-style: normal; font-display: swap; } ``` 3. Use the `font-family` value from the `@font-face` statement to style elements in your component or layout. In this example, the `<h1>` heading will have the custom font applied, while the paragraph `<p>` will not. src/pages/example.astro ```astro --- --- <h1>In a galaxy far, far away...</h1> <p>Custom fonts make my headings much cooler!</p> <style> h1 { font-family: 'DistantGalaxy', sans-serif; } </style> ``` ## Using Fontsource [Section titled ‚ÄúUsing Fontsource‚Äù](#using-fontsource) The [Fontsource](https://fontsource.org/) project simplifies using Google Fonts and other open-source fonts. It provides npm modules you can install for the fonts you want to use. 1. Find the font you want to use in [Fontsource‚Äôs catalog](https://fontsource.org/). This example will use [Twinkle Star](https://fontsource.org/fonts/twinkle-star). 2. Install the package for your chosen font. * npm ```shell npm install @fontsource/twinkle-star ``` * pnpm ```shell pnpm add @fontsource/twinkle-star ``` * Yarn ```shell yarn add @fontsource/twinkle-star ``` 3. Import the font package in the component where you want to use the font. Usually, you will want to do this in a common layout component to make sure the font is available across your site. The import will automatically add the necessary `@font-face` rules needed to set up the font. src/layouts/BaseLayout.astro ```astro --- import '@fontsource/twinkle-star'; --- ``` 4. Use the font‚Äôs name as shown in the `body` example on its Fontsource page as the `font-family` value. This will work anywhere you can write CSS in your Astro project. ```css h1 { font-family: "Twinkle Star", cursive; } ``` To optimize your website‚Äôs rendering times, you may want to preload fonts that are essential for the initial page display. See the [Fontsource guide to preloading fonts](https://fontsource.org/docs/getting-started/preload) for more information and usage. ## Register fonts in Tailwind [Section titled ‚ÄúRegister fonts in Tailwind‚Äù](#register-fonts-in-tailwind) If you are using [Tailwind](/en/guides/styling/#tailwind), you can use either of the previous methods on this page to install your font, with some modifications. You can either add an [`@font-face` statement for a local font](#using-a-local-font-file) or use [Fontsource‚Äôs `import` strategy](#using-fontsource) to install your font. To register your font in Tailwind: 1. Follow either of the guides above, but skip the final step of adding `font-family` to your CSS. 2. Add the typeface name to `src/styles/global.css`. This example adds `Inter` to the sans-serif font stack. src/styles/global.css ```diff @import 'tailwindcss'; +@theme { +--font-sans: 'Inter', 'sans-serif'; +} ``` Now, all sans-serif text (the default with Tailwind) in your project will use your chosen font and the `font-sans` class will also apply the Inter font. See [Tailwind‚Äôs docs on adding custom font families](https://tailwindcss.com/docs/font-family#using-custom-values) for more information. ## More resources [Section titled ‚ÄúMore resources‚Äù](#more-resources) * Learn how web fonts work in [MDN‚Äôs web fonts guide](https://developer.mozilla.org/en-US/docs/Learn/CSS/Styling_text/Web_fonts). * Generate CSS for your font with [Font Squirrel‚Äôs Webfont Generator](https://www.fontsquirrel.com/tools/webfont-generator).

# Front-end frameworks

> Build your Astro website with React, Svelte, and more.

Build your Astro website without sacrificing your favorite component framework. Create Astro [islands](/en/concepts/islands/) with the UI frameworks of your choice. ## Official front-end framework integrations [Section titled ‚ÄúOfficial front-end framework integrations‚Äù](#official-front-end-framework-integrations) Astro supports a variety of popular frameworks including [React](https://react.dev/), [Preact](https://preactjs.com/), [Svelte](https://svelte.dev/), [Vue](https://vuejs.org/), [SolidJS](https://www.solidjs.com/), and [AlpineJS](https://alpinejs.dev/) with official integrations. Find even more [community-maintained framework integrations](https://astro.build/integrations/?search=\&categories%5B%5D=frameworks) (e.g. Angular, Qwik, Elm) in our integrations directory. ### Front-end frameworks * ![](/logos/alpine-js.svg) ### [@astrojs/‚Äãalpinejs](/en/guides/integrations-guide/alpinejs/) * ![](/logos/preact.svg) ### [@astrojs/‚Äãpreact](/en/guides/integrations-guide/preact/) * ![](/logos/react.svg) ### [@astrojs/‚Äãreact](/en/guides/integrations-guide/react/) * ![](/logos/solid.svg) ### [@astrojs/‚Äãsolid‚Å†-‚Å†js](/en/guides/integrations-guide/solid-js/) * ![](/logos/svelte.svg) ### [@astrojs/‚Äãsvelte](/en/guides/integrations-guide/svelte/) * ![](/logos/vue.svg) ### [@astrojs/‚Äãvue](/en/guides/integrations-guide/vue/) ## Installing integrations [Section titled ‚ÄúInstalling integrations‚Äù](#installing-integrations) One or several of these Astro integrations can be installed and configured in your project. See the [Integrations Guide](/en/guides/integrations-guide/) for more details on installing and configuring Astro integrations. ## Using framework components [Section titled ‚ÄúUsing framework components‚Äù](#using-framework-components) Use your JavaScript framework components in your Astro pages, layouts and components just like Astro components! All your components can live together in `/src/components`, or can be organized in any way you like. To use a framework component, import it from its relative path in your Astro component script. Then, use the component alongside other components, HTML elements and JSX-like expressions in the component template. src/pages/static-components.astro ```diff --- +import MyReactComponent from '../components/MyReactComponent.jsx'; --- <html> <body> <h1>Use React components directly in Astro!</h1> +<MyReactComponent /> </body> </html> ``` By default, your framework components will only render on the server, as static HTML. This is useful for templating components that are not interactive and avoids sending any unnecessary JavaScript to the client. ## Hydrating interactive components [Section titled ‚ÄúHydrating interactive components‚Äù](#hydrating-interactive-components) A framework component can be made interactive (hydrated) using a [`client:*` directive](/en/reference/directives-reference/#client-directives). These are component attributes that determine when your component‚Äôs JavaScript should be sent to the browser. With all client directives except `client:only`, your component will first render on the server to generate static HTML. Component JavaScript will be sent to the browser according to the directive you chose. The component will then hydrate and become interactive. src/pages/interactive-components.astro ```astro --- // Example: hydrating framework components in the browser. import InteractiveButton from '../components/InteractiveButton.jsx'; import InteractiveCounter from '../components/InteractiveCounter.jsx'; import InteractiveModal from '../components/InteractiveModal.svelte'; --- <!-- This component's JS will begin importing when the page loads --> <InteractiveButton client:load /> <!-- This component's JS will not be sent to the client until the user scrolls down and the component is visible on the page --> <InteractiveCounter client:visible /> <!-- This component won't render on the server, but will render on the client when the page loads --> <InteractiveModal client:only="svelte" /> ``` The JavaScript framework (React, Svelte, etc.) needed to render the component will be sent to the browser along with the component‚Äôs own JavaScript. If two or more components on a page use the same framework, the framework will only be sent once. ### Available hydration directives [Section titled ‚ÄúAvailable hydration directives‚Äù](#available-hydration-directives) There are several hydration directives available for UI framework components: `client:load`, `client:idle`, `client:visible`, `client:media={QUERY}` and `client:only={FRAMEWORK}`. See our [directives reference](/en/reference/directives-reference/#client-directives) page for a full description of these hydration directives, and their usage. ## Mixing frameworks [Section titled ‚ÄúMixing frameworks‚Äù](#mixing-frameworks) You can import and render components from multiple frameworks in the same Astro component. src/pages/mixing-frameworks.astro ```astro --- // Example: Mixing multiple framework components on the same page. import MyReactComponent from '../components/MyReactComponent.jsx'; import MySvelteComponent from '../components/MySvelteComponent.svelte'; import MyVueComponent from '../components/MyVueComponent.vue'; --- <div> <MySvelteComponent /> <MyReactComponent /> <MyVueComponent /> </div> ``` Astro will recognize and render your component based on its file extension. To distinguish between frameworks that use the same file extension, [additional configuration when rendering multiple JSX frameworks](/en/guides/integrations-guide/react/#combining-multiple-jsx-frameworks) (e.g. React and Preact) is required. Caution Only **Astro** components (`.astro`) can contain components from multiple frameworks. ## Passing props to framework components [Section titled ‚ÄúPassing props to framework components‚Äù](#passing-props-to-framework-components) You can pass props from Astro components to framework components: src/pages/frameworks-props.astro ```astro --- import TodoList from '../components/TodoList.jsx'; import Counter from '../components/Counter.svelte'; --- <div> <TodoList initialTodos={["learn Astro", "review PRs"]} /> <Counter startingCount={1} /> </div> ``` Props that are passed to interactive framework components [using a `client:*` directive](/en/reference/directives-reference/#client-directives) must be [serialized](https://developer.mozilla.org/en-US/docs/Glossary/Serialization): translated into a format suitable for transfer over a network, or storage. However, Astro does not serialize every type of data structure. Therefore, there are some limitations on what can be passed as props to hydrated components. The following prop types are supported: plain object, `number`, `string`, `Array`, `Map`, `Set`, `RegExp`, `Date`, `BigInt`, `URL`, `Uint8Array`, `Uint16Array`, `Uint32Array`, and `Infinity` Non-supported data structures passed to components, such as functions, can only be used during the component‚Äôs server rendering and cannot be used to provide interactivity. For example, passing functions to hydrated components is not supported because Astro cannot pass functions from the server in a way that makes them executable on the client. ## Passing children to framework components [Section titled ‚ÄúPassing children to framework components‚Äù](#passing-children-to-framework-components) Inside of an Astro component, you **can** pass children to framework components. Each framework has its own patterns for how to reference these children: React, Preact, and Solid all use a special prop named `children`, while Svelte and Vue use the `<slot />` element. src/pages/component-children.astro ```astro --- import MyReactSidebar from '../components/MyReactSidebar.jsx'; --- <MyReactSidebar> <p>Here is a sidebar with some text and a button.</p> </MyReactSidebar> ``` Additionally, you can use [Named Slots](/en/basics/astro-components/#named-slots) to group specific children together. For React, Preact, and Solid, these slots will be converted to a top-level prop. Slot names using `kebab-case` will be converted to `camelCase`. src/pages/named-slots.astro ```astro --- import MySidebar from '../components/MySidebar.jsx'; --- <MySidebar> <h2 slot="title">Menu</h2> <p>Here is a sidebar with some text and a button.</p> <ul slot="social-links"> <li><a href="https://twitter.com/astrodotbuild">Twitter</a></li> <li><a href="https://github.com/withastro">GitHub</a></li> </ul> </MySidebar> ``` src/components/MySidebar.jsx ```jsx export default function MySidebar(props) { return ( <aside> <header>{props.title}</header> <main>{props.children}</main> <footer>{props.socialLinks}</footer> </aside> ) } ``` For Svelte and Vue these slots can be referenced using a `<slot>` element with the `name` attribute. Slot names using `kebab-case` will be preserved. src/components/MySidebar.svelte ```jsx <aside> <header><slot name="title" /></header> <main><slot /></main> <footer><slot name="social-links" /></footer> </aside> ``` ## Nesting framework components [Section titled ‚ÄúNesting framework components‚Äù](#nesting-framework-components) Inside of an Astro file, framework component children can also be hydrated components. This means that you can recursively nest components from any of these frameworks. src/pages/nested-components.astro ```astro --- import MyReactSidebar from '../components/MyReactSidebar.jsx'; import MyReactButton from '../components/MyReactButton.jsx'; import MySvelteButton from '../components/MySvelteButton.svelte'; --- <MyReactSidebar> <p>Here is a sidebar with some text and a button.</p> <div slot="actions"> <MyReactButton client:idle /> <MySvelteButton client:idle /> </div> </MyReactSidebar> ``` Caution Remember: framework component files themselves (e.g. `.jsx`, `.svelte`) cannot mix multiple frameworks. This allows you to build entire ‚Äúapps‚Äù in your preferred JavaScript framework and render them, via a parent component, to an Astro page. ## Can I use Astro components inside my framework components? [Section titled ‚ÄúCan I use Astro components inside my framework components?‚Äù](#can-i-use-astro-components-inside-my-framework-components) Any UI framework component becomes an ‚Äúisland‚Äù of that framework. These components must be written entirely as valid code for that framework, using only its own imports and packages. You cannot import `.astro` components in a UI framework component (e.g. `.jsx` or `.svelte`). You can, however, use [the Astro `<slot />` pattern](/en/basics/astro-components/#slots) to pass static content generated by Astro components as children to your framework components **inside an `.astro` component**. src/pages/astro-children.astro ```astro --- import MyReactComponent from '../components/MyReactComponent.jsx'; import MyAstroComponent from '../components/MyAstroComponent.astro'; --- <MyReactComponent> <MyAstroComponent slot="name" /> </MyReactComponent> ``` ## Can I hydrate Astro components? [Section titled ‚ÄúCan I hydrate Astro components?‚Äù](#can-i-hydrate-astro-components) If you try to hydrate an Astro component with a `client:` modifier, you will get an error. [Astro components](/en/basics/astro-components/) are HTML-only templating components with no client-side runtime. But, you can use a `<script>` tag in your Astro component template to send JavaScript to the browser that executes in the global scope. Learn more about [client-side `<script>` tags in Astro components](/en/guides/client-side-scripts/)

# Images

> Learn how to use images in Astro.

Astro provides several ways for you to use images on your site, whether they are stored locally inside your project, linked to from an external URL, or managed in a CMS or CDN. Astro provides built-in [`<Image />`](#image-) and [`<Picture />`](#picture-) Astro components, [Markdown image syntax](#images-in-markdown-files) (`![]()`) processing, [SVG components](#svg-components), and [an image generating function](#generating-images-with-getimage) to optimize and/or transform your images. Additionally, you can configure [automatically resizing responsive images](#responsive-image-behavior) by default, or set responsive properties on individual image and picture components. You can always choose to use images and SVG files using native HTML elements in `.astro` or Markdown files, or the standard way for your file type (e.g. `<img />` in MDX and JSX). However, Astro does not perform any processing or optimization of these images. There is also no native video support in Astro, and we recommend choosing a [hosted video service](/en/guides/media/) to handle the demands of optimizing and streaming video content. See the full API reference for the [`<Image />`](/en/reference/modules/astro-assets/#image-) and [`<Picture />`](/en/reference/modules/astro-assets/#picture-) components. ## Where to store images [Section titled ‚ÄúWhere to store images‚Äù](#where-to-store-images) ### `src/` vs `public/` [Section titled ‚Äúsrc/ vs public/‚Äù](#src-vs-public) We recommend that local images are kept in `src/` when possible so that Astro can transform, optimize, and bundle them. Files in the `public/` directory are always served or copied into the build folder as-is, with no processing. Your local images stored in `src/` can be used by all files in your project: `.astro`, `.md`, `.mdx`, `.mdoc`, and other UI frameworks as file imports. Images can be stored in any folder, including alongside your content. Store your images in the `public/` folder if you want to avoid any processing. These images are available to your project files as URL paths on your domain and allow you to have a direct public link to them. For example, your site favicon will commonly be placed in the root of this folder where browsers can identify it. ### Remote images [Section titled ‚ÄúRemote images‚Äù](#remote-images) You can also choose to store your images remotely, in a [content management system (CMS)](/en/guides/cms/) or [digital asset management (DAM)](/en/guides/media/) platform. Astro can fetch your data remotely using APIs or display images from their full URL path. For extra protection when dealing with external sources, Astro‚Äôs image components and helper function will only process (e.g. optimize, transform) images from [authorized image sources specified in your configuration](#authorizing-remote-images). Remote images from other sources will be displayed with no processing. ## Images in `.astro` files [Section titled ‚ÄúImages in .astro files‚Äù](#images-in-astro-files) **Options:** `<Image />`, `<Picture />`, `<img>`, `<svg>`, SVG components Astro‚Äôs templating language allows you to render optimized images with the Astro [`<Image />`](/en/reference/modules/astro-assets/#image-) component and generate multiple sizes and formats with the Astro [`<Picture />`](/en/reference/modules/astro-assets/#picture-) component. Both components also accept [responsive image properties](#responsive-image-behavior) for resizing based on container size and responding to device screen size and resolution. Additionally, you can import and use [SVG files as Astro components](#svg-components) in `.astro` components. All native HTML tags, including `<img>` and `<svg>`, are also available in `.astro` components. [Images rendered with HTML tags](#display-unprocessed-images-with-the-html-img-tag) will not be processed (e.g. optimized, transformed) and will be copied into your build folder as-is. For all images in `.astro` files, **the value of the image `src` attribute is determined by the location of your image file**: * A local image from your project `src/` folder uses an import from the file‚Äôs relative path. The image and picture components use the named import directly (e.g. `src={rocket}`), while the `<img>` tag uses the `src` object property of the import (e.g. `src={rocket.src}`). * Remote and `public/` images use a URL path. Provide a full URL for remote images (e.g. `src="https://www.example.com/images/my-remote-image.jpg"`), or a relative URL path on your site that corresponds to your file‚Äôs location in your `public/` folder (e.g. `src="/images/my-public-image.jpg"` for an image located in `public/images/my-public-image.jpg`). src/pages/blog/my-images.astro ```astro --- import { Image } from 'astro:assets'; import localBirdImage from '../../images/subfolder/localBirdImage.png'; --- <Image src={localBirdImage} alt="A bird sitting on a nest of eggs." /> <Image src="/images/bird-in-public-folder.jpg" alt="A bird." width="50" height="50" /> <Image src="https://example.com/remote-bird.jpg" alt="A bird." width="50" height="50" /> <img src={localBirdImage.src} alt="A bird sitting on a nest of eggs."> <img src="/images/bird-in-public-folder.jpg" alt="A bird."> <img src="https://example.com/remote-bird.jpg" alt="A bird."> ``` See the full API reference for the [`<Image />`](/en/reference/modules/astro-assets/#image-) and [`<Picture />`](/en/reference/modules/astro-assets/#picture-) components including required and optional properties. ![](/houston_chef.webp) **Related recipe:** [Dynamically import images](/en/recipes/dynamically-importing-images/) ## Images in Markdown files [Section titled ‚ÄúImages in Markdown files‚Äù](#images-in-markdown-files) **Options:** `![]()`, `<img>` (with public or remote images) Use standard Markdown `![alt](src)` syntax in your `.md` files. Your local images stored in `src/` and remote images will be processed and optimized. When you [configure responsive images globally](/en/reference/configuration-reference/#imagelayout), these images will also be [responsive](#responsive-image-behavior). Images stored in the `public/` folder are never optimized. src/pages/post-1.md ```md # My Markdown Page <!-- Local image stored in src/assets/ --> <!-- Use a relative file path or import alias --> ![A starry night sky.](../assets/stars.png) <!-- Image stored in public/images/ --> <!-- Use the file path relative to public/ --> ![A starry night sky.](/images/stars.png) <!-- Remote image on another server --> <!-- Use the full URL of the image --> ![Astro](https://example.com/images/remote-image.png) ``` The HTML `<img>` tag can also be used to display images stored in `public/` or remote images without any image optimization or processing. However, `<img>` is not supported for your local images in `src`. The `<Image />` and `<Picture />` components are unavailable in `.md` files. If you require more control over your image attributes, we recommend using [Astro‚Äôs MDX integration](/en/guides/integrations-guide/mdx/) to add support for `.mdx` file format. MDX allows additional [image options available in MDX](#images-in-mdx-files), including combining components with Markdown syntax. ## Images in MDX files [Section titled ‚ÄúImages in MDX files‚Äù](#images-in-mdx-files) **Options:** `<Image />`, `<Picture />`, `<img />`, `![]()`, SVG components You can use Astro‚Äôs `<Image />` and `<Picture />` components in your `.mdx` files by importing both the component and your image. Use them just as they are [used in `.astro` files](#images-in-astro-files). The JSX `<img />` tag is also supported for unprocessed images and [uses the same image import as the HTML `<img>` tag](#display-unprocessed-images-with-the-html-img-tag). Additionally, there is support for [standard Markdown `![alt](src)` syntax](#images-in-markdown-files) with no import required. src/pages/post-1.mdx ```mdx --- title: My Page title --- import { Image } from 'astro:assets'; import rocket from '../assets/rocket.png'; # My MDX Page // Local image stored in the the same folder ![Houston in the wild](houston.png) // Local image stored in src/assets/ <Image src={rocket} alt="A rocketship in space." /> <img src={rocket.src} alt="A rocketship in space." /> ![A rocketship in space](../assets/rocket.png) // Image stored in public/images/ <Image src="/images/stars.png" alt="A starry night sky." /> <img src="/images/stars.png" alt="A starry night sky." /> ![A starry night sky.](/images/stars.png) // Remote image on another server <Image src="https://example.com/images/remote-image.png" /> <img src="https://example.com/images/remote-image.png" /> ![Astro](https://example.com/images/remote-image.png) ``` See the full API reference for the [`<Image />`](/en/reference/modules/astro-assets/#image-) and [`<Picture />`](/en/reference/modules/astro-assets/#picture-) components. ## Images in UI framework components [Section titled ‚ÄúImages in UI framework components‚Äù](#images-in-ui-framework-components) **Image options:** the framework‚Äôs own image syntax (e.g. `<img />` in JSX, `<img>` in Svelte) [Local images must first be imported](#display-unprocessed-images-with-the-html-img-tag) to access their image properties such as `src`. Then, they can be rendered as you normally would in that framework‚Äôs own image syntax: src/components/ReactImage.jsx ```jsx import stars from "../assets/stars.png"; export default function ReactImage() { return ( <img src={stars.src} alt="A starry night sky." /> ) } ``` src/components/SvelteImage.svelte ```svelte <script> import stars from '../assets/stars.png'; </script> <img src={stars.src} alt="A starry night sky." /> ``` Astro components (e.g. `<Image />`, `<Picture />`, SVG components) are unavailable inside UI framework components because [a client island must contain only valid code for its own framework](/en/guides/framework-components/#can-i-use-astro-components-inside-my-framework-components). But, you can pass the static content generated by these components to a framework component inside a `.astro` file [as children](/en/guides/framework-components/#passing-children-to-framework-components) or using a [named `<slot/>`](/en/guides/framework-components/#can-i-use-astro-components-inside-my-framework-components): src/components/ImageWrapper.astro ```astro --- import ReactComponent from './ReactComponent.jsx'; import { Image } from 'astro:assets'; import stars from '~/stars/docline.png'; --- <ReactComponent> <Image src={stars} alt="A starry night sky." /> </ReactComponent> ``` ## Astro components for images [Section titled ‚ÄúAstro components for images‚Äù](#astro-components-for-images) Astro provides two built-in Astro components for images (`<Image />` and `<Picture />`) and also allows you to import SVG files and use them as Astro components. These components may be used in any files that can import and render `.astro` components. ### `<Image />` [Section titled ‚Äú\<Image />‚Äù](#image-) Use the built-in `<Image />` Astro component to display optimized versions of: * your local images located within the `src/` folder * [configured remote images](#authorizing-remote-images) from authorized sources `<Image />` can transform a local or authorized remote image‚Äôs dimensions, file type, and quality for control over your displayed image. This transformation happens at build time for prerendered pages. When your page is rendered on demand, this transformation will occur on the fly when the page is viewed. The resulting `<img>` tag includes `alt`, `loading`, and `decoding` attributes and infers image dimensions to avoid Cumulative Layout Shift (CLS). src/components/MyComponent.astro ```astro --- // import the Image component and the image import { Image } from 'astro:assets'; import myImage from '../assets/my_image.png'; // Image is 1600x900 --- <!-- `alt` is mandatory on the Image component --> <Image src={myImage} alt="A description of my image." /> ``` ```html <!-- Prerendered output --> <!-- Image is optimized, proper attributes are enforced --> <img src="/_astro/my_image.hash.webp" width="1600" height="900" decoding="async" loading="lazy" alt="A description of my image." /> <!-- Output rendered on demand--> <!-- src will use an endpoint generated on demand--> <img src="/_image?href=%2F_astro%2Fmy_image.hash.webp&amp;w=1600&amp;h=900&amp;f=webp" <!-- ... --> /> ``` The `<Image />` component accepts [several component properties](/en/reference/modules/astro-assets/#image-) as well as any attributes accepted by the HTML `<img>` tag. The following example provides a `class` to the image component which will apply to the final `<img>` element. src/pages/index.astro ```astro --- import { Image } from 'astro:assets'; import myImage from '../assets/my_image.png'; --- <!-- `alt` is mandatory on the Image component --> <Image src={myImage} alt="" class="my-class" /> ``` ```html <!-- Prerendered output --> <img src="/_astro/my_image.hash.webp" width="1600" height="900" decoding="async" loading="lazy" class="my-class" alt="" /> ``` ### `<Picture />` [Section titled ‚Äú\<Picture />‚Äù](#picture-) **Added in:** `astro@3.3.0` Use the built-in `<Picture />` Astro component to generate a `<picture>` tag with multiple formats and/or sizes of your image. This allows you to specify preferred file formats to display and at the same time, provide a fallback format. Like the [`<Image />` component](#image-), images will be processed at build time for prerendered pages. When your page is rendered on demand, processing will occur on the fly when the page is viewed. The following example uses the `<Picture />` component to transform a local `.png` file into a web-friendly `avif` and `webp` format as well as the `.png` `<img>` that can be displayed as a fallback when needed: src/pages/index.astro ```astro --- import { Picture } from 'astro:assets'; import myImage from '../assets/my_image.png'; // Image is 1600x900 --- <!-- `alt` is mandatory on the Picture component --> <Picture src={myImage} formats={['avif', 'webp']} alt="A description of my image." /> ``` ```html <!-- Prerendered output --> <picture> <source srcset="/_astro/my_image.hash.avif" type="image/avif" /> <source srcset="/_astro/my_image.hash.webp" type="image/webp" /> <img src="/_astro/my_image.hash.png" width="1600" height="900" decoding="async" loading="lazy" alt="A description of my image." /> </picture> ``` See details about [the `<Picture />` component properties](/en/reference/modules/astro-assets/#picture-) in the `astro:assets` reference. ### Responsive image behavior [Section titled ‚ÄúResponsive image behavior‚Äù](#responsive-image-behavior) **Added in:** `astro@5.10.0` Responsive images are images that adjust to improve performance across different devices. These images can resize to fit their container, and can be served in different sizes depending on your visitor‚Äôs screen size and resolution. With [responsive image properties](/en/reference/modules/astro-assets/#responsive-image-properties) applied to the `<Image />` or `<Picture />` components, Astro will automatically generate the required `srcset` and `sizes` values for your images, and apply the necessary [styles to ensure they resize correctly](#responsive-image-styles). When this responsive behavior is [configured globally with `image.layout`](/en/reference/configuration-reference/#imagelayout), it will apply to all image components and also to any local and remote images using [the Markdown `![]()` syntax](/en/guides/images/#images-in-markdown-files). Images in your `public/` folder are never optimized, and responsive images are not supported. Read more about [responsive images on MDN web docs](https://developer.mozilla.org/en-US/docs/Web/HTML/Guides/Responsive_images). #### Generated HTML output for responsive images [Section titled ‚ÄúGenerated HTML output for responsive images‚Äù](#generated-html-output-for-responsive-images) When a layout is set, either by default or on an individual component, images have automatically generated `srcset` and `sizes` attributes based on the image‚Äôs dimensions and the layout type. Images with `constrained` and `full-width` layouts will have styles applied to ensure they resize according to their container. src/components/MyComponent.astro ```astro --- import { Image } from 'astro:assets'; import myImage from '../assets/my_image.png'; --- <Image src={myImage} alt="A description of my image." layout='constrained' width={800} height={600} /> ``` This `<Image />` component will generate the following HTML output on a prerendered page: ```html <img src="/_astro/my_image.hash3.webp" srcset="/_astro/my_image.hash1.webp 640w, /_astro/my_image.hash2.webp 750w, /_astro/my_image.hash3.webp 800w, /_astro/my_image.hash4.webp 828w, /_astro/my_image.hash5.webp 1080w, /_astro/my_image.hash6.webp 1280w, /_astro/my_image.hash7.webp 1600w" alt="A description of my image" sizes="(min-width: 800px) 800px, 100vw" loading="lazy" decoding="async" fetchpriority="auto" width="800" height="600" style="--fit: cover; --pos: center;" data-astro-image="constrained" > ``` #### Responsive image styles [Section titled ‚ÄúResponsive image styles‚Äù](#responsive-image-styles) Setting [`image.responsiveStyles: true`](/en/reference/configuration-reference/#imageresponsivestyles) applies a small number of global styles to ensure that your images resize correctly. In most cases, you will want to enable these as a default; your images will not be responsive without additional styles. However, if you prefer to handle responsive image styling yourself, or need to [override these defaults when using Tailwind 4](#responsive-images-with-tailwind-4), leave the default `false` value configured. The global styles applied by Astro will depend on the layout type, and are designed to produce the best result for the generated `srcset` and `sizes` attributes. These are the default styles: Responsive Image Styles ```css :where([data-astro-image]) { object-fit: var(--fit); object-position: var(--pos); } :where([data-astro-image='full-width']) { width: 100%; } :where([data-astro-image='constrained']) { max-width: 100%; } ``` The styles use the [`:where()` pseudo-class](https://developer.mozilla.org/en-US/docs/Web/CSS/:where), which has a [specificity](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_cascade/Specificity) of 0, meaning that it is easy to override with your own styles. Any CSS selector will have a higher specificity than `:where()`, so you can easily override the styles by adding your own styles to target the image. You can override the `object-fit` and `object-position` styles on a per-image basis by setting the `fit` and `position` props on the `<Image />` or `<Picture />` component. #### Responsive images with Tailwind 4 [Section titled ‚ÄúResponsive images with Tailwind 4‚Äù](#responsive-images-with-tailwind-4) Tailwind 4 is compatible with Astro‚Äôs default responsive styles. However, Tailwind uses [cascade layers](https://developer.mozilla.org/en-US/docs/Web/CSS/@layer), meaning that its rules are always lower specificity than rules that don‚Äôt use layers, including Astro‚Äôs responsive styles. Therefore, Astro‚Äôs styling will take precedence over Tailwind styling. To use Tailwind rules instead of Astro‚Äôs default styling, do not enable [Astro‚Äôs default responsive styles](/en/reference/configuration-reference/#imageresponsivestyles). ### SVG components [Section titled ‚ÄúSVG components‚Äù](#svg-components) **Added in:** `astro@5.7.0` Astro allows you to import SVG files and use them as Astro components. Astro will inline the SVG content into your HTML output. Reference the default import of any local `.svg` file. Since this import is treated as an Astro component, you must use the same conventions (e.g. capitalization) as when [using dynamic tags](/en/reference/astro-syntax/#dynamic-tags). src/components/MyAstroComponent.astro ```astro --- import Logo from './path/to/svg/file.svg'; --- <Logo /> ``` Your SVG component, like `<Image />` or any other Astro component, is unavailable inside UI framework components, but can [be passed to a framework component](#images-in-ui-framework-components) inside a `.astro` component. #### SVG component attributes [Section titled ‚ÄúSVG component attributes‚Äù](#svg-component-attributes) You can pass props such as `width`, `height`, `fill`, `stroke`, and any other attribute accepted by the [native `<svg>` element](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/svg). These attributes will automatically be applied to the underlying `<svg>` element. If a property is present in the original `.svg` file and is passed to the component, the value passed to the component will override the original value. src/components/MyAstroComponent.astro ```astro --- import Logo from '../assets/logo.svg'; --- <Logo width={64} height={64} fill="currentColor" /> ``` #### `SvgComponent` Type [Section titled ‚ÄúSvgComponent Type‚Äù](#svgcomponent-type) **Added in:** `astro@5.14.0` You can also enforce type safety for your `.svg` assets using the `SvgComponent` type: src/components/Logo.astro ```astro --- import type { SvgComponent } from "astro/types"; import HomeIcon from './Home.svg' interface Link { url: string text: string icon: SvgComponent } const links: Link[] = [ { url: '/', text: 'Home', icon: HomeIcon } ] --- ``` ### Creating custom image components [Section titled ‚ÄúCreating custom image components‚Äù](#creating-custom-image-components) You can create a custom, reusable image component by wrapping the `<Image />` or `<Picture/>` component in another Astro component. This allows you to set default attributes and styles only once. For example, you could create a component for your blog post images that receives attributes as props and applies consistent styles to each image: src/components/BlogPostImage.astro ```astro --- import { Image } from 'astro:assets'; const { src, ...attrs } = Astro.props; --- <Image src={src} {...attrs} /> <style> img { margin-block: 2.5rem; border-radius: 0.75rem; } </style> ``` ## Display unprocessed images with the HTML `<img>` tag [Section titled ‚ÄúDisplay unprocessed images with the HTML \<img> tag‚Äù](#display-unprocessed-images-with-the-html-img-tag) The [Astro template syntax](/en/reference/astro-syntax/) also supports writing an `<img>` tag directly, with full control over its final output. These images will not be processed and optimized. It accepts all HTML `<img>` tag properties, and the only required property is `src`. However, it is strongly recommended to include [the `alt` property for accessibility](#alt-text). ### images in `src/` [Section titled ‚Äúimages in src/‚Äù](#images-in-src) Local images must be imported from the relative path from the existing `.astro` file, or you can configure and use an [import alias](/en/guides/imports/#aliases). Then, you can access the image‚Äôs `src` and other properties to use in the `<img>` tag. Imported image assets match the [`ImageMetadata` type](/en/reference/modules/astro-assets/#imagemetadata-1) and have the following signature: ```ts interface ImageMetadata { src: string; width: number; height: number; format: string; } ``` The following example uses the image‚Äôs own `height` and `width` properties to avoid Cumulative Layout Shift (CLS) and improve Core Web Vitals: src/pages/posts/post-1.astro ```astro --- // import local images import myDog from '../../images/pets/local-dog.jpg'; --- // access the image properties <img src={myDog.src} width={myDog.width} height={myDog.height} alt="A barking dog." /> ``` ### Images in `public/` [Section titled ‚ÄúImages in public/‚Äù](#images-in-public) For images located within `public/` use the image‚Äôs file path relative to the public folder as the `src` value: ```astro <img src="/images/public-cat.jpg" alt="A sleeping cat." > ``` ### Remote images [Section titled ‚ÄúRemote images‚Äù](#remote-images-1) For remote images, use the image‚Äôs full URL as the `src` value: ```astro <img src="https://example.com/remote-cat.jpg" alt="A sleeping cat." > ``` ### Choosing `<Image />` vs `<img>` [Section titled ‚ÄúChoosing \<Image /> vs \<img>‚Äù](#choosing-image--vs-img) The `<Image />` component optimizes your image and infers width and height (for images it can process) based on the original aspect ratio to avoid CLS. It is the preferred way to use images in `.astro` files whenever possible. Use the HTML `<img>` element when you cannot use the `<Image />` component, for example: * for unsupported image formats * when you do not want your image optimized by Astro * to access and change the `src` attribute dynamically client-side ## Using Images from a CMS or CDN [Section titled ‚ÄúUsing Images from a CMS or CDN‚Äù](#using-images-from-a-cms-or-cdn) Image CDNs work with [all Astro image options](#images-in-astro-files). Use an image‚Äôs full URL as the `src` attribute in the `<Image />` component, an `<img>` tag, or in Markdown notation. For image optimization with remote images, also [configure your authorized domains or URL patterns](#authorizing-remote-images). Alternatively, the CDN may provide its own SDKs to more easily integrate in an Astro project. For example, Cloudinary supports an [Astro SDK](https://astro.cloudinary.dev/) which allows you to easily drop in images with their `CldImage` component or a [Node.js SDK](https://cloudinary.com/documentation/node_integration) that can generate URLs to use with an `<img>` tag in a Node.js environment. See the full API reference for the [`<Image />`](/en/reference/modules/astro-assets/#image-) and [`<Picture />`](/en/reference/modules/astro-assets/#picture-) components. ## Authorizing remote images [Section titled ‚ÄúAuthorizing remote images‚Äù](#authorizing-remote-images) You can configure lists of authorized image source URL domains and patterns for image optimization using [`image.domains`](/en/reference/configuration-reference/#imagedomains) and [`image.remotePatterns`](/en/reference/configuration-reference/#imageremotepatterns). This configuration is an extra layer of safety to protect your site when showing images from an external source. Remote images from other sources will not be optimized, but using the `<Image />` component for these images will prevent Cumulative Layout Shift (CLS). For example, the following configuration will only allow remote images from `astro.build` to be optimized: astro.config.mjs ```ts export default defineConfig({ image: { domains: ["astro.build"], } }); ``` The following configuration will only allow remote images from HTTPS hosts: astro.config.mjs ```ts export default defineConfig({ image: { remotePatterns: [{ protocol: "https" }], } }); ``` ## Images in content collections [Section titled ‚ÄúImages in content collections‚Äù](#images-in-content-collections) You can declare an associated image for a content collections entry, such as a blog post‚Äôs cover image, in your frontmatter using its path relative to the current folder: src/content/blog/my-post.md ```md --- title: "My first blog post" cover: "./firstpostcover.jpeg" # will resolve to "src/content/blog/firstblogcover.jpeg" coverAlt: "A photograph of a sunset behind a mountain range." --- This is a blog post ``` The `image` helper for the content collections schema lets you validate and import the image. src/content.config.ts ```ts import { defineCollection } from "astro:content"; import { z } from "astro/zod"; const blogCollection = defineCollection({ schema: ({ image }) => z.object({ title: z.string(), cover: image(), coverAlt: z.string(), }), }); export const collections = { blog: blogCollection, }; ``` The image will be imported and transformed into metadata, allowing you to pass it as a `src` to `<Image/>`, `<img>`, or `getImage()` in an Astro component. The example below shows a blog index page that renders the cover photo and title of each blog post from the previous schema: src/pages/blog.astro ```astro --- import { Image } from "astro:assets"; import { getCollection } from "astro:content"; const allBlogPosts = await getCollection("blog"); --- { allBlogPosts.map((post) => ( <div> <Image src={post.data.cover} alt={post.data.coverAlt} /> <h2> <a href={"/blog/" + post.slug}>{post.data.title}</a> </h2> </div> )) } ``` ## Generating images with `getImage()` [Section titled ‚ÄúGenerating images with getImage()‚Äù](#generating-images-with-getimage) The `getImage()` function is intended for generating images destined to be used somewhere else than directly in HTML, for example in an [API Route](/en/guides/endpoints/#server-endpoints-api-routes). When you need options that the `<Picture>` and `<Image>` components do not currently support, you can use the `getImage()` function to create your own custom `<Image />` component. See more in the [`getImage()` reference](/en/reference/modules/astro-assets/#getimage). ![](/houston_chef.webp) **Related recipe:** [Build a custom image component](/en/recipes/build-custom-img-component/) ## Alt Text [Section titled ‚ÄúAlt Text‚Äù](#alt-text) Not all users can see images in the same way, so accessibility is an especially important concern when using images. Use the `alt` attribute to provide [descriptive alt text](https://www.w3.org/WAI/tutorials/images/) for images. This attribute is required for both the `<Image />` and `<Picture />` components. If no alt text is provided, a helpful error message will be provided reminding you to include the `alt` attribute. If the image is merely decorative (i.e. doesn‚Äôt contribute to the understanding of the page), set `alt=""` so that screen readers know to ignore the image. ## Default image service [Section titled ‚ÄúDefault image service‚Äù](#default-image-service) [Sharp](https://github.com/lovell/sharp) is the default image service used for `astro:assets`. You can further configure the image service using the [`image.service`](/en/reference/configuration-reference/#imageservice) option. ### Configure no-op passthrough service [Section titled ‚ÄúConfigure no-op passthrough service‚Äù](#configure-no-op-passthrough-service) If your [adapter](https://astro.build/integrations/?search=\&categories%5B%5D=adapters) does not support Astro‚Äôs built-in Sharp image optimization (e.g. Deno, Cloudflare), you can configure a no-op image service to allow you to use the `<Image />` and `<Picture />` components. Note that Astro does not perform any image transformation and processing in these environments. However, you can still enjoy the other benefits of using `astro:assets`, including no Cumulative Layout Shift (CLS), the enforced `alt` attribute, and a consistent authoring experience. Configure the `passthroughImageService()` to avoid Sharp image processing: astro.config.mjs ```diff import { defineConfig, passthroughImageService } from 'astro/config'; export default defineConfig({ + image: { + service: passthroughImageService() + } }); ``` ## Asset Caching [Section titled ‚ÄúAsset Caching‚Äù](#asset-caching) Astro stores processed image assets in a cache directory during site builds for both local and [remote images from authorized sources](#authorizing-remote-images). By preserving the cache directory between builds, processed assets are reused, improving build time and bandwidth usage. The default cache directory is `./node_modules/.astro`, however this can be changed using the [`cacheDir`](/en/reference/configuration-reference/#cachedir) configuration setting. ### Remote Images [Section titled ‚ÄúRemote Images‚Äù](#remote-images-2) Remote images in the asset cache are managed based on [HTTP Caching](https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching), and respect the [Cache-Control header](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control) returned by the remote server. Images are cached if the Cache-Control header allows, and will be used until they are no longer [fresh](https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching#fresh_and_stale_based_on_age). #### Revalidation [Section titled ‚ÄúRevalidation‚Äù](#revalidation) **Added in:** `astro@5.1.0` [Revalidation](https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching#validation) reduces bandwidth usage and build time by checking with the remote server whether an expired cached image is still up-to-date. If the server indicates that the image is still fresh, the cached version is reused, otherwise the image is redownloaded. Revalidation requires that the remote server send [Last-Modified](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Last-Modified) and/or [Etag (entity tag)](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag) headers with its responses. This feature is available for remote servers that support the [If-Modified-Since](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/If-Modified-Since) and [If-None-Match](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/If-None-Match) headers. ## Community Integrations [Section titled ‚ÄúCommunity Integrations‚Äù](#community-integrations) There are several third-party [community image integrations](https://astro.build/integrations?search=images) for optimizing and working with images in your Astro project.

# Add Integrations

> Learn how to add integrations to your Astro project.

**Astro integrations** add new functionality and behaviors for your project with only a few lines of code. You can use an official integration, [integrations built by the community](#finding-more-integrations) or even [build a custom integration yourself](#building-your-own-integration). Integrations can‚Ä¶ * Unlock React, Vue, Svelte, Solid, and other popular UI frameworks with a [renderer](/en/guides/framework-components/). * Enable on-demand rendering with an [SSR adapter](/en/guides/on-demand-rendering/). * Integrate tools like MDX, and Partytown with a few lines of code. * Add new features to your project, like automatic sitemap generation. * Write custom code that hooks into the build process, dev server, and more. ## Official Integrations [Section titled ‚ÄúOfficial Integrations‚Äù](#official-integrations) The following integrations are maintained by Astro. ### Front-end frameworks * ![](/logos/alpine-js.svg) ### [@astrojs/‚Äãalpinejs](/en/guides/integrations-guide/alpinejs/) * ![](/logos/preact.svg) ### [@astrojs/‚Äãpreact](/en/guides/integrations-guide/preact/) * ![](/logos/react.svg) ### [@astrojs/‚Äãreact](/en/guides/integrations-guide/react/) * ![](/logos/solid.svg) ### [@astrojs/‚Äãsolid‚Å†-‚Å†js](/en/guides/integrations-guide/solid-js/) * ![](/logos/svelte.svg) ### [@astrojs/‚Äãsvelte](/en/guides/integrations-guide/svelte/) * ![](/logos/vue.svg) ### [@astrojs/‚Äãvue](/en/guides/integrations-guide/vue/) ### Adapters * ![](/logos/cloudflare-pages.svg) ### [@astrojs/‚Äãcloudflare](/en/guides/integrations-guide/cloudflare/) * ![](/logos/netlify.svg) ### [@astrojs/‚Äãnetlify](/en/guides/integrations-guide/netlify/) * ![](/logos/node.svg) ### [@astrojs/‚Äãnode](/en/guides/integrations-guide/node/) * ![](/logos/vercel.svg) ### [@astrojs/‚Äãvercel](/en/guides/integrations-guide/vercel/) ### Other integrations * ![](/logos/db.svg) ### [@astrojs/‚Äãdb](/en/guides/integrations-guide/db/) * ![](/logos/markdoc.svg) ### [@astrojs/‚Äãmarkdoc](/en/guides/integrations-guide/markdoc/) * ![](/logos/mdx.svg) ### [@astrojs/‚Äãmdx](/en/guides/integrations-guide/mdx/) * ![](/logos/partytown.svg) ### [@astrojs/‚Äãpartytown](/en/guides/integrations-guide/partytown/) * ![](/logos/sitemap.svg) ### [@astrojs/‚Äãsitemap](/en/guides/integrations-guide/sitemap/) ## Automatic Integration Setup [Section titled ‚ÄúAutomatic Integration Setup‚Äù](#automatic-integration-setup) Astro includes an `astro add` command to automate the setup of official integrations. Several community plugins can also be added using this command. Please check each integration‚Äôs own documentation to see whether `astro add` is supported, or whether you must [install manually](#manual-installation). Run the `astro add` command using the package manager of your choice and our automatic integration wizard will update your configuration file and install any necessary dependencies. * npm ```shell npx astro add react ``` * pnpm ```shell pnpm astro add react ``` * Yarn ```shell yarn astro add react ``` It‚Äôs even possible to add multiple integrations at the same time! * npm ```shell npx astro add react sitemap partytown ``` * pnpm ```shell pnpm astro add react sitemap partytown ``` * Yarn ```shell yarn astro add react sitemap partytown ``` ### Manual Installation [Section titled ‚ÄúManual Installation‚Äù](#manual-installation) Astro integrations are always added through the `integrations` property in your `astro.config.mjs` file. There are three common ways to import an integration into your Astro project: 1. [Install an npm package integration](#installing-an-npm-package). 2. Import your own integration from a local file inside your project. 3. Write your integration inline, directly in your config file. astro.config.mjs ```js import { defineConfig } from 'astro/config'; import installedIntegration from '@astrojs/vue'; import localIntegration from './my-integration.js'; export default defineConfig({ integrations: [ // 1. Imported from an installed npm package installedIntegration(), // 2. Imported from a local JS file localIntegration(), // 3. An inline object {name: 'namespace:id', hooks: { /* ... */ }}, ] }); ``` Check out the [Integration API](/en/reference/integrations-reference/) reference to learn all of the different ways that you can write an integration. #### Installing an NPM package [Section titled ‚ÄúInstalling an NPM package‚Äù](#installing-an-npm-package) Install an NPM package integration using a package manager, and then update `astro.config.mjs` manually. For example, to install the `@astrojs/sitemap` integration: 1. Install the integration to your project dependencies using your preferred package manager: * npm ```shell npm install @astrojs/sitemap ``` * pnpm ```shell pnpm add @astrojs/sitemap ``` * Yarn ```shell yarn add @astrojs/sitemap ``` 2. Import the integration to your `astro.config.mjs` file, and add it to your `integrations[]` array, along with any configuration options: astro.config.mjs ```diff import { defineConfig } from 'astro/config'; +import sitemap from '@astrojs/sitemap'; export default defineConfig({ // ... integrations: [sitemap()], // ... }); ``` Note that different integrations may have different configuration settings. Read each integration‚Äôs documentation, and apply any necessary config options to your chosen integration in `astro.config.mjs`. ### Custom Options [Section titled ‚ÄúCustom Options‚Äù](#custom-options) Integrations are almost always authored as factory functions that return the actual integration object. This lets you pass arguments and options to the factory function that customize the integration for your project. ```js integrations: [ // Example: Customize your integration with function arguments sitemap({filter: true}) ] ``` ### Toggle an Integration [Section titled ‚ÄúToggle an Integration‚Äù](#toggle-an-integration) Falsy integrations are ignored, so you can toggle integrations on & off without worrying about left-behind `undefined` and boolean values. ```js integrations: [ // Example: Skip building a sitemap on Windows process.platform !== 'win32' && sitemap() ] ``` ## Upgrading Integrations [Section titled ‚ÄúUpgrading Integrations‚Äù](#upgrading-integrations) To upgrade all official integrations at once, run the `@astrojs/upgrade` command. This will upgrade both Astro and all official integrations to their latest versions. ### Automatic Upgrading [Section titled ‚ÄúAutomatic Upgrading‚Äù](#automatic-upgrading) * npm ```shell # Upgrade Astro and official integrations together to latest npx @astrojs/upgrade ``` * pnpm ```shell # Upgrade Astro and official integrations together to latest pnpm dlx @astrojs/upgrade ``` * Yarn ```shell # Upgrade Astro and official integrations together to latest yarn dlx @astrojs/upgrade ``` ### Manual Upgrading [Section titled ‚ÄúManual Upgrading‚Äù](#manual-upgrading) To upgrade one or more integrations manually, use the appropriate command for your package manager. * npm ```shell # Example: upgrade React and Partytown integrations npm install @astrojs/react@latest @astrojs/partytown@latest ``` * pnpm ```shell # Example: upgrade React and Partytown integrations pnpm add @astrojs/react@latest @astrojs/partytown@latest ``` * Yarn ```shell # Example: upgrade React and Partytown integrations yarn add @astrojs/react@latest @astrojs/partytown@latest ``` ## Removing an Integration [Section titled ‚ÄúRemoving an Integration‚Äù](#removing-an-integration) 1. To remove an integration, first uninstall the integration from your project. * npm ```shell npm uninstall @astrojs/react ``` * pnpm ```shell pnpm remove @astrojs/react ``` * Yarn ```shell yarn remove @astrojs/react ``` 2. Next, remove the integration from your `astro.config.*` file: astro.config.mjs ```diff import { defineConfig } from 'astro/config'; -import react from '@astrojs/react'; export default defineConfig({ integrations: [ -react() ] }); ``` ## Finding More Integrations [Section titled ‚ÄúFinding More Integrations‚Äù](#finding-more-integrations) You can find many integrations developed by the community in the [Astro Integrations Directory](https://astro.build/integrations/). Follow links there for detailed usage and configuration instructions. ## Building Your Own Integration [Section titled ‚ÄúBuilding Your Own Integration‚Äù](#building-your-own-integration) Astro‚Äôs Integration API is inspired by Rollup and Vite, and designed to feel familiar to anyone who has ever written a Rollup or Vite plugin before. Check out the [Integration API](/en/reference/integrations-reference/) reference to learn what integrations can do and how to write one yourself.

# @astrojs/alpinejs

> Learn how to use the @astrojs/alpinejs framework integration to extend component support in your Astro project.

This **[Astro integration](/en/guides/integrations-guide/)** adds [Alpine.js](https://alpinejs.dev/) to your project so that you can use Alpine.js anywhere on your page. ## Installation [Section titled ‚ÄúInstallation‚Äù](#installation) Astro includes an `astro add` command to automate the setup of official integrations. If you prefer, you can [install integrations manually](#manual-install) instead. To install `@astrojs/alpinejs`, run the following from your project directory and follow the prompts: * npm ```sh npx astro add alpinejs ``` * pnpm ```sh pnpm astro add alpinejs ``` * Yarn ```sh yarn astro add alpinejs ``` If you run into any issues, [feel free to report them to us on GitHub](https://github.com/withastro/astro/issues) and try the manual installation steps below. ### Manual Install [Section titled ‚ÄúManual Install‚Äù](#manual-install) First, install the `@astrojs/alpinejs` package. * npm ```sh npm install @astrojs/alpinejs ``` * pnpm ```sh pnpm add @astrojs/alpinejs ``` * Yarn ```sh yarn add @astrojs/alpinejs ``` Most package managers will install associated peer dependencies as well. However, if you see a `Cannot find package 'alpinejs'` (or similar) warning when you start up Astro, you‚Äôll need to manually install Alpine.js yourself: * npm ```sh npm install alpinejs @types/alpinejs ``` * pnpm ```sh pnpm add alpinejs @types/alpinejs ``` * Yarn ```sh yarn add alpinejs @types/alpinejs ``` Then, apply the integration to your `astro.config.*` file using the `integrations` property: astro.config.mjs ```diff import { defineConfig } from 'astro/config'; +import alpinejs from '@astrojs/alpinejs'; export default defineConfig({ // ... integrations: [alpinejs()], }); ``` ## Configuration Options [Section titled ‚ÄúConfiguration Options‚Äù](#configuration-options) ### `entrypoint` [Section titled ‚Äúentrypoint‚Äù](#entrypoint) **Type:** `string` **Added in:** `@astrojs/alpinejs@0.4.0` New You can extend Alpine by setting the `entrypoint` option to a root-relative import specifier (e.g. `entrypoint: "/src/entrypoint"`). The default export of this file should be a function that accepts an Alpine instance prior to starting. This allows the use of custom directives, plugins and other customizations for advanced use cases. astro.config.mjs ```js import { defineConfig } from 'astro/config'; import alpinejs from '@astrojs/alpinejs'; export default defineConfig({ // ... integrations: [alpinejs({ entrypoint: '/src/entrypoint' })], }); ``` src/entrypoint.ts ```js import type { Alpine } from 'alpinejs' import intersect from '@alpinejs/intersect' export default (Alpine: Alpine) => { Alpine.plugin(intersect) } ``` ## Usage [Section titled ‚ÄúUsage‚Äù](#usage) Once the integration is installed, you can use [Alpine.js](https://alpinejs.dev/) directives and syntax inside any Astro component. The Alpine.js script is automatically added and enabled on every page of your website so no client directives are needed. Add plugin scripts to the page `<head>`. The following example adds [Alpine‚Äôs Collapse plugin](https://alpinejs.dev/plugins/collapse) to expand and collapse paragraph text: src/pages/index.astro ```diff --- --- <html> <head> <!-- ... --> <script defer src="https://cdn.jsdelivr.net/npm/@alpinejs/collapse@3.x.x/dist/cdn.min.js"></script> </head> <body> <!-- ... --> <div x-data="{ expanded: false }"> <button @click="expanded = ! expanded">Toggle Content</button> <p id="foo" x-show="expanded" x-collapse> Lorem ipsum </p> </div> </body> </html> ``` ## Intellisense for TypeScript [Section titled ‚ÄúIntellisense for TypeScript‚Äù](#intellisense-for-typescript) The `@astrojs/alpine` integration adds `Alpine` to [the global window object](/en/guides/typescript/#window-and-globalthis). For IDE autocompletion, add the following to your `src/env.d.ts`: src/env.d.ts ```ts interface Window { Alpine: import('alpinejs').Alpine; } ``` ## Examples [Section titled ‚ÄúExamples‚Äù](#examples) * The [Astro Alpine.js example](https://github.com/withastro/astro/tree/main/examples/framework-alpine) shows how to use Alpine.js in an Astro project.

# @astrojs/cloudflare

> Learn how to use the @astrojs/cloudflare adapter to deploy your Astro project.

This adapter allows Astro to deploy your [on-demand rendered routes and features](/en/guides/on-demand-rendering/) to [Cloudflare](https://www.cloudflare.com/), including [server islands](/en/guides/server-islands/), [actions](/en/guides/actions/), and [sessions](/en/guides/sessions/). If you‚Äôre using Astro as a static site builder, you don‚Äôt need an adapter. Learn how to deploy your Astro site in our [Cloudflare deployment guide](/en/guides/deploy/cloudflare/). ## Why Astro Cloudflare [Section titled ‚ÄúWhy Astro Cloudflare‚Äù](#why-astro-cloudflare) Cloudflare‚Äôs [Developer Platform](https://developers.cloudflare.com/) lets you develop full-stack applications with access to resources such as storage and AI, all deployed to a global edge network. This adapter builds your Astro project for deployment through Cloudflare. ## Installation [Section titled ‚ÄúInstallation‚Äù](#installation) Astro includes an `astro add` command to automate the setup of official integrations. If you prefer, you can [install integrations manually](#manual-install) instead. Add the Cloudflare adapter to enable server-rendering in your Astro project with the `astro add` command. This will install `@astrojs/cloudflare` and make the appropriate changes to your `astro.config.mjs` file in one step. * npm ```sh npx astro add cloudflare ``` * pnpm ```sh pnpm astro add cloudflare ``` * Yarn ```sh yarn astro add cloudflare ``` Now, you can enable [on-demand rendering per page](/en/guides/on-demand-rendering/#enabling-on-demand-rendering), or set your build output configuration to `output: 'server'` to [server-render all your pages by default](/en/guides/on-demand-rendering/#server-mode). ### Manual Install [Section titled ‚ÄúManual Install‚Äù](#manual-install) 1. Add the `@astrojs/cloudflare` adapter to your project‚Äôs dependencies using your preferred package manager. * npm ```sh npm install @astrojs/cloudflare ``` * pnpm ```sh pnpm add @astrojs/cloudflare ``` * Yarn ```sh yarn add @astrojs/cloudflare ``` 2. Add the adapter to your `astro.config.mjs` file: astro.config.mjs ```diff import { defineConfig } from 'astro/config'; +import cloudflare from '@astrojs/cloudflare'; export default defineConfig({ + adapter: cloudflare(), }); ``` 3. Create a [Wrangler configuration file](https://developers.cloudflare.com/workers/wrangler/configuration/): wrangler.jsonc ```jsonc { "main": "dist/_worker.js/index.js", "name": "my-astro-app", // Update to today's date "compatibility_date": "2025-03-25", "compatibility_flags": [ "nodejs_compat", "global_fetch_strictly_public" ], "assets": { "binding": "ASSETS", "directory": "./dist" }, "observability": { "enabled": true } } ``` 4. Create a `.assetsignore` file in your `public/` folder, and add the following lines to it: public/.assetsignore ```txt _worker.js _routes.json ``` ## Options [Section titled ‚ÄúOptions‚Äù](#options) The Cloudflare adapter accepts the following options: ### `cloudflareModules` [Section titled ‚ÄúcloudflareModules‚Äù](#cloudflaremodules) **Type:** `boolean`\ **Default:** `true` Enables [imports of `.wasm`, `.bin`, and `.txt` modules](#cloudflare-module-imports). This functionality is enabled by default. If you‚Äôd like to disable, set `cloudflareModules` to `false`. ### `imageService` [Section titled ‚ÄúimageService‚Äù](#imageservice) **Type:** `'passthrough' | 'cloudflare' | 'compile' | 'custom'`\ **Default:** `'compile'` Determines which image service is used by the adapter. The adapter will default to `compile` mode when an incompatible image service is configured. Otherwise, it will use the globally configured image service: * **`cloudflare`:** Uses the [Cloudflare Image Resizing](https://developers.cloudflare.com/images/image-resizing/) service. * **`passthrough`:** Uses the existing [`noop`](/en/guides/images/#configure-no-op-passthrough-service) service. * **`compile`:** Uses Astro‚Äôs default service (sharp), but only on pre-rendered routes at build time. For pages rendered on-demand, all `astro:assets` features are disabled. * **`custom`:** Always uses the image service configured in [Image Options](/en/reference/configuration-reference/#image-options). **This option will not check to see whether the configured image service works in Cloudflare‚Äôs `workerd` runtime.** astro.config.mjs ```diff import { defineConfig } from "astro/config"; import cloudflare from '@astrojs/cloudflare'; export default defineConfig({ adapter: cloudflare({ + imageService: 'cloudflare' }), }) ``` ### `platformProxy` [Section titled ‚ÄúplatformProxy‚Äù](#platformproxy) Determines whether and how the Cloudflare runtime is added to `astro dev`. It contains proxies to local `workerd` bindings and emulations of Cloudflare specific values, allowing the emulation of the runtime in the Node.js dev process. Read more about the [Cloudflare Runtime](#cloudflare-runtime). #### `platformProxy.enabled` [Section titled ‚ÄúplatformProxy.enabled‚Äù](#platformproxyenabled) **Type:** `boolean`\ **Default:** `true` Determines whether to enable the Cloudflare runtime in development mode. #### `platformProxy.configPath` [Section titled ‚ÄúplatformProxy.configPath‚Äù](#platformproxyconfigpath) **Type:** `string`\ **Default:** `undefined` Defines the path to the Wrangler configuration file. If no value is set, it tracks `wrangler.toml`, `wrangler.json`, and `wrangler.jsonc` in the project root. #### `platformProxy.environment` [Section titled ‚ÄúplatformProxy.environment‚Äù](#platformproxyenvironment) **Type:** `string`\ **Default:** `undefined` Sets the [Cloudflare environment](https://developers.cloudflare.com/workers/wrangler/environments/) to use. You must select an environment defined in the Wrangler configuration file, otherwise an error occurs. #### `platformProxy.persist` [Section titled ‚ÄúplatformProxy.persist‚Äù](#platformproxypersist) **Type:** `boolean | { path: string }`\ **Default:** `true` Sets whether and where to save binding data locally to the file system. * If set to `true`, binding data is stored in `.wrangler/state/v3/`. It is the same as the default setting for wrangler. * If set to `false`, binding data is not stored in file system. * If set to `{ path: string }`, binding data is stored in the specified path. The following configuration shows an example of enabling the Cloudflare runtime when running the development server, as well as using a `wrangler.json` config file. It also specifies a custom location for persisting data to the filesystem: ```js import cloudflare from '@astrojs/cloudflare'; import { defineConfig } from 'astro/config'; export default defineConfig({ adapter: cloudflare({ platformProxy: { enabled: true, configPath: 'wrangler.json', persist: { path: './.cache/wrangler/v3' }, }, }), }); ``` ### `routes.extend` [Section titled ‚Äúroutes.extend‚Äù](#routesextend) On Cloudflare Workers, this option is not applicable. Refer to [Routing on Cloudflare Workers](#routing-on-cloudflare-workers) for more information. On Cloudflare Pages, this option allows you to add or exclude custom patterns (e.g. `/fonts/*`) to the generated `_routes.json` file that determines which routes are generated on-demand. This can be useful if you need to add route patterns which cannot be automatically generated, or exclude prerendered routes. More information about the custom route patterns can be found in [Cloudflare‚Äôs routing docs](https://developers.cloudflare.com/pages/functions/routing/#functions-invocation-routes). Any routes specified are not automatically deduplicated and will be appended to the existing routes as is. #### `routes.extend.include` [Section titled ‚Äúroutes.extend.include‚Äù](#routesextendinclude) **Type:** `{ pattern: string }[]`\ **Default:** `undefined` Configures additional routes to be generated on demand by the Cloudflare adapter in the `routes.extend.include` array. #### `routes.extend.exclude` [Section titled ‚Äúroutes.extend.exclude‚Äù](#routesextendexclude) **Type:** `{ pattern: string }[]`\ **Default:** `undefined` Configures routes to be excluded from on-demand rendering in the `routes.extend.exclude` array. These routes will be prerendered and served statically instead, and will not invoke the server function. Additionally you can use this option to serve any static asset (e.g. images, fonts, css, js, html, txt, json, etc.) files directly without routing the request through the server function. astro.config.mjs ```js export default defineConfig({ adapter: cloudflare({ routes: { extend: { include: [{ pattern: '/static' }], // Route a prerended page to the server function for on-demand rendering exclude: [{ pattern: '/pagefind/*' }], // Use Starlight's pagefind search, which is generated statically at build time } }, }), }); ``` ### `sessionKVBindingName` [Section titled ‚ÄúsessionKVBindingName‚Äù](#sessionkvbindingname) **Type:** `string`\ **Default:** `SESSION` **Added in:** `astro@5.6.0` The `sessionKVBindingName` option allows you to specify the name of the KV binding used for session storage. By default, this is set to `SESSION`, but you can change it to match your own KV binding name. See [Sessions](#sessions) for more information. astro.config.mjs ```js export default defineConfig({ adapter: cloudflare({ sessionKVBindingName: 'MY_SESSION_BINDING', }), }); ``` ### `workerEntryPoint` [Section titled ‚ÄúworkerEntryPoint‚Äù](#workerentrypoint) **Type:** `{ path: string | URL, namedExports: string[] }`\ **Default:** `{ path: '@astrojs/cloudflare/entrypoints/server.js', namedExports: [] }` **Added in:** `@astrojs/cloudflare@12.6.0` New A configuration object to specify the [workerEntryPoint](https://developers.cloudflare.com/workers/runtime-apis/bindings/service-bindings/rpc/) for your Cloudflare Worker when you use the `astro build` command. It allows you to optionally specify both a custom file `path` and `namedExports`: astro.config.mjs ```js import cloudflare from '@astrojs/cloudflare'; import { defineConfig } from 'astro/config'; export default defineConfig({ adapter: cloudflare({ workerEntryPoint: { path: 'src/worker.ts', namedExports: ['MyDurableObject'] } }), }); ``` #### `workerEntryPoint.path` [Section titled ‚ÄúworkerEntryPoint.path‚Äù](#workerentrypointpath) **Type:** `string`\ **Default:** `@astrojs/cloudflare/entrypoints/server.js` **Added in:** `@astrojs/cloudflare@12.6.0` New The path to the entry file. This should be a relative path from the root of your Astro project. By default, the adapter uses a generic entry file, which only supports the `fetch` handler. To support other [Cloudflare invocation handlers](https://developers.cloudflare.com/workers/observability/logs/workers-logs/#invocation-logs), you can create a custom file to use as the entry point. This is useful if you want to use features that require other handlers (e.g. Durable Objects, Cloudflare Queues, Scheduled Invocations). #### `workerEntryPoint.namedExports` [Section titled ‚ÄúworkerEntryPoint.namedExports‚Äù](#workerentrypointnamedexports) **Type:** `[]`\ **Default:** `[]` **Added in:** `@astrojs/cloudflare@12.6.0` New An array of named exports to use for the entry file. Provide any additional defined named exports of your [custom entry file](#creating-a-custom-cloudflare-worker-entry-file) (e.g. `DurableObject`). If not provided, only default exports will be included. #### Creating a custom Cloudflare Worker entry file [Section titled ‚ÄúCreating a custom Cloudflare Worker entry file‚Äù](#creating-a-custom-cloudflare-worker-entry-file) The custom entry file must export the `createExports()` function with a `default` export including all the handlers you need. The following example entry file registers a Durable Object and a queue handler: src/worker.ts ```ts import type { SSRManifest } from 'astro'; import { App } from 'astro/app'; import { handle } from '@astrojs/cloudflare/handler' import { DurableObject } from 'cloudflare:workers'; class MyDurableObject extends DurableObject<Env> { constructor(ctx: DurableObjectState, env: Env) { super(ctx, env) } } export function createExports(manifest: SSRManifest) { const app = new App(manifest); return { default: { async fetch(request, env, ctx) { await env.MY_QUEUE.send("log"); return handle(manifest, app, request, env, ctx); }, async queue(batch, _env) { let messages = JSON.stringify(batch.messages); console.log(`consumed from our queue: ${messages}`); } } satisfies ExportedHandler<Env>, MyDurableObject: MyDurableObject, } } ``` ## Cloudflare runtime [Section titled ‚ÄúCloudflare runtime‚Äù](#cloudflare-runtime) ### Usage [Section titled ‚ÄúUsage‚Äù](#usage) The Cloudflare runtime gives you access to environment variables and bindings to Cloudflare resources defined in your `wrangler.toml`/`wrangler.jsonc` configuration file. You can access the bindings from `Astro.locals.runtime`: src/pages/index.astro ```astro --- const { env } = Astro.locals.runtime; --- ``` You can access the runtime from API endpoints through `context.locals`: src/pages/api/someFile.js ```js export function GET(context) { const runtime = context.locals.runtime; return new Response('Some body'); } ``` See the [list of all supported bindings](https://developers.cloudflare.com/workers/wrangler/api/#supported-bindings) in the Cloudflare documentation. ### Environment variables and secrets [Section titled ‚ÄúEnvironment variables and secrets‚Äù](#environment-variables-and-secrets) The Cloudflare runtime treats environment variables as a type of binding. For example, you can define an [environment variable](https://developers.cloudflare.com/workers/configuration/environment-variables/#add-environment-variables-via-wrangler) in `wrangler.jsonc` as follows: wrangler.jsonc ```jsonc { "vars" : { "MY_VARIABLE": "test" } } ``` Secrets are a special type of environment variable that allow you to attach encrypted text values to your Worker. They need to be defined differently to ensure they are not visible after you set them. To define `secrets`, add them through the [Wrangler CLI](https://developers.cloudflare.com/workers/wrangler/) rather than in your Wrangler config file. ```bash npx wrangler secret put <KEY> ``` To set secrets for local development, you also need to add a `.dev.vars` file to the root of the Astro project: .dev.vars ```ini DB_PASSWORD=myPassword ``` You can then access environment variables, including secrets, from the `env` object available from `Astro.locals.runtime`: src/pages/index.astro ```astro --- const { env } = Astro.locals.runtime; const myVariable = env.MY_VARIABLE; const secret = env.DB_PASSWORD; --- ``` Cloudflare environment variables and secrets are compatible with the [`astro:env` API](/en/guides/environment-variables/#type-safe-environment-variables). ### Typing [Section titled ‚ÄúTyping‚Äù](#typing) `wrangler` provides a `types` command to generate TypeScript types for the bindings. This allows you to type locals without the need to manually type them. Refer to the [Cloudflare documentation](https://developers.cloudflare.com/workers/wrangler/commands/#types) for more information. Every time you change your configuration files (e.g. `wrangler.toml`, `.dev.vars`) you need to run `wrangler types`. You can type the `runtime` object by [extending global types](/en/guides/typescript/#extending-global-types) using `Runtime`: src/env.d.ts ```ts type Runtime = import('@astrojs/cloudflare').Runtime<Env>; declare namespace App { interface Locals extends Runtime { otherLocals: { test: string; }; } } ``` ## Cloudflare Platform [Section titled ‚ÄúCloudflare Platform‚Äù](#cloudflare-platform) ### Headers [Section titled ‚ÄúHeaders‚Äù](#headers) You can attach [custom headers](https://developers.cloudflare.com/pages/platform/headers/) to your responses by adding a `_headers` file in your Astro project‚Äôs `public/` folder. This file will be copied to your build output directory. This is available on Cloudflare Workers and Pages. ### Assets [Section titled ‚ÄúAssets‚Äù](#assets) Assets built by Astro are all named with a hash and therefore can be given long cache headers. By default, Astro on Cloudflare will add such a header for these files. ### Redirects [Section titled ‚ÄúRedirects‚Äù](#redirects) You can declare [custom redirects](https://developers.cloudflare.com/pages/platform/redirects/) to redirect requests to a different URL. To do so, add a `_redirects` file in your Astro project‚Äôs `public/` folder. This file will be copied to your build output directory. This is available on Cloudflare Workers and Pages. ### Routes [Section titled ‚ÄúRoutes‚Äù](#routes) #### Routing on Cloudflare Workers [Section titled ‚ÄúRouting on Cloudflare Workers‚Äù](#routing-on-cloudflare-workers) Routing for static assets is based on the file structure in the build directory (e.g. `./dist`). If no match is found, this will fall back to the Worker for on-demand rendering. Read more about [static asset routing with Cloudflare Workers](https://developers.cloudflare.com/workers/static-assets/routing/). Unlike [Cloudflare Pages](#routing-on-cloudflare-pages), with Workers, you do not need a `_routes.json` file. Currently, the Cloudflare adapter always generates this file. To work around this, create a `.assetsignore` file in your `public/` folder, and add the following lines to it: public/.assetsignore ```txt _worker.js _routes.json ``` #### Routing on Cloudflare Pages [Section titled ‚ÄúRouting on Cloudflare Pages‚Äù](#routing-on-cloudflare-pages) For Cloudflare Pages, [routing](https://developers.cloudflare.com/pages/platform/functions/routing/#functions-invocation-routes) uses a `_routes.json` file to determine which requests are routed to the server function and which are served as static assets. By default, a `_routes.json` file will be automatically generated for your project based on its files and configuration. You can [specify additional routing patterns to follow](#routesextend) in your adapter config, or create your own custom `_routes.json` file to fully override the automatic generation. Creating a custom `public/_routes.json` will override the automatic generation. See [Cloudflare‚Äôs documentation on creating a custom `_routes.json`](https://developers.cloudflare.com/pages/platform/functions/routing/#create-a-_routesjson-file) for more details. ## Sessions [Section titled ‚ÄúSessions‚Äù](#sessions) The Astro [Sessions API](/en/guides/sessions/) allows you to easily store user data between requests. This can be used for things like user data and preferences, shopping carts, and authentication credentials. Unlike cookie storage, there are no size limits on the data, and it can be restored on different devices. Astro automatically configures [Workers KV](https://developers.cloudflare.com/kv/) for session storage when using the Cloudflare adapter. Before using sessions, you need to create a KV namespace to store the data and configure a KV binding in your Wrangler config file. By default, Astro expects the KV binding to be named `SESSION`, but you can choose a different name if you prefer by setting the [`sessionKVBindingName`](#sessionkvbindingname) option in the adapter config. 1. Create a KV namespace using the Wrangler CLI and make note of the ID of the new namespace: ```sh npx wrangler kv namespace create "SESSION" ``` 2. Declare the KV namespace in your Wrangler config, setting the namespace ID to the one returned by the previous command: * wrangler.jsonc wrangler.jsonc ```json { "kv_namespaces": [ { "binding": "SESSION", "id": "<KV_NAMESPACE_ID>" } ] } ``` * wrangler.toml wrangler.toml ```toml kv_namespaces = [ { binding = "SESSION", id = "<KV_NAMESPACE_ID>" } ] ``` 3. You can then use sessions in your server code: src/components/CartButton.astro ```astro --- export const prerender = false; const cart = await Astro.session?.get('cart'); --- <a href="/checkout">üõí {cart?.length ?? 0} items</a> ``` ## Cloudflare Module Imports [Section titled ‚ÄúCloudflare Module Imports‚Äù](#cloudflare-module-imports) The Cloudflare `workerd` runtime supports imports of some [non-standard module types](https://developers.cloudflare.com/workers/wrangler/bundling/#including-non-javascript-modules). Most additional file types are also available in Astro: * `.wasm` or `.wasm?module`: exports a [`WebAssembly.Module`](https://developer.mozilla.org/en-US/docs/WebAssembly/JavaScript_interface/Module) that can then be instantiated * `.bin`: exports an [`ArrayBuffer`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) of the raw binary contents of the file * `.txt`: exports a string of the file contents All module types export a single default value. Modules can be imported both from server-side rendered pages, or from prerendered pages for static site generation. The following is an example of importing a Wasm module that then responds to requests by adding the request‚Äôs number parameters together. pages/add/\[a]/\[b].js ```js // Import the WebAssembly module import mod from '../util/add.wasm'; // Instantiate first in order to use it const addModule: any = new WebAssembly.Instance(mod); export async function GET(context) { const a = Number.parseInt(context.params.a); const b = Number.parseInt(context.params.b); return new Response(`${addModule.exports.add(a, b)}`); } ``` While this example is trivial, Wasm can be used to accelerate computationally intensive operations which do not involve significant I/O such as embedding an image processing library, or embedding a small pre-indexed database for search over a read-only dataset. ## Node.js compatibility [Section titled ‚ÄúNode.js compatibility‚Äù](#nodejs-compatibility) Out of the box, Cloudflare does not support the Node.js runtime APIs. With some configuration, Cloudflare does support a subset of the Node.js runtime APIs. You can find supported Node.js runtime APIs in Cloudflare‚Äôs [documentation](https://developers.cloudflare.com/workers/runtime-apis/nodejs). To use these APIs, your page or endpoint must be server-side rendered (not pre-rendered) and must use the `import {} from 'node:*'` import syntax. pages/api/endpoint.js ```js export const prerender = false; import { Buffer } from 'node:buffer'; ``` You‚Äôll also need to modify the `vite` configuration in your Astro config to allow for the `node:*` import syntax: astro.config.mjs ```diff import {defineConfig} from "astro/config"; import cloudflare from '@astrojs/cloudflare'; export default defineConfig({ adapter: cloudflare({}), + vite: { + ssr: { + external: ['node:buffer'], + }, + }, }) ``` Additionally, you‚Äôll need to follow Cloudflare‚Äôs documentation on how to enable support. For detailed guidance, please refer to the [Cloudflare documentation on enabling Node.js compatibility](https://developers.cloudflare.com/workers/runtime-apis/nodejs/). ## Preview with Wrangler [Section titled ‚ÄúPreview with Wrangler‚Äù](#preview-with-wrangler) To use [`wrangler`](https://developers.cloudflare.com/workers/wrangler/) to run your application locally, update the preview script. For Workers: package.json ```json "preview": "wrangler dev" ``` For Pages: package.json ```json "preview": "wrangler pages dev ./dist" ``` Developing with [`wrangler`](https://developers.cloudflare.com/workers/wrangler/) gives you access to [Cloudflare bindings](https://developers.cloudflare.com/pages/platform/functions/bindings), [environment variables](https://developers.cloudflare.com/pages/platform/functions/bindings/#environment-variables), and the [cf object](https://developers.cloudflare.com/workers/runtime-apis/request/#incomingrequestcfproperties). Getting hot reloading of the Astro dev server to work with Wrangler might require custom setup. See [community examples](https://github.com/withastro/roadmap/discussions/590). ### Meaningful error messages [Section titled ‚ÄúMeaningful error messages‚Äù](#meaningful-error-messages) Currently, errors during running your application in Wrangler are not very useful, due to the minification of your code. For better debugging, you can add `vite.build.minify = false` setting to your `astro.config.mjs`. astro.config.mjs ```diff export default defineConfig({ adapter: cloudflare(), + vite: { + build: { + minify: false, + }, + }, }); ```

# @astrojs/db

> Learn how to use the @astrojs/db integration in your Astro project.

Astro DB is a fully-managed SQL database designed for the Astro ecosystem: develop locally in Astro and deploy to any [libSQL-compatible database](/en/guides/astro-db/). With Astro DB you have a powerful, local, type-safe tool to query and model content as a relational database. See the [Astro DB guide](/en/guides/astro-db/) for full usage and examples. ## Installation [Section titled ‚ÄúInstallation‚Äù](#installation) Astro includes an `astro add` command to automate the setup of official integrations. If you prefer, you can [install integrations manually](#manual-installation) instead. Run one of the following commands in a new terminal window. * npm ```sh npx astro add db ``` * pnpm ```sh pnpm astro add db ``` * Yarn ```sh yarn astro add db ``` #### Manual Installation [Section titled ‚ÄúManual Installation‚Äù](#manual-installation) If you prefer to set things up from scratch yourself, skip `astro add` and follow these instructions to install Astro DB yourself. ##### 1. Install the integration from npm via a package manager [Section titled ‚Äú1. Install the integration from npm via a package manager‚Äù](#1-install-the-integration-from-npm-via-a-package-manager) * npm ```shell npm install @astrojs/db ``` * pnpm ```shell pnpm add @astrojs/db ``` * Yarn ```shell yarn add @astrojs/db ``` ##### 2. Add the integration to `astro.config.mjs` [Section titled ‚Äú2. Add the integration to astro.config.mjs‚Äù](#2-add-the-integration-to-astroconfigmjs) astro.config.mjs ```diff import { defineConfig } from 'astro/config'; +import db from '@astrojs/db'; export default defineConfig({ integrations: [ +db() ] }); ``` ##### 3. Configure your database [Section titled ‚Äú3. Configure your database‚Äù](#3-configure-your-database) Create a `db/config.ts` file at the root of your project. This is a special file that Astro will automatically load and use to configure your database tables. db/config.ts ```ts import { defineDb } from 'astro:db'; export default defineDb({ tables: {}, }) ``` ## Configuration [Section titled ‚ÄúConfiguration‚Äù](#configuration) ### `mode` [Section titled ‚Äúmode‚Äù](#mode) **Type:** `'node' | 'web'`\ **Default:** `'node'` **Added in:** `@astrojs/db@0.18.0` Configures the driver to use to connect to your database in production. By default, Astro DB uses a Node.js-based libSQL driver for production deployments. The `node` driver mode is sufficient for most Astro hosted or self-hosted websites with Node.js runtimes. This allows you to connect to your database over several protocols, including `memory:`, `file:`, `ws:`, `wss:`, `libsql`, `http`, and `https`, as well as allowing for more advanced features such as [embedded replicas](/en/guides/astro-db/#syncurl). When deploying to a serverless environment on a non-Node.js runtime, such as Cloudflare Workers or Deno, a web-based libSQL driver is available. When deploying using the `web` mode, you will be able to make web-based connections over `libsql`, `http`, or `https`. To use the web libSQL driver mode for non-Node.js environments, set the `mode` property in your adapter‚Äôs configuration: astro.config.mjs ```diff import { defineConfig } from 'astro/config'; import db from '@astrojs/db'; export default defineConfig({ integrations: [ db({ + mode: 'web' }) ] }); ``` ## Table configuration reference [Section titled ‚ÄúTable configuration reference‚Äù](#table-configuration-reference) ### `columns` [Section titled ‚Äúcolumns‚Äù](#columns) **Type:** `ColumnsConfig` Table columns are configured using the `columns` object: ```ts import { defineTable, column, NOW } from 'astro:db'; const Comment = defineTable({ columns: { id: column.number({ primaryKey: true }), author: column.text(), content: column.text({ optional: true }), published: column.date({ default: NOW }), }, }); ``` Columns are configured using the `column` utility. `column` supports the following types: * **`column.text(...)`** - store either plain or rich text content * **`column.number(...)`** - store integer and floating point values * **`column.boolean(...)`** - store true / false values * **`column.date(...)`** - store `Date` objects, parsed as ISO strings for data storage * **`column.json(...)`** - store arbitrary JSON blobs, parsed as stringified JSON for data storage There are a few shared configuration values across all columns: * `primaryKey` - Set a `number` or `text` column as the unique identifier. * `optional` - Astro DB uses `NOT NULL` for all columns by default. Set `optional` to `true` to allow null values. * `default` - Set the default value for newly inserted entries. This accepts either a static value or a string of `sql` for generated values like timestamps. * `unique` - Mark a column as unique. This prevents duplicate values across entries in the table. * `references` - Reference a related table by column. This establishes a foreign key constraint, meaning each column value must have a matching value in the referenced table. A `text` column can optionally define a list of string literals to serve as an enum for generating types. However, **no runtime validation will be performed**. Removing, adding, and changing values should be handled in your project code. db/config.ts ```ts import { defineTable, column } from 'astro:db'; // Table definition const UserTable = defineTable({ columns: { id: column.number({ primaryKey: true }), name: column.text(), rank: column.text({ enum: ['user', 'mod', 'admin'] }), }, }); // Resulting type definition type UserTableInferInsert = { id?: string; name: string; rank: "user" | "mod" | "admin"; } ``` ### `indexes` [Section titled ‚Äúindexes‚Äù](#indexes) **Type:** `{ on: string | string[]; unique?: boolean | undefined; name?: string | undefined; }[]` Table indexes are used to improve lookup speeds on a given column or combination of columns. The `indexes` property accepts an array of configuration objects specifying the columns to index: db/config.ts ```ts import { defineTable, column } from 'astro:db'; const Comment = defineTable({ columns: { authorId: column.number(), published: column.date(), body: column.text(), }, indexes: [ { on: ["authorId", "published"], unique: true }, ] }); ``` This will generate a unique index on the `authorId` and `published` columns with the name `Comment_authorId_published_idx`. The following configuration options are available for each index: * `on` - A single column or array of column names to index. * `unique` (optional) - Set to `true` to enforce unique values across the indexed columns. * `name` (optional) - A custom name for the unique index. This will override Astro‚Äôs generated name based on the table and column names being indexed (e.g. `Comment_authorId_published_idx`). Custom names are global, so ensure index names do not conflict between tables. ### `foreignKeys` [Section titled ‚ÄúforeignKeys‚Äù](#foreignkeys) **Type:** `{ columns: string | string[]; references: () => Column | Column[]; }[]` Foreign keys are used to establish a relationship between two tables. The `foreignKeys` property accepts an array of configuration objects that may relate one or more columns between tables: db/config.ts ```ts import { defineTable, column } from 'astro:db'; const Author = defineTable({ columns: { firstName: column.text(), lastName: column.text(), }, }); const Comment = defineTable({ columns: { authorFirstName: column.text(), authorLastName: column.text(), body: column.text(), }, foreignKeys: [ { columns: ["authorFirstName", "authorLastName"], references: () => [Author.columns.firstName, Author.columns.lastName], }, ], }); ``` Each foreign key configuration object accepts the following properties: * `columns` - A single column or array of column names to relate to the referenced table. * `references` - A function that returns a single column or an array of columns from the referenced table. ## Astro DB CLI reference [Section titled ‚ÄúAstro DB CLI reference‚Äù](#astro-db-cli-reference) Astro DB includes a set of CLI commands to interact with your local and libSQL-compatible database. These commands are called automatically when using a GitHub CI action, and can be called manually using the `astro db` CLI. ### `astro db push` [Section titled ‚Äúastro db push‚Äù](#astro-db-push) **Flags:** * `--db-app-token <token>` Provide the remote database app token directly instead of `ASTRO_DB_APP_TOKEN`. * `--dry-run` Print the generated SQL statements without applying them. * `--force-reset` Reset all production data if a breaking schema change is required. * `--remote` Push to your remote database instead of the local database file. Requires the `ASTRO_DB_REMOTE_URL` environment variable to be set, and either `ASTRO_DB_APP_TOKEN` to be set in the environment or a value passed with the `--db-app-token` command-line argument. Safely push database configuration changes to your project database. This will check for any risk of data loss and guide you on any recommended migration steps. Use `--remote` to apply changes to your remote database. If a breaking schema change must be made, use `--force-reset` to reset all production data. ### `astro db verify` [Section titled ‚Äúastro db verify‚Äù](#astro-db-verify) **Flags:** * `--db-app-token <token>` Provide the remote database app token directly instead of `ASTRO_DB_APP_TOKEN`. * `--json` Print a machine-readable JSON result from `verify`. * `--remote` Compare against your remote database instead of the local database file. Requires the `ASTRO_DB_REMOTE_URL` environment variable to be set, and either `ASTRO_DB_APP_TOKEN` to be set in the environment or a value passed with the `--db-app-token` command-line argument. Compares your local schema against the remote database to check for any differences between your local and remote database configurations. This is automatically run by `astro db push`. `verify` will compare your local `db/config.ts` file with the remote database and warn if changes are detected. It will exit with a non-zero code if changes are required or unsafe, making it useful for CI. ### `astro db execute <file-path>` [Section titled ‚Äúastro db execute \<file-path>‚Äù](#astro-db-execute-file-path) **Flags:** * `--db-app-token <token>` Provide the remote database app token directly instead of `ASTRO_DB_APP_TOKEN`. * `--remote` Run against your libSQL-compatible database. Omit to run against your local database file. Requires the `ASTRO_DB_REMOTE_URL` environment variable to be set, and either `ASTRO_DB_APP_TOKEN` to be set in the environment or a value passed with the `--db-app-token` command-line argument. Execute a `.ts` or `.js` file to read or write to your database. This accepts a file path as an argument, and supports usage of the `astro:db` module to write type-safe queries. Use the `--remote` flag to run against your libSQL-compatible database, or omit the flag to run against your local database file. See how to [seed development data](/en/guides/astro-db/#seed-your-database-for-development) for an example file. ### `astro db shell --query <sql-string>` [Section titled ‚Äúastro db shell --query \<sql-string>‚Äù](#astro-db-shell---query-sql-string) **Flags:** * `--query` Raw SQL query to execute. * `--remote` Run against your libSQL-compatible database. Omit to run against your local database file. Requires the `ASTRO_DB_REMOTE_URL` environment variable to be set, and either `ASTRO_DB_APP_TOKEN` to be set in the environment or a value passed with the `--db-app-token` command-line argument. Execute a raw SQL query against your database. The following example selects all rows from a `Comment` table in a remote database: ```sh npx astro db shell --query "SELECT * FROM Comment;" --remote ``` ## Astro DB utility reference [Section titled ‚ÄúAstro DB utility reference‚Äù](#astro-db-utility-reference) ### `isDbError()` [Section titled ‚ÄúisDbError()‚Äù](#isdberror) **Type:** `(err: unknown) => boolean` **Added in:** `@astrojs/db@0.9.1` The `isDbError()` function checks if an error is a libSQL database exception. This may include a foreign key constraint error when using references, or missing fields when inserting data. You can combine `isDbError()` with a try / catch block to handle database errors in your application: src/pages/api/comment/\[id].ts ```ts import { db, Comment, isDbError } from 'astro:db'; import type { APIRoute } from 'astro'; export const POST: APIRoute = (ctx) => { try { await db.insert(Comment).values({ id: ctx.params.id, content: 'Hello, world!' }); } catch (e) { if (isDbError(e)) { return new Response(`Cannot insert comment with id ${id}\n\n${e.message}`, { status: 400 }); } return new Response('An unexpected error occurred', { status: 500 }); } return new Response(null, { status: 201 }); }; ```

# @deno/astro-adapter

> The Deno Astro adapter

The Deno adapter allows Astro to deploy your SSR site to Deno targets including Deno Deploy. The Deno adapter was previously maintained by Astro but now is maintained by Deno directly. Usage is now documented [in the Deno adapter repository](https://github.com/denoland/deno-astro-adapter). If you are currently using this Astro adapter, you will need to migrate to the new Deno version or to [add another adapter](/en/guides/on-demand-rendering/) to continue using SSR in your project.

# Lit

> Using Lit to extend component support in your Astro project.

Deprecated This Astro integration to enable on-demand rendering and client-side hydration for your [Lit](https://lit.dev/) custom elements was deprecated in Astro 5.0. You can continue to use Lit for client components by adding a client-side script tag. For example: ```astro <script> import "../components/MyTabs"; </script> <my-tabs title="These are my tabs">...</my-tabs> ``` If you‚Äôre interested in maintaining a Lit integration yourself, you may wish to use the [last published version of `@astrojs/lit`](https://github.com/withastro/astro/tree/astro%404.13.0/packages/integrations/lit) as a starting point and upgrade the relevant packages.

# @astrojs/markdoc

> Learn how to use the @astrojs/markdoc integration in your Astro project.

This **[Astro integration](/en/guides/integrations-guide/)** enables the usage of [Markdoc](https://markdoc.dev/) to create components, pages, and content collection entries. ## Why Markdoc? [Section titled ‚ÄúWhy Markdoc?‚Äù](#why-markdoc) Markdoc allows you to enhance your Markdown with [Astro components](/en/basics/astro-components/). If you have existing content authored in Markdoc, this integration allows you to bring those files to your Astro project using content collections. ## Installation [Section titled ‚ÄúInstallation‚Äù](#installation) Astro includes an `astro add` command to automate the setup of official integrations. If you prefer, you can [install integrations manually](#manual-install) instead. Run one of the following commands in a new terminal window. * npm ```sh npx astro add markdoc ``` * pnpm ```sh pnpm astro add markdoc ``` * Yarn ```sh yarn astro add markdoc ``` If you run into any issues, [feel free to report them to us on GitHub](https://github.com/withastro/astro/issues) and try the manual installation steps below. ### Manual Install [Section titled ‚ÄúManual Install‚Äù](#manual-install) First, install the `@astrojs/markdoc` package: * npm ```sh npm install @astrojs/markdoc ``` * pnpm ```sh pnpm add @astrojs/markdoc ``` * Yarn ```sh yarn add @astrojs/markdoc ``` Then, apply the integration to your `astro.config.*` file using the `integrations` property: astro.config.mjs ```diff import { defineConfig } from 'astro/config'; +import markdoc from '@astrojs/markdoc'; export default defineConfig({ // ... integrations: [markdoc()], }); ``` ### VS Code Editor Integration [Section titled ‚ÄúVS Code Editor Integration‚Äù](#vs-code-editor-integration) If you are using VS Code, there is an official [Markdoc language extension](https://marketplace.visualstudio.com/items?itemName=Stripe.markdoc-language-support) that includes syntax highlighting and autocomplete for configured tags. [See the language server on GitHub](https://github.com/markdoc/language-server.git) for more information. To set up the extension, create a `markdoc.config.json` file in the project root with following content: markdoc.config.json ```json [ { "id": "my-site", "path": "src/content", "schema": { "path": "markdoc.config.mjs", "type": "esm", "property": "default", "watch": true } } ] ``` Set `markdoc.config.mjs` as your configuration file with the `schema` object, and define where your Markdoc files are stored using the `path` property. Since Markdoc is specific to content collections, you can use `src/content`. ## Usage [Section titled ‚ÄúUsage‚Äù](#usage) Markdoc files can only be used within content collections. Add entries to any content collection using the `.mdoc` extension: Then, query your collection using the [Content Collection APIs](/en/guides/content-collections/#querying-collections): src/pages/why-markdoc.astro ```astro --- import { getEntry, render } from 'astro:content'; const entry = await getEntry('docs', 'why-markdoc'); const { Content } = await render(entry); --- <!--Access frontmatter properties with `data`--> <h1>{entry.data.title}</h1> <!--Render Markdoc contents with the Content component--> <Content /> ``` See the [Astro Content Collection docs](/en/guides/content-collections/) for more information. ## Pass Markdoc variables [Section titled ‚ÄúPass Markdoc variables‚Äù](#pass-markdoc-variables) You may need to pass [variables](https://markdoc.dev/docs/variables) to your content. This is useful when passing SSR parameters like A/B tests. Variables can be passed as props via the `Content` component: src/pages/why-markdoc.astro ```astro --- import { getEntry, render } from 'astro:content'; const entry = await getEntry('docs', 'why-markdoc'); const { Content } = await render(entry); --- <!--Pass the `abTest` param as a variable--> <Content abTestGroup={Astro.params.abTestGroup} /> ``` Now, `abTestGroup` is available as a variable in `docs/why-markdoc.mdoc`: src/content/docs/why-markdoc.mdoc ```md {% if $abTestGroup === 'image-optimization-lover' %} Let me tell you about image optimization... {% /if %} ``` To make a variable global to all Markdoc files, you can use the `variables` attribute from your `markdoc.config.mjs|ts`: markdoc.config.mjs ```js import { defineMarkdocConfig } from '@astrojs/markdoc/config'; export default defineMarkdocConfig({ variables: { environment: process.env.IS_PROD ? 'prod' : 'dev', }, }); ``` ### Access frontmatter from your Markdoc content [Section titled ‚ÄúAccess frontmatter from your Markdoc content‚Äù](#access-frontmatter-from-your-markdoc-content) To access frontmatter, you can pass the entry `data` property as a variable where you render your content: src/pages/why-markdoc.astro ```astro --- import { getEntry, render } from 'astro:content'; const entry = await getEntry('docs', 'why-markdoc'); const { Content } = await render(entry); --- <Content frontmatter={entry.data} /> ``` This can now be accessed as `$frontmatter` in your Markdoc. ## Render components [Section titled ‚ÄúRender components‚Äù](#render-components) `@astrojs/markdoc` offers configuration options to use all of Markdoc‚Äôs features and connect UI components to your content. ### Use Astro components as Markdoc tags [Section titled ‚ÄúUse Astro components as Markdoc tags‚Äù](#use-astro-components-as-markdoc-tags) You can configure [Markdoc tags](https://markdoc.dev/docs/tags) that map to `.astro` components. You can add a new tag by creating a `markdoc.config.mjs|ts` file at the root of your project and configuring the `tag` attribute. This example renders an `Aside` component, and allows a `type` prop to be passed as a string: markdoc.config.mjs ```js import { defineMarkdocConfig, component } from '@astrojs/markdoc/config'; export default defineMarkdocConfig({ tags: { aside: { render: component('./src/components/Aside.astro'), attributes: { // Markdoc requires type defs for each attribute. // These should mirror the `Props` type of the component // you are rendering. // See Markdoc's documentation on defining attributes // https://markdoc.dev/docs/attributes#defining-attributes type: { type: String }, }, }, }, }); ``` This component can now be used in your Markdoc files with the `{% aside %}` tag. Children will be passed to your component‚Äôs default slot: ```md # Welcome to Markdoc üëã {% aside type="tip" %} Use tags like this fancy "aside" to add some _flair_ to your docs. {% /aside %} ``` ### Use client-side UI components [Section titled ‚ÄúUse client-side UI components‚Äù](#use-client-side-ui-components) Tags and nodes are restricted to `.astro` files. To embed client-side UI components in Markdoc, [use a wrapper `.astro` component that renders a framework component](/en/guides/framework-components/#nesting-framework-components) with your desired `client:` directive. This example wraps a React `Aside.tsx` component with a `ClientAside.astro` component: src/components/ClientAside.astro ```astro --- import Aside from './Aside'; --- <Aside {...Astro.props} client:load /> ``` This Astro component can now be passed to the `render` prop for any [tag](https://markdoc.dev/docs/tags) or [node](https://markdoc.dev/docs/nodes) in your config: markdoc.config.mjs ```js import { defineMarkdocConfig, component } from '@astrojs/markdoc/config'; export default defineMarkdocConfig({ tags: { aside: { render: component('./src/components/ClientAside.astro'), attributes: { type: { type: String }, }, }, }, }); ``` ### Use Astro components from npm packages and TypeScript files [Section titled ‚ÄúUse Astro components from npm packages and TypeScript files‚Äù](#use-astro-components-from-npm-packages-and-typescript-files) You may need to use Astro components exposed as named exports from TypeScript or JavaScript files. This is common when using npm packages and design systems. You can pass the import name as the second argument to the `component()` function: markdoc.config.mjs ```js import { defineMarkdocConfig, component } from '@astrojs/markdoc/config'; export default defineMarkdocConfig({ tags: { tabs: { render: component('@astrojs/starlight/components', 'Tabs'), }, }, }); ``` This generates the following import statement internally: ```ts import { Tabs } from '@astrojs/starlight/components'; ``` ## Markdoc Partials [Section titled ‚ÄúMarkdoc Partials‚Äù](#markdoc-partials) The `{% partial /%}` tag allows you to render other `.mdoc` files inside your Markdoc content. This is useful for reusing content across multiple documents, and allows you to have `.mdoc` content files that do not follow your collection schema. This example shows a Markdoc partial for a footer to be used inside blog collection entries: src/content/blog/\_footer.mdoc ```md Social links: - [Twitter / X](https://twitter.com/astrodotbuild) - [Discord](https://astro.build/chat) - [GitHub](https://github.com/withastro/astro) ``` Use the `{% partial /%}` tag with to render the footer at the bottom of a blog post entry. Apply the `file` attribute with the path to the file, using either a relative path or an import alias: src/content/blog/post.mdoc ```md # My Blog Post {% partial file="./_footer.mdoc" /%} ``` ## Syntax highlighting [Section titled ‚ÄúSyntax highlighting‚Äù](#syntax-highlighting) `@astrojs/markdoc` provides [Shiki](https://shiki.style) and [Prism](https://github.com/PrismJS) extensions to highlight your code blocks. ### Shiki [Section titled ‚ÄúShiki‚Äù](#shiki) Apply the `shiki()` extension to your Markdoc config using the `extends` property. You can optionally pass a shiki configuration object: markdoc.config.mjs ```js import { defineMarkdocConfig } from '@astrojs/markdoc/config'; import shiki from '@astrojs/markdoc/shiki'; export default defineMarkdocConfig({ extends: [ shiki({ // Choose from Shiki's built-in themes (or add your own) // Default: 'github-dark' // https://shiki.style/themes theme: 'dracula', // Enable word wrap to prevent horizontal scrolling // Default: false wrap: true, // Pass custom languages // Note: Shiki has countless langs built-in, including `.astro`! // https://shiki.style/languages langs: [], }), ], }); ``` ### Prism [Section titled ‚ÄúPrism‚Äù](#prism) Apply the `prism()` extension to your Markdoc config using the `extends` property. markdoc.config.mjs ```diff import { defineMarkdocConfig } from '@astrojs/markdoc/config'; import prism from '@astrojs/markdoc/prism'; export default defineMarkdocConfig({ + extends: [prism()], }); ``` To learn about configuring Prism stylesheets, [see our syntax highlighting guide](/en/guides/syntax-highlighting/#add-a-prism-stylesheet). ## Custom Markdoc nodes / elements [Section titled ‚ÄúCustom Markdoc nodes / elements‚Äù](#custom-markdoc-nodes--elements) You may want to render standard Markdown elements, such as paragraphs and bolded text, as Astro components. For this, you can configure a [Markdoc node](https://markdoc.dev/docs/nodes). If a given node receives attributes, they will be available as component props. This example renders blockquotes with a custom `Quote.astro` component: markdoc.config.mjs ```js import { defineMarkdocConfig, nodes, component } from '@astrojs/markdoc/config'; export default defineMarkdocConfig({ nodes: { blockquote: { ...nodes.blockquote, // Apply Markdoc's defaults for other options render: component('./src/components/Quote.astro'), }, }, }); ``` See the [Markdoc nodes documentation](https://markdoc.dev/docs/nodes#built-in-nodes) to learn about all the built-in nodes and attributes. ### Custom headings [Section titled ‚ÄúCustom headings‚Äù](#custom-headings) `@astrojs/markdoc` automatically adds anchor links to your headings, and [generates a list of `headings` via the content collections API](/en/guides/content-collections/#rendering-body-content). To further customize how headings are rendered, you can apply an Astro component [as a Markdoc node](https://markdoc.dev/docs/nodes). This example renders a `Heading.astro` component using the `render` property: markdoc.config.mjs ```js import { defineMarkdocConfig, nodes, component } from '@astrojs/markdoc/config'; export default defineMarkdocConfig({ nodes: { heading: { ...nodes.heading, // Preserve default anchor link generation render: component('./src/components/Heading.astro'), }, }, }); ``` All Markdown headings will render the `Heading.astro` component and pass the following `attributes` as component props: * `level: number` The heading level 1 - 6 * `id: string` An `id` generated from the heading‚Äôs text contents. This corresponds to the `slug` generated by the [content `render()` function](/en/guides/content-collections/#rendering-body-content). For example, the heading `### Level 3 heading!` will pass `level: 3` and `id: 'level-3-heading'` as component props. ### Custom image components [Section titled ‚ÄúCustom image components‚Äù](#custom-image-components) Astro‚Äôs `<Image />` component cannot be used directly in Markdoc. However, you can configure an Astro component to override the default image node every time the native `![]()` image syntax is used, or as a custom Markdoc tag to allow you to specify additional image attributes. #### Override Markdoc‚Äôs default image node [Section titled ‚ÄúOverride Markdoc‚Äôs default image node‚Äù](#override-markdocs-default-image-node) To override the default image node, you can configure an `.astro` component to be rendered in place of a standard `<img>`. 1. Build a custom `MarkdocImage.astro` component to pass the required `src` and `alt` properties from your image to the `<Image />` component: src/components/MarkdocImage.astro ```astro --- import type { ImageMetadata } from "astro"; import { Image } from "astro:assets"; interface Props { src: ImageMetadata; alt: string; } const { src, alt } = Astro.props; --- <Image src={src} alt={alt} /> ``` 2. The `<Image />` component requires a `width` and `height` for remote images which cannot be provided using the `![]()` syntax. To avoid errors when using remote images, update your component to render a standard HTML `<img>` tag when a remote URL `src` is found: src/components/MarkdocImage.astro ```diff --- import type { ImageMetadata } from "astro"; import { Image } from "astro:assets"; interface Props { src: ImageMetadata | string; alt: string; } const { src, alt } = Astro.props; --- -<Image src={src} alt={alt} /> +{ +typeof src === 'string' ? <img src={src} alt={alt} /> : <Image src={src} alt={alt} /> +} ``` 3. Configure Markdoc to override the default image node and render `MarkdocImage.astro`: markdoc.config.mjs ```js import { defineMarkdocConfig, nodes, component } from '@astrojs/markdoc/config'; export default defineMarkdocConfig({ nodes: { image: { ...nodes.image, // Apply Markdoc's defaults for other options render: component('./src/components/MarkdocImage.astro'), }, }, }); ``` 4. The native image syntax in any `.mdoc` file will now use the `<Image />` component to optimize your local images. Remote images may still be used, but will not be rendered by Astro‚Äôs `<Image />` component. src/content/blog/post.mdoc ```md <!-- Optimized by <Image /> --> ![A picture of a cat](/cat.jpg) <!-- Unoptimized <img> --> ![A picture of a dog](https://example.com/dog.jpg) ``` #### Create a custom Markdoc image tag [Section titled ‚ÄúCreate a custom Markdoc image tag‚Äù](#create-a-custom-markdoc-image-tag) A Markdoc `image` tag allows you to set additional attributes on your image that are not possible with the `![]()` syntax. For example, custom image tags allow you to use Astro‚Äôs `<Image />` component for remote images that require a `width` and `height`. The following steps will create a custom Markdoc image tag to display a `<figure>` element with a caption, using the Astro `<Image />` component to optimize the image. 1. Create a `MarkdocFigure.astro` component to receive the necessary props and render an image with a caption: src/components/MarkdocFigure.astro ```astro --- import type { ImageMetadata } from "astro"; import { Image } from "astro:assets"; interface Props { src: ImageMetadata | string; alt: string; width: number; height: number; caption: string; } const { src, alt, width, height, caption } = Astro.props; --- <figure> <Image {src} {alt} {width} {height} /> {caption && <figcaption>{caption}</figcaption>} </figure> ``` 2. Configure your custom image tag to render your Astro component: markdoc.config.mjs ```ts import { component, defineMarkdocConfig, nodes } from '@astrojs/markdoc/config'; export default defineMarkdocConfig({ tags: { image: { attributes: { width: { type: String, }, height: { type: String, }, caption: { type: String, }, ...nodes.image.attributes }, render: component('./src/components/MarkdocFigure.astro'), }, }, }); ``` 3. Use the `image` tag in Markdoc files to display a figure with caption, providing all the necessary attributes for your component: ```md {% image src="./astro-logo.png" alt="Astro Logo" width="100" height="100" caption="a caption!" /%} ``` ## Advanced Markdoc configuration [Section titled ‚ÄúAdvanced Markdoc configuration‚Äù](#advanced-markdoc-configuration) The `markdoc.config.mjs|ts` file accepts [all Markdoc configuration options](https://markdoc.dev/docs/config), including [tags](https://markdoc.dev/docs/tags) and [functions](https://markdoc.dev/docs/functions). You can pass these options from the default export in your `markdoc.config.mjs|ts` file: markdoc.config.mjs ```js import { defineMarkdocConfig } from '@astrojs/markdoc/config'; export default defineMarkdocConfig({ functions: { getCountryEmoji: { transform(parameters) { const [country] = Object.values(parameters); const countryToEmojiMap = { japan: 'üáØüáµ', spain: 'üá™üá∏', france: 'üá´üá∑', }; return countryToEmojiMap[country] ?? 'üè≥'; }, }, }, }); ``` Now, you can call this function from any Markdoc content entry: ```md ¬°Hola {% getCountryEmoji("spain") %}! ``` [See the Markdoc documentation](https://markdoc.dev/docs/functions#creating-a-custom-function) for more on using variables or functions in your content. ### Set the root HTML element [Section titled ‚ÄúSet the root HTML element‚Äù](#set-the-root-html-element) Markdoc wraps documents with an `<article>` tag by default. This can be changed from the `document` Markdoc node. This accepts an HTML element name or `null` if you prefer to remove the wrapper element: markdoc.config.mjs ```js import { defineMarkdocConfig, nodes } from '@astrojs/markdoc/config'; export default defineMarkdocConfig({ nodes: { document: { ...nodes.document, // Apply defaults for other options render: null, // default 'article' }, }, }); ``` ## Integration config options [Section titled ‚ÄúIntegration config options‚Äù](#integration-config-options) The Astro Markdoc integration handles configuring Markdoc options and capabilities that are not available through the `markdoc.config.js` file. ### `allowHTML` [Section titled ‚ÄúallowHTML‚Äù](#allowhtml) **Type:** `boolean`\ **Default:** `false` **Added in:** `@astrojs/markdoc@0.4.4` Enables writing HTML markup alongside Markdoc tags and nodes. By default, Markdoc will not recognize HTML markup as semantic content. To achieve a more Markdown-like experience, where HTML elements can be included alongside your content, set `allowHTML:true` as a `markdoc` integration option. This will enable HTML parsing in Markdoc markup. astro.config.mjs ```diff import { defineConfig } from 'astro/config'; import markdoc from '@astrojs/markdoc'; export default defineConfig({ // ... + integrations: [markdoc({ allowHTML: true })], }); ``` Caution When `allowHTML` is enabled, HTML markup inside Markdoc documents will be rendered as actual HTML elements (including `<script>`), making attack vectors like XSS possible. Ensure that any HTML markup comes from trusted sources. ### `ignoreIndentation` [Section titled ‚ÄúignoreIndentation‚Äù](#ignoreindentation) **Type:** `boolean`\ **Default:** `false` **Added in:** `@astrojs/markdoc@0.7.0` By default, any content that is indented by four spaces is treated as a code block. Unfortunately, this behavior makes it difficult to use arbitrary levels of indentation to improve the readability of documents with complex structure. When using nested tags in Markdoc, it can be helpful to indent the content inside of tags so that the level of depth is clear. To support arbitrary indentation, we have to disable the indent-based code blocks and modify several other markdown-it parsing rules that account for indent-based code blocks. These changes can be applied by enabling the ignoreIndentation option. astro.config.mjs ```diff import { defineConfig } from 'astro/config'; import markdoc from '@astrojs/markdoc'; export default defineConfig({ // ... + integrations: [markdoc({ ignoreIndentation: true })], }); ``` ```md # Welcome to Markdoc with indented tags üëã # Note: Can use either spaces or tabs for indentation {% custom-tag %} {% custom-tag %} ### Tags can be indented for better readability {% another-custom-tag %} This is easier to follow when there is a lot of nesting {% /another-custom-tag %} {% /custom-tag %} {% /custom-tag %} ``` ## Examples [Section titled ‚ÄúExamples‚Äù](#examples) * The [Astro Markdoc starter template](https://github.com/withastro/astro/tree/latest/examples/with-markdoc) shows how to use Markdoc files in your Astro project.

# @astrojs/mdx

> Learn how to use the @astrojs/mdx integration in your Astro project.

This **[Astro integration](/en/guides/integrations-guide/)** enables the usage of [MDX](https://mdxjs.com/) components and allows you to create pages as `.mdx` files. ## Why MDX? [Section titled ‚ÄúWhy MDX?‚Äù](#why-mdx) MDX allows you to use variables, JSX expressions and components within Markdown content in Astro. If you have existing content authored in MDX, this integration allows you to bring those files to your Astro project. ## Installation [Section titled ‚ÄúInstallation‚Äù](#installation) Astro includes an `astro add` command to automate the setup of official integrations. If you prefer, you can [install integrations manually](#manual-install) instead. Run one of the following commands in a new terminal window. * npm ```sh npx astro add mdx ``` * pnpm ```sh pnpm astro add mdx ``` * Yarn ```sh yarn astro add mdx ``` If you run into any issues, [feel free to report them to us on GitHub](https://github.com/withastro/astro/issues) and try the manual installation steps below. ### Manual Install [Section titled ‚ÄúManual Install‚Äù](#manual-install) First, install the `@astrojs/mdx` package: * npm ```sh npm install @astrojs/mdx ``` * pnpm ```sh pnpm add @astrojs/mdx ``` * Yarn ```sh yarn add @astrojs/mdx ``` Then, apply the integration to your `astro.config.*` file using the `integrations` property: astro.config.mjs ```diff import { defineConfig } from 'astro/config'; +import mdx from '@astrojs/mdx'; export default defineConfig({ // ... integrations: [mdx()], }); ``` ### Editor Integration [Section titled ‚ÄúEditor Integration‚Äù](#editor-integration) For editor support in [VS Code](https://code.visualstudio.com/), install the [official MDX extension](https://marketplace.visualstudio.com/items?itemName=unifiedjs.vscode-mdx). For other editors, use the [MDX language server](https://github.com/mdx-js/mdx-analyzer/tree/main/packages/language-server). ## Usage [Section titled ‚ÄúUsage‚Äù](#usage) Visit the [MDX docs](https://mdxjs.com/docs/what-is-mdx/) to learn about using standard MDX features. ## MDX in Astro [Section titled ‚ÄúMDX in Astro‚Äù](#mdx-in-astro) Adding the MDX integration enhances your Markdown authoring with JSX variables, expressions and components. It also adds extra features to standard MDX, including support for Markdown-style frontmatter in MDX. This allows you to use most of [Astro‚Äôs built-in Markdown features](/en/guides/markdown-content/). `.mdx` files must be written in [MDX syntax](https://mdxjs.com/docs/what-is-mdx/#mdx-syntax) rather than Astro‚Äôs HTML-like syntax. ### Using MDX with content collections [Section titled ‚ÄúUsing MDX with content collections‚Äù](#using-mdx-with-content-collections) To include MDX files in a content collection, make sure that your [collection loader](/en/guides/content-collections/#defining-the-collection-loader) is configured to load content from `.mdx` files: src/content.config.ts ```js import { defineCollection } from 'astro:content'; import { glob } from 'astro/loaders'; import { z } from 'astro/zod'; const blog = defineCollection({ loader: glob({ pattern: "**/*.{md,mdx}", base: "./src/blog" }), schema: z.object({ title: z.string(), description: z.string(), pubDate: z.coerce.date(), }) }); export const collections = { blog }; ``` ### Using Exported Variables in MDX [Section titled ‚ÄúUsing Exported Variables in MDX‚Äù](#using-exported-variables-in-mdx) MDX supports using `export` statements to add variables to your MDX content or to export data to a component that imports it. For example, you can export a `title` field from an MDX page or component to use as a heading with `{JSX expressions}`: /src/blog/posts/post-1.mdx ```mdx export const title = 'My first MDX post' # {title} ``` Or you can use that exported `title` in your page using `import` and `import.meta.glob()` statements: src/pages/index.astro ```astro --- const matches = import.meta.glob('./posts/*.mdx', { eager: true }); const posts = Object.values(matches); --- {posts.map(post => <p>{post.title}</p>)} ``` #### Exported Properties [Section titled ‚ÄúExported Properties‚Äù](#exported-properties) The following properties are available to a `.astro` component when using an `import` statement or `import.meta.glob()`: * **`file`** - The absolute file path (e.g. `/home/user/projects/.../file.mdx`). * **`url`** - The URL of the page (e.g. `/en/guides/markdown-content`). * **`frontmatter`** - Contains any data specified in the file‚Äôs YAML/TOML frontmatter. * **`getHeadings()`** - An async function that returns an array of all headings (`<h1>` to `<h6>`) in the file with the type: `{ depth: number; slug: string; text: string }[]`. Each heading‚Äôs `slug` corresponds to the generated ID for a given heading and can be used for anchor links. * **`<Content />`** - A component that returns the full, rendered contents of the file. * **(any `export` value)** - MDX files can also export data with an `export` statement. ### Using Frontmatter Variables in MDX [Section titled ‚ÄúUsing Frontmatter Variables in MDX‚Äù](#using-frontmatter-variables-in-mdx) The Astro MDX integration includes support for using frontmatter in MDX by default. Add frontmatter properties just as you would in Markdown files, and these variables are available to use in the template, and as named properties when importing the file somewhere else. /src/blog/posts/post-1.mdx ```mdx --- title: 'My first MDX post' author: 'Houston' --- # {frontmatter.title} Written by: {frontmatter.author} ``` ### Using Components in MDX [Section titled ‚ÄúUsing Components in MDX‚Äù](#using-components-in-mdx) After installing the MDX integration, you can import and use both [Astro components](/en/basics/astro-components/) and [UI framework components](/en/guides/framework-components/#using-framework-components) in MDX (`.mdx`) files just as you would use them in any other Astro component. Don‚Äôt forget to include a `client:directive` on your UI framework components, if necessary! See more examples of using import and export statements in the [MDX docs](https://mdxjs.com/docs/what-is-mdx/#esm). src/blog/post-1.mdx ```mdx --- title: My first post --- import ReactCounter from '../components/ReactCounter.jsx'; I just started my new Astro blog! Here is my counter component, working in MDX: <ReactCounter client:load /> ``` #### Assigning Custom Components to HTML elements [Section titled ‚ÄúAssigning Custom Components to HTML elements‚Äù](#assigning-custom-components-to-html-elements) With MDX, you can map Markdown syntax to custom components instead of their standard HTML elements. This allows you to write in standard Markdown syntax, but apply special component styling to selected elements. For example, you can create a `Blockquote.astro` component to provide custom styling for `<blockquote>` content: src/components/Blockquote.astro ```astro --- const props = Astro.props; --- <blockquote {...props} class="bg-blue-50 p-4"> <span class="text-4xl text-blue-600 mb-2">‚Äú</span> <slot /> <!-- Be sure to add a `<slot/>` for child content! --> </blockquote> ``` Import your custom component into your `.mdx` file, then export a `components` object that maps the standard HTML element to your custom component: src/blog/posts/post-1.mdx ```mdx import Blockquote from '../components/Blockquote.astro'; export const components = {blockquote: Blockquote} > This quote will be a custom Blockquote ``` Visit the [MDX website](https://mdxjs.com/table-of-components/) for a full list of HTML elements that can be overwritten as custom components. #### Passing `components` to MDX content [Section titled ‚ÄúPassing components to MDX content‚Äù](#passing-components-to-mdx-content) When rendering imported MDX content with the `<Content />` component, including rendering MDX entries using content collections, custom components can be passed via the `components` prop. These components must first be imported to make them available to the `<Content />` component. The `components` object maps HTML element names (`h1`, `h2`, `blockquote`, etc.) to your custom components. You can also include [all components exported from the MDX file itself](#assigning-custom-components-to-html-elements) using the spread operator (`...`), which must also be imported from your MDX file as `components`. If you are importing MDX directly from a single file for use in an Astro component, import both the `Content` component and any exported components from your MDX file. src/pages/page.astro ```astro --- import { Content, components } from '../content.mdx'; import Heading from '../Heading.astro'; --- <!-- Creates a custom <h1> for the # syntax, _and_ applies any custom components defined in `content.mdx` --> <Content components={{...components, h1: Heading }} /> ``` If your MDX file is a content collections entry, then use the `render()` function from `astro:content` to access the `<Content />` component. The following example passes a custom heading to the `<Content />` component via the `components` prop to be used in place of all `<h1>` HTML elements: src/pages/blog/post-1.astro ```astro --- import { getEntry, render } from 'astro:content'; import CustomHeading from '../../components/CustomHeading.astro'; const entry = await getEntry('blog', 'post-1'); const { Content } = await render(entry); --- <Content components={{ h1: CustomHeading }} /> ``` ## Configuration [Section titled ‚ÄúConfiguration‚Äù](#configuration) Once the MDX integration is installed, no configuration is necessary to use `.mdx` files in your Astro project. You can configure how your MDX is rendered with the following options: * [Options inherited from Markdown config](#options-inherited-from-markdown-config) * [`extendMarkdownConfig`](#extendmarkdownconfig) * [`recmaPlugins`](#recmaplugins) * [`optimize`](#optimize) ### Options inherited from Markdown config [Section titled ‚ÄúOptions inherited from Markdown config‚Äù](#options-inherited-from-markdown-config) All [`markdown` configuration options](/en/reference/configuration-reference/#markdown-options) can be configured separately in the MDX integration. This includes remark and rehype plugins, syntax highlighting, and more. Options will default to those in your Markdown config ([see the `extendMarkdownConfig` option](#extendmarkdownconfig) to modify this). astro.config.mjs ```js import { defineConfig } from 'astro/config'; import mdx from '@astrojs/mdx'; import remarkToc from 'remark-toc'; import rehypePresetMinify from 'rehype-preset-minify'; export default defineConfig({ // ... integrations: [ mdx({ syntaxHighlight: 'shiki', shikiConfig: { theme: 'dracula' }, remarkPlugins: [remarkToc], rehypePlugins: [rehypePresetMinify], remarkRehype: { footnoteLabel: 'Footnotes' }, gfm: false, }), ], }); ``` Caution MDX does not support passing remark and rehype plugins as a string. You should install, import, and apply the plugin function instead. See the [Markdown Options reference](/en/reference/configuration-reference/#markdown-options) for a complete list of options. ### `extendMarkdownConfig` [Section titled ‚ÄúextendMarkdownConfig‚Äù](#extendmarkdownconfig) **Type:** `boolean`\ **Default:** `true` **Added in:** `@astrojs/mdx@0.15.0` MDX will extend [your project‚Äôs existing Markdown configuration](/en/reference/configuration-reference/#markdown-options) by default. To override individual options, you can specify their equivalent in your MDX configuration. For example, say you need to disable GitHub-Flavored Markdown and apply a different set of remark plugins for MDX files. You can apply these options like so, with `extendMarkdownConfig` enabled by default: astro.config.mjs ```js import { defineConfig } from 'astro/config'; import mdx from '@astrojs/mdx'; export default defineConfig({ // ... markdown: { syntaxHighlight: 'prism', remarkPlugins: [remarkPlugin1], gfm: true, }, integrations: [ mdx({ // `syntaxHighlight` inherited from Markdown // Markdown `remarkPlugins` ignored, // only `remarkPlugin2` applied. remarkPlugins: [remarkPlugin2], // `gfm` overridden to `false` gfm: false, }), ], }); ``` You may also need to disable `markdown` config extension in MDX. For this, set `extendMarkdownConfig` to `false`: astro.config.mjs ```js import { defineConfig } from 'astro/config'; import mdx from '@astrojs/mdx'; export default defineConfig({ // ... markdown: { remarkPlugins: [remarkPlugin1], }, integrations: [ mdx({ // Markdown config now ignored extendMarkdownConfig: false, // No `remarkPlugins` applied }), ], }); ``` ### `recmaPlugins` [Section titled ‚ÄúrecmaPlugins‚Äù](#recmaplugins) **Type:** `PluggableList`\ **Default:** `[]` **Added in:** `@astrojs/mdx@0.11.5` These are plugins that modify the output [estree](https://github.com/estree/estree) directly. This is useful for modifying or injecting JavaScript variables in your MDX files. We suggest [using AST Explorer](https://astexplorer.net/) to play with estree outputs, and trying [`estree-util-visit`](https://unifiedjs.com/explore/package/estree-util-visit/) for searching across JavaScript nodes. ### `optimize` [Section titled ‚Äúoptimize‚Äù](#optimize) **Type:** `boolean | { ignoreElementNames?: string[] }`\ **Default:** `false` **Added in:** `@astrojs/mdx@0.19.5` This is an optional configuration setting to optimize the MDX output for faster builds and rendering via an internal rehype plugin. This may be useful if you have many MDX files and notice slow builds. However, this option may generate some unescaped HTML, so make sure your site‚Äôs interactive parts still work correctly after enabling it. This is disabled by default. To enable MDX optimization, add the following to your MDX integration configuration: astro.config.mjs ```js import { defineConfig } from 'astro/config'; import mdx from '@astrojs/mdx'; export default defineConfig({ // ... integrations: [ mdx({ optimize: true, }), ], }); ``` #### `ignoreElementNames` [Section titled ‚ÄúignoreElementNames‚Äù](#ignoreelementnames) **Type:** `string[]` **Added in:** `@astrojs/mdx@3.0.0` Previously known as `customComponentNames`. An optional property of `optimize` to prevent the MDX optimizer from handling certain element names, like [custom components passed to imported MDX content via the components prop](#passing-components-to-mdx-content). You will need to exclude these components from optimization as the optimizer eagerly converts content into a static string, which will break custom components that needs to be dynamically rendered. For example, the intended MDX output of the following is `<Heading>...</Heading>` in place of every `"<h1>...</h1>"`: ```astro --- import { Content, components } from '../content.mdx'; import Heading from '../Heading.astro'; --- <Content components={{ ...components, h1: Heading }} /> ``` To configure optimization for this using the `ignoreElementNames` property, specify an array of HTML element names that should be treated as custom components: astro.config.mjs ```js import { defineConfig } from 'astro/config'; import mdx from '@astrojs/mdx'; export default defineConfig({ // ... integrations: [ mdx({ optimize: { // Prevent the optimizer from handling `h1` elements ignoreElementNames: ['h1'], }, }), ], }); ``` Note that if your MDX file [configures custom components using `export const components = { ... }`](/en/guides/integrations-guide/mdx/#assigning-custom-components-to-html-elements), then you do not need to manually configure this option. The optimizer will automatically detect them. ## Examples [Section titled ‚ÄúExamples‚Äù](#examples) * The [Astro MDX starter template](https://github.com/withastro/astro/tree/latest/examples/with-mdx) shows how to use MDX files in your Astro project.

# @astrojs/netlify

> Learn how to use the @astrojs/netlify adapter to deploy your Astro project.

This adapter allows Astro to deploy your [on-demand rendered routes and features](/en/guides/on-demand-rendering/) to [Netlify](https://www.netlify.com/), including [server islands](/en/guides/server-islands/), [actions](/en/guides/actions/), and [sessions](/en/guides/sessions/). If you‚Äôre using Astro as a static site builder, you only need this adapter if you are using additional Netlify services that require a server (e.g. [Netlify Image CDN](#netlify-image-cdn-support)). Otherwise, you do not need an adapter to deploy your static site. Learn how to deploy your Astro site in our [Netlify deployment guide](/en/guides/deploy/netlify/). ## Why Astro Netlify [Section titled ‚ÄúWhy Astro Netlify‚Äù](#why-astro-netlify) [Netlify](https://www.netlify.com/) is a deployment platform that allows you to host your site by connecting directly to your GitHub repository. This adapter enhances the Astro build process to prepare your project for deployment through Netlify. ## Installation [Section titled ‚ÄúInstallation‚Äù](#installation) Astro includes an `astro add` command to automate the setup of official integrations. If you prefer, you can [install integrations manually](#manual-install) instead. Add the Netlify adapter to enable on-demand rendering in your Astro project with the `astro add` command. This will install `@astrojs/netlify` and make the appropriate changes to your `astro.config.mjs` file in one step. * npm ```sh npx astro add netlify ``` * pnpm ```sh pnpm astro add netlify ``` * Yarn ```sh yarn astro add netlify ``` Now, you can enable [on-demand rendering per page](/en/guides/on-demand-rendering/#enabling-on-demand-rendering), or set your build output configuration to `output: 'server'` to [server-render all your pages by default](/en/guides/on-demand-rendering/#server-mode). ### Manual Install [Section titled ‚ÄúManual Install‚Äù](#manual-install) First, install the Netlify adapter to your project‚Äôs dependencies using your preferred package manager: * npm ```sh npm install @astrojs/netlify ``` * pnpm ```sh pnpm add @astrojs/netlify ``` * Yarn ```sh yarn add @astrojs/netlify ``` Then, add the adapter to your `astro.config.*` file: astro.config.mjs ```diff import { defineConfig } from 'astro/config'; +import netlify from '@astrojs/netlify'; export default defineConfig({ // ... + adapter: netlify(), }); ``` ## Usage [Section titled ‚ÄúUsage‚Äù](#usage) [Read the full deployment guide here.](/en/guides/deploy/netlify/) Follow the instructions to [build your site locally](/en/guides/deploy/#building-your-site-locally). After building, you will have a `.netlify/` folder containing both [Netlify Functions](https://docs.netlify.com/functions/overview/) in the `.netlify/functions-internal/` folder and [Netlify Edge Functions](https://docs.netlify.com/edge-functions/overview/) in the`.netlify/edge-functions/` folder. To deploy your site, install the [Netlify CLI](https://docs.netlify.com/cli/get-started/) and run: ```sh netlify deploy ``` The [Netlify Blog post on Astro](https://www.netlify.com/blog/how-to-deploy-astro/) and the [Netlify Docs](https://docs.netlify.com/integrations/frameworks/astro/) provide more information on how to use this integration to deploy to Netlify. ### Running Astro middleware on Netlify Edge Functions [Section titled ‚ÄúRunning Astro middleware on Netlify Edge Functions‚Äù](#running-astro-middleware-on-netlify-edge-functions) Any Astro middleware is applied to pre-rendered pages at build-time, and to on-demand-rendered pages at runtime. To implement redirects, access control, or custom response headers for pre-rendered pages, run your middleware on Netlify Edge Functions by enabling the [`edgeMiddleware` option](/en/reference/adapter-reference/#edgemiddleware): astro.config.mjs ```diff import { defineConfig } from 'astro/config'; import netlify from '@astrojs/netlify'; export default defineConfig({ // ... adapter: netlify({ + edgeMiddleware: true, }), }); ``` When `edgeMiddleware` is enabled, an edge function will execute your middleware code for all requests including static assets, prerendered pages, and on-demand rendered pages. For on-demand rendered pages, the `context.locals` object is serialized using JSON and sent in a header for the serverless function, which performs the rendering. As a security measure, the serverless function will refuse to serve requests with a `403 Forbidden` response unless they come from the generated edge function. ### Accessing edge context from your site [Section titled ‚ÄúAccessing edge context from your site‚Äù](#accessing-edge-context-from-your-site) Netlify Edge Functions provide a [context object](https://docs.netlify.com/edge-functions/api/#netlify-specific-context-object) that includes metadata about the request such as a user‚Äôs IP, geolocation data, and cookies. This can be accessed through the `Astro.locals.netlify.context` object: ```astro --- const { geo: { city }, } = Astro.locals.netlify.context; --- <h1>Hello there, friendly visitor from {city}!</h1> ``` If you‚Äôre using TypeScript, you can [get proper typings](/en/guides/typescript/#extending-global-types) by updating `src/env.d.ts` to use `NetlifyLocals`: src/env.d.ts ```ts type NetlifyLocals = import('@astrojs/netlify').NetlifyLocals declare namespace App { interface Locals extends NetlifyLocals { // ... } } ``` This is not available on prerendered pages. ### Netlify Image CDN support [Section titled ‚ÄúNetlify Image CDN support‚Äù](#netlify-image-cdn-support) This adapter by default uses the [Netlify Image CDN](https://docs.netlify.com/image-cdn/overview/) to transform images on-the-fly without impacting build times. It‚Äôs implemented using an [Astro Image Service](/en/reference/image-service-reference/) under the hood. To opt out of Netlify‚Äôs Image CDN remote image optimization, use the `imageCDN` option: astro.config.mjs ```diff import { defineConfig } from 'astro/config'; import netlify from '@astrojs/netlify'; export default defineConfig({ // ... adapter: netlify({ + imageCDN: false, }), }); ``` If you are using images hosted on another domain, you must authorize the domain or URL patterns using the [`image.domains`](/en/reference/configuration-reference/#imagedomains) or [`image.remotePatterns`](/en/reference/configuration-reference/#imageremotepatterns) configuration options: astro.config.mjs ```diff import { defineConfig } from 'astro/config'; import netlify from '@astrojs/netlify'; export default defineConfig({ // ... adapter: netlify(), + image: { + domains: ['example.com'], + }, }); ``` For more information, see [the guide to authorizing remote images](/en/guides/images/#authorizing-remote-images). This is not required for images hosted on the same domain as your site. ### Static sites with the Netlify Adapter [Section titled ‚ÄúStatic sites with the Netlify Adapter‚Äù](#static-sites-with-the-netlify-adapter) For static sites (`output: 'static'`) hosted on Netlify, you usually don‚Äôt need an adapter. However, some deployment features are only available through an adapter. Static sites will need to install this adapter to use and configure Netlify‚Äôs [image service](#netlify-image-cdn-support). If you use `redirects` configuration in your Astro config, the Netlify adapter can be used to translate this to the proper `_redirects` format. astro.config.mjs ```js import { defineConfig } from 'astro/config'; import netlify from '@astrojs/netlify'; export default defineConfig({ // ... adapter: netlify(), redirects: { '/blog/old-post': '/blog/new-post', }, }); ``` Once you run `astro build` there will be a `dist/_redirects` file. Netlify will use that to properly route pages in production. ### Sessions [Section titled ‚ÄúSessions‚Äù](#sessions) The Astro [Sessions API](/en/guides/sessions/) allows you to easily store user data between requests. This can be used for things like user data and preferences, shopping carts, and authentication credentials. Unlike cookie storage, there are no size limits on the data, and it can be restored on different devices. Astro automatically configures [Netlify Blobs](https://docs.netlify.com/blobs/overview/) for session storage when using the Netlify adapter. If you would prefer to use a different session storage driver, you can specify it in your Astro config. See [the `session` configuration reference](/en/reference/configuration-reference/#sessiondriver) for more details. ### Caching Pages [Section titled ‚ÄúCaching Pages‚Äù](#caching-pages) On-demand rendered pages without any dynamic content can be cached to improve performance and lower resource usage. Enabling the `cacheOnDemandPages` option in the adapter will cache all server-rendered pages for up to one year: astro.config.mjs ```diff export default defineConfig({ // ... adapter: netlify({ + cacheOnDemandPages: true, }), }); ``` This can be changed on a per-page basis by adding caching headers to your response: pages/index.astro ```astro --- import Layout from '../components/Layout.astro'; Astro.response.headers.set('CDN-Cache-Control', 'public, max-age=45, must-revalidate'); --- <Layout title="Astro on Netlify"> {new Date()} </Layout> ``` With [fine-grained cache control](https://www.netlify.com/blog/swr-and-fine-grained-cache-control/), Netlify supports standard caching headers like `CDN-Cache-Control` or `Vary`. Refer to the docs to learn about implementing e.g. time to live (TTL) or stale while revalidate (SWR) caching: <https://docs.netlify.com/platform/caching> ### Skew Protection [Section titled ‚ÄúSkew Protection‚Äù](#skew-protection) **Added in:** `@astrojs/netlify@6.6.0` New Netlify‚Äôs skew protection ensures that users accessing your site during a deployment continue to receive content from the same deploy version. The Netlify adapter automatically configures skew protection for Astro features like actions, server islands, view transitions, and prefetch requests by injecting the current deploy ID into internal requests. This prevents version mismatches between the client and server during active deployments. While Astro automatically adds the skew protection header for its built-in features, if you are making your own fetch requests to your site, you can include the header manually using the `DEPLOY_ID` environment variable: ```js const response = await fetch('/api/endpoint', { headers: { 'X-Netlify-Deploy-ID': import.meta.env.DEPLOY_ID, }, }); ``` ### Including or excluding files from Netlify Functions [Section titled ‚ÄúIncluding or excluding files from Netlify Functions‚Äù](#including-or-excluding-files-from-netlify-functions) When deploying an Astro site with on-demand rendering to Netlify, the generated functions automatically trace and include server dependencies. However, you may need to customize which files are included in your Netlify Functions. #### `includeFiles` [Section titled ‚ÄúincludeFiles‚Äù](#includefiles) **Type:** `string[]`\ **Default:** `[]` **Added in:** `astro@5.3.0` The `includeFiles` property allows you to explicitly specify additional files that should be bundled with your function. This is useful for files that aren‚Äôt automatically detected as dependencies, such as: * Data files loaded using `fs` operations * Configuration files * Template files Provide an array of additional files to include with file paths relative to your project‚Äôs [`root`](/en/reference/configuration-reference/#root). Absolute paths may not work as expected. astro.config.mjs ```diff import { defineConfig } from 'astro/config'; import netlify from '@astrojs/netlify'; export default defineConfig({ // ... adapter: netlify({ + includeFiles: ['./my-data.json'], // relative to `root` }), }); ``` #### `excludeFiles` [Section titled ‚ÄúexcludeFiles‚Äù](#excludefiles) **Type:** `string[]`\ **Default:** `[]` **Added in:** `astro@5.3.0` You can use the `excludeFiles` property to prevent specific files from being bundled that would otherwise be included. This is helpful for: * Reducing bundle size * Excluding large binaries * Preventing unwanted files from being deployed Provide an array of specific files to exclude with file paths relative to your project‚Äôs [`root`](/en/reference/configuration-reference/#root). Absolute paths may not work as expected. astro.config.mjs ```diff import { defineConfig } from 'astro/config'; import netlify from '@astrojs/netlify'; export default defineConfig({ // ... adapter: netlify({ + excludeFiles: ['./src/some_big_file.jpg'], // relative to `root` }), }); ``` #### Using glob patterns [Section titled ‚ÄúUsing glob patterns‚Äù](#using-glob-patterns) Both `includeFiles` and `excludeFiles` support [glob patterns](/en/guides/imports/#glob-patterns) for matching multiple files: astro.config.mjs ```diff import { defineConfig } from 'astro/config'; import netlify from '@astrojs/netlify'; export default defineConfig({ adapter: netlify({ includeFiles: [ +'./data/**/*.json' ], excludeFiles: [ +'./node_modules/package/**/*', +'./src/**/*.test.js' ] }), }); ``` ### Local development features [Section titled ‚ÄúLocal development features‚Äù](#local-development-features) When running `astro dev`, the adapter enables several Netlify platform features to ensure the environment matches production as closely as possible. These include: * A local [Netlify Image CDN](https://docs.netlify.com/build/image-cdn/overview/) server. This is used for [images](#netlify-image-cdn-support) by default. * A local [Netlify Blobs](https://docs.netlify.com/build/data-and-storage/netlify-blobs/) server. This is used for [sessions](#sessions) by default * [Redirects, rewrites](https://docs.netlify.com/manage/routing/redirects/overview/) and [headers](https://docs.netlify.com/manage/routing/headers/) from your Netlify config * Access to [Netlify Edge Context](#accessing-edge-context-from-your-site) in on-demand pages * [Environment variables](https://docs.netlify.com/build/environment-variables/overview/) from your Netlify site These work best when your local site is [linked to a Netlify site](https://docs.netlify.com/api-and-cli-guides/cli-guides/get-started-with-cli/#link-and-unlink-sites) using `netlify link`. You can enable or disable some of these features using the [`devFeatures`](#devfeatures) option in your adapter configuration. By default, all features are enabled except for environment variables. #### `devFeatures` [Section titled ‚ÄúdevFeatures‚Äù](#devfeatures) **Type:** `boolean | object`\ **Default:** `{ images: true, environmentVariables: false }` **Added in:** `@astrojs/netlify@6.5.1` The `devFeatures` option can be either a boolean to enable or disable all features, or an object to enable specific features. astro.config.mjs ```diff import { defineConfig } from 'astro/config'; import netlify from '@astrojs/netlify'; export default defineConfig({ // ... adapter: netlify({ + devFeatures: { +// Enable Netlify Image CDN support in dev. Defaults to true. + images: false, +// Inject Netlify environment variables in dev. Defaults to false. + environmentVariables: true, + }, }), }); ``` ##### `devFeatures.images` [Section titled ‚ÄúdevFeatures.images‚Äù](#devfeaturesimages) **Type:** `boolean`\ **Default:** `true` **Added in:** `@astrojs/netlify@6.5.1` Enables support for the local [Netlify Image CDN](https://docs.netlify.com/build/image-cdn/overview/) in development. This uses a local version of the Netlify Image CDN, rather than the default Astro image service. ##### `devFeatures.environmentVariables` [Section titled ‚ÄúdevFeatures.environmentVariables‚Äù](#devfeaturesenvironmentvariables) **Type:** `boolean`\ **Default:** `false` **Added in:** `@astrojs/netlify@6.5.1` Injects environment variables from your Netlify site into the development environment. This allows you to use the same values in development as you would in production. See [the Netlify docs on environment variables](https://docs.netlify.com/build/environment-variables/overview/) for more information, including how to use different variables for different environments. ## Experimental features [Section titled ‚ÄúExperimental features‚Äù](#experimental-features) The following features are also available for use, but may be subject to breaking changes in future updates. Please follow the [`@astrojs/netlify` CHANGELOG](https://github.com/withastro/astro/tree/main/packages/integrations/netlify/CHANGELOG.md) carefully for updates if you are using these features in your project. ### `experimentalStaticHeaders` [Section titled ‚ÄúexperimentalStaticHeaders‚Äù](#experimentalstaticheaders) **Type:** `boolean`\ **Default:** `false` **Added in:** `@astrojs/netlify@6.4.0` Enables specifying custom headers for prerendered pages in Netlify‚Äôs configuration. If enabled, the adapter will save [static headers in the Framework API config file](https://docs.netlify.com/frameworks-api/#headers) when provided by Astro features, such as Content Security Policy. For example, when [experimental Content Security Policy](/en/reference/experimental-flags/csp/) is enabled, `experimentalStaticHeaders` can be used to add the CSP `headers` to your Netlify configuration, instead of creating a `<meta>` element: astro.config.mjs ```js import { defineConfig } from 'astro/config'; import netlify from '@astrojs/netlify'; export default defineConfig({ experimental: { csp: true }, adapter: netlify({ experimentalStaticHeaders: true }) }); ``` ## Examples [Section titled ‚ÄúExamples‚Äù](#examples) * The [Astro Netlify Edge Starter](https://github.com/sarahetter/astro-netlify-edge-starter) provides an example and a guide in the README. * [Browse Astro Netlify projects on GitHub](https://github.com/search?q=path%3A**%2Fastro.config.mjs+%40astrojs%2Fnetlify\&type=code) for more examples!

# @astrojs/node

> Learn how to use the @astrojs/node adapter to deploy your Astro project.

This adapter allows Astro to deploy your [on-demand rendered routes and features](/en/guides/on-demand-rendering/) to Node targets, including [server islands](/en/guides/server-islands/), [actions](/en/guides/actions/), and [sessions](/en/guides/sessions/). If you‚Äôre using Astro as a static site builder, you don‚Äôt need an adapter. ## Why Astro Node.js [Section titled ‚ÄúWhy Astro Node.js‚Äù](#why-astro-nodejs) [Node.js](https://nodejs.org/en/) is a JavaScript runtime for server-side code. @astrojs/node can be used either in standalone mode or as middleware for other http servers, such as [Express](https://expressjs.com/). ## Installation [Section titled ‚ÄúInstallation‚Äù](#installation) Astro includes an `astro add` command to automate the setup of official integrations. If you prefer, you can [install integrations manually](#manual-install) instead. Add the Node adapter to enable on-demand rendering in your Astro project with the `astro add` command. This will install `@astrojs/node` and make the appropriate changes to your `astro.config.*` file in one step. * npm ```sh npx astro add node ``` * pnpm ```sh pnpm astro add node ``` * Yarn ```sh yarn astro add node ``` Now, you can enable [on-demand rendering per page](/en/guides/on-demand-rendering/#enabling-on-demand-rendering), or set your build output configuration to `output: 'server'` to [server-render all your pages by default](/en/guides/on-demand-rendering/#server-mode). ### Manual Install [Section titled ‚ÄúManual Install‚Äù](#manual-install) First, add the Node adapter to your project‚Äôs dependencies using your preferred package manager. * npm ```sh npm install @astrojs/node ``` * pnpm ```sh pnpm add @astrojs/node ``` * Yarn ```sh yarn add @astrojs/node ``` Then, add the adapter to your `astro.config.*` file: astro.config.mjs ```diff import { defineConfig } from 'astro/config'; +import node from '@astrojs/node'; export default defineConfig({ + adapter: node({ + mode: 'standalone', + }), }); ``` ## Configuration [Section titled ‚ÄúConfiguration‚Äù](#configuration) @astrojs/node can be configured by passing options into the adapter function. The following options are available: ### `mode` [Section titled ‚Äúmode‚Äù](#mode) **Type:** `'middleware' | 'standalone'` Controls whether the adapter builds to `middleware` or `standalone` mode. * `middleware` mode allows the built output to be used as middleware for another Node.js server, like Express.js or Fastify. * `standalone` mode builds a server that automatically starts when the entry module is run. This allows you to more easily deploy your build to a host without needing additional code. astro.config.mjs ```js import { defineConfig } from 'astro/config'; import node from '@astrojs/node'; export default defineConfig({ adapter: node({ mode: 'middleware', }), }); ``` ### `experimentalDisableStreaming` [Section titled ‚ÄúexperimentalDisableStreaming‚Äù](#experimentaldisablestreaming) **Type:** `boolean`\ **Default:** `false` **Added in:** `@astrojs/node@9.3.0` Disables Astro‚Äôs default [HTML streaming](/en/guides/on-demand-rendering/#html-streaming) for pages rendered on demand. HTML streaming helps with performance and generally provides a better visitor experience. In most cases, disabling streaming is not recommended. However, when you need to disable HTML streaming (e.g. your host only supports non-streamed HTML caching at the CDN level), you can opt out of the default behavior: astro.config.mjs ```js import { defineConfig } from 'astro/config'; import node from '@astrojs/node'; export default defineConfig({ adapter: node({ mode: 'standalone', experimentalDisableStreaming: true, }), }); ``` ### `experimentalStaticHeaders` [Section titled ‚ÄúexperimentalStaticHeaders‚Äù](#experimentalstaticheaders) **Type:** `boolean`\ **Default:** `false` **Added in:** `@astrojs/node@9.3.0` If enabled, the adapter will serve the headers of prerendered pages using the `Response` object when provided by Astro features, such as Content Security Policy. For example, when [experimental Content Security Policy](/en/reference/experimental-flags/csp/) is enabled, `experimentalStaticHeaders` can be used to add the CSP headers to the `Response` object instead of creating a `<meta>` element: astro.config.mjs ```js import { defineConfig } from 'astro/config'; import node from '@astrojs/node'; export default defineConfig({ experimental: { csp: true }, adapter: node({ mode: 'standalone', experimentalStaticHeaders: true, }) }); ``` ### `experimentalErrorPageHost` [Section titled ‚ÄúexperimentalErrorPageHost‚Äù](#experimentalerrorpagehost) **Type:** `string | URL`\ **Default:** `undefined` **Added in:** `@astrojs/node@9.4.0` Specifies an alternate host for loading prerendered [custom error pages](/en/basics/astro-pages/#custom-404-error-page). Astro needs to be able to load your 404 page in order to return it in a response. By default, Astro will load prerendered custom error pages from the same host as the one that the request is made to. For example, if a request is made to `https://example.com/nonexistent-page`, Astro will attempt to load the prerendered error page from `https://example.com/404.html`. Use `experimentalErrorPageHost` when your custom error page must be loaded from a different host, such as when the server is running behind a reverse proxy or in a container that may not have access to the external host URL. You can also use this when it is more efficient to load the prerendered error page from localhost rather than via the public internet. The value can be a string or a URL object. It must be a fully-qualified URL, including the protocol (e.g., `http://localhost:4321`). Astro will always load the prerendered error page from the root path, and any path or query parameters will be ignored. ```js import { defineConfig } from 'astro/config'; import node from '@astrojs/node'; export default defineConfig({ adapter: node({ // Load pages from localhost, not the public URL. experimentalErrorPageHost: 'http://localhost:4321', }) }); ``` ## Usage [Section titled ‚ÄúUsage‚Äù](#usage) First, [performing a build](/en/guides/deploy/#building-your-site-locally). Depending on which `mode` selected (see above) follow the appropriate steps below: ### Middleware [Section titled ‚ÄúMiddleware‚Äù](#middleware) The server entrypoint is built to `./dist/server/entry.mjs` by default. This module exports a `handler` function that can be used with any framework that supports the Node `request` and `response` objects. For example, with Express: run-server.mjs ```js import express from 'express'; import { handler as ssrHandler } from './dist/server/entry.mjs'; const app = express(); // Change this based on your astro.config.mjs, `base` option. // They should match. The default value is "/". const base = '/'; app.use(base, express.static('dist/client/')); app.use(ssrHandler); app.listen(8080); ``` Or, with Fastify (>4): run-server.mjs ```js import Fastify from 'fastify'; import fastifyMiddie from '@fastify/middie'; import fastifyStatic from '@fastify/static'; import { fileURLToPath } from 'node:url'; import { handler as ssrHandler } from './dist/server/entry.mjs'; const app = Fastify({ logger: true }); await app .register(fastifyStatic, { root: fileURLToPath(new URL('./dist/client', import.meta.url)), }) .register(fastifyMiddie); app.use(ssrHandler); app.listen({ port: 8080 }); ``` Additionally, you can also pass in an object to be accessed with `Astro.locals` or in Astro middleware: run-server.mjs ```js import express from 'express'; import { handler as ssrHandler } from './dist/server/entry.mjs'; const app = express(); app.use(express.static('dist/client/')); app.use((req, res, next) => { const locals = { title: 'New title', }; ssrHandler(req, res, next, locals); }); app.listen(8080); ``` Note that middleware mode does not do file serving. You‚Äôll need to configure your HTTP framework to do that for you. By default the client assets are written to `./dist/client/`. ### Standalone [Section titled ‚ÄúStandalone‚Äù](#standalone) In standalone mode a server starts when the server entrypoint is run. By default it is built to `./dist/server/entry.mjs`. You can run it with: ```sh node ./dist/server/entry.mjs ``` For standalone mode the server handles file serving in addition to the page and API routes. #### Custom host and port [Section titled ‚ÄúCustom host and port‚Äù](#custom-host-and-port) You can override the host and port the standalone server runs on by passing them as environment variables at runtime: ```sh HOST=0.0.0.0 PORT=4321 node ./dist/server/entry.mjs ``` #### HTTPS [Section titled ‚ÄúHTTPS‚Äù](#https) By default the standalone server uses HTTP. This works well if you have a proxy server in front of it that does HTTPS. If you need the standalone server to run HTTPS itself you need to provide your SSL key and certificate. You can pass the path to your key and certification via the environment variables `SERVER_CERT_PATH` and `SERVER_KEY_PATH`. This is how you might pass them in bash: ```bash SERVER_KEY_PATH=./private/key.pem SERVER_CERT_PATH=./private/cert.pem node ./dist/server/entry.mjs ``` #### Assets [Section titled ‚ÄúAssets‚Äù](#assets) In standalone mode, assets in your `dist/client/` folder are served via the standalone server. You might be deploying these assets to a CDN, in which case the server will never actually be serving them. But in some cases, such as intranet sites, it‚Äôs fine to serve static assets directly from the application server. Assets in the `dist/client/_astro/` folder are the ones that Astro has built. These assets are all named with a hash and therefore can be given long cache headers. Internally the adapter adds this header for these assets: ```plaintext Cache-Control: public, max-age=31536000, immutable ``` ## Sessions [Section titled ‚ÄúSessions‚Äù](#sessions) The Astro [Sessions API](/en/guides/sessions/) allows you to easily store user data between requests. This can be used for things like user data and preferences, shopping carts, and authentication credentials. Unlike cookie storage, there are no size limits on the data, and it can be restored on different devices. Astro uses the local filesystem for session storage when using the Node adapter. If you would prefer to use a different session storage driver, you can specify it in your Astro config. See [the `session` configuration reference](/en/reference/configuration-reference/#sessiondriver) for more details. ## Environment variables [Section titled ‚ÄúEnvironment variables‚Äù](#environment-variables) When using the [`astro:env`](/en/guides/environment-variables/#type-safe-environment-variables) secrets or `process.env` at runtime, neither Astro nor the adapter loads environment variables for you. Some hosts may expose the environment variables you configure through their dashboard during the build and at runtime. Check your host‚Äôs documentation for setting and using environment variables within the specific platform. When self-hosting, you can load environment variables through CLI commands or configuration files as appropriate: * Inline ```shell DB_HOST=... DB_PASSWORD=... node ./dist/server/entry.mjs ``` * dotenvx ```shell npx @dotenvx/dotenvx run -- node ./dist/server/entry.mjs ``` * Docker Dockerfile ```docker FROM node:lts AS runtime WORKDIR /app COPY . . RUN npm install RUN npm run build ENV DB_HOST=... ENV DB_PASSWORD=... CMD node ./dist/server/entry.mjs ```

# @astrojs/partytown

> Learn how to use the @astrojs/partytown integration in your Astro project.

This **[Astro integration](/en/guides/integrations-guide/)** enables [Partytown](https://partytown.qwik.dev/) in your Astro project. ## Why Astro Partytown [Section titled ‚ÄúWhy Astro Partytown‚Äù](#why-astro-partytown) Partytown is a lazy-loaded library to help relocate resource intensive scripts into a [web worker](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API), and off of the [main thread](https://developer.mozilla.org/en-US/docs/Glossary/Main_thread). If you‚Äôre using third-party scripts for things like analytics or ads, Partytown is a great way to make sure that they don‚Äôt slow down your site. The Astro Partytown integration installs Partytown for you and makes sure it‚Äôs enabled on all of your pages. ## Installation [Section titled ‚ÄúInstallation‚Äù](#installation) Astro includes an `astro add` command to automate the setup of official integrations. If you prefer, you can [install integrations manually](#manual-install) instead. Run one of the following commands in a new terminal window. * npm ```sh npx astro add partytown ``` * pnpm ```sh pnpm astro add partytown ``` * Yarn ```sh yarn astro add partytown ``` If you run into any issues, [feel free to report them to us on GitHub](https://github.com/withastro/astro/issues) and try the manual installation steps below. ### Manual Install [Section titled ‚ÄúManual Install‚Äù](#manual-install) First, install the `@astrojs/partytown` package: * npm ```sh npm install @astrojs/partytown ``` * pnpm ```sh pnpm add @astrojs/partytown ``` * Yarn ```sh yarn add @astrojs/partytown ``` Then, apply the integration to your `astro.config.*` file using the `integrations` property: astro.config.mjs ```diff import { defineConfig } from 'astro/config'; +import partytown from '@astrojs/partytown'; export default defineConfig({ // ... integrations: [partytown()], }); ``` ## Usage [Section titled ‚ÄúUsage‚Äù](#usage) Partytown should be ready to go with zero config. If you have an existing 3rd party script on your site, try adding the `type="text/partytown"` attribute: ```html <script type="text/partytown" src="fancy-analytics.js"></script> ``` If you open the ‚ÄúNetwork‚Äù tab from [your browser‚Äôs dev tools](https://developer.chrome.com/docs/devtools/open/), you should see the `partytown` proxy intercepting this request. ## Configuration [Section titled ‚ÄúConfiguration‚Äù](#configuration) To configure this integration, pass a ‚Äòconfig‚Äô object to the `partytown()` function call in `astro.config.mjs`. astro.config.mjs ```js export default defineConfig({ // ... integrations: [ partytown({ config: { // options go here }, }), ], }); ``` This mirrors the [Partytown config object](https://partytown.qwik.dev/configuration/) and all options can be set in `partytown.config`. Some common configuration options for Astro projects are described on this page. ### Enabling debug mode [Section titled ‚ÄúEnabling debug mode‚Äù](#enabling-debug-mode) Partytown ships with a `debug` mode; enable or disable it by passing `true` or `false` to `config.debug`. If [`debug` mode](https://partytown.qwik.dev/debugging) is enabled, it will output detailed logs to the browser console. If this option isn‚Äôt set, `debug` mode will be on by default in [dev](/en/reference/cli-reference/#astro-dev) or [preview](/en/reference/cli-reference/#astro-preview) mode. astro.config.mjs ```js export default defineConfig({ // ... integrations: [ partytown({ // Example: Disable debug mode. config: { debug: false }, }), ], }); ``` ### Forwarding variables [Section titled ‚ÄúForwarding variables‚Äù](#forwarding-variables) Third-party scripts typically add variables to the `window` object so that you can communicate with them throughout your site. But when a script is loaded in a web-worker, it doesn‚Äôt have access to that global `window` object. To solve this, Partytown can ‚Äúpatch‚Äù variables to the global window object and forward them to the appropriate script. You can specify which variables to forward with the `config.forward` option. [Read more in Partytown‚Äôs documentation.](https://partytown.qwik.dev/forwarding-events) astro.config.mjs ```js export default defineConfig({ // ... integrations: [ partytown({ // Example: Add dataLayer.push as a forwarding-event. config: { forward: ['dataLayer.push'], }, }), ], }); ``` ### Proxying requests [Section titled ‚ÄúProxying requests‚Äù](#proxying-requests) Some third-party scripts may require [proxying](https://partytown.qwik.dev/proxying-requests/) through `config.resolveUrl()`, which runs inside the service worker. You can set this configuration option to check for a specific URL, and optionally return a proxied URL instead: astro.config.mjs ```js export default defineConfig({ // ... integrations: [ partytown({ // Example: proxy Facebook's analytics script config: { resolveUrl: (url) => { const proxyMap = { "connect.facebook.net": "my-proxy.com" } url.hostname = proxyMap[url.hostname] || url.hostname; return url; }, } }), ], }); ``` However since the `config` object is serialized when sent to the client, some limitations on functions passed to your configuration apply: * Functions cannot reference anything outside of the function scope. * Functions can only be written in JavaScript. In some advanced use cases, you may need to pass data to this function while initializing Partytown. To do so, you can set `resolveUrl()` on `window.partytown` instead of the integration config: Head.astro ```astro --- const proxyMap = { "connect.facebook.net": "my-proxy.com" }; --- <script is:inline set:html={` window.partytown = { resolveUrl: (url) => { const proxyMap = ${JSON.stringify(proxyMap)}; url.hostname = proxyMap[url.hostname] || url.hostname; return url; }, }; `} /> ``` Note that the integration config will override `window.partytown` if you set a property in both. ## Examples [Section titled ‚ÄúExamples‚Äù](#examples) * [Browse projects with Astro Partytown on GitHub](https://github.com/search?q=%22%40astrojs%2Fpartytown%22+path%3A**%2Fpackage.json\&type=code) for more examples! ## Community Resources [Section titled ‚ÄúCommunity Resources‚Äù](#community-resources) * [Implementing Google Tag Manager with Partytown and Astro](https://medium.com/@tagperfect/implementing-google-tag-manager-with-partytown-js-in-astro-my-modest-experience-983388907b35) * [Optimise Google Analytics using Partytown in Astro](https://ricostacruz.com/posts/google-analytics-in-astro)

# @astrojs/preact

> Learn how to use the @astrojs/preact framework integration to extend component support in your Astro project.

This **[Astro integration](/en/guides/integrations-guide/)** enables rendering and client-side hydration for your [Preact](https://preactjs.com/) components. ## Why Preact? [Section titled ‚ÄúWhy Preact?‚Äù](#why-preact) Preact is a library that lets you build interactive UI components for the web. If you want to build interactive features on your site using JavaScript, you may prefer using its component format instead of using browser APIs directly. Preact is also a great choice if you have previously used React. Preact provides the same API as React, but in a much smaller 3kB package. It even supports rendering many React components using the `compat` configuration option (see below). **Want to learn more about Preact before using this integration?**\ Check out [‚ÄúLearn Preact‚Äù](https://preactjs.com/tutorial), an interactive tutorial on their website. ## Installation [Section titled ‚ÄúInstallation‚Äù](#installation) Astro includes an `astro add` command to automate the setup of official integrations. If you prefer, you can [install integrations manually](#manual-install) instead. To install `@astrojs/preact`, run the following from your project directory and follow the prompts: * npm ```sh npx astro add preact ``` * pnpm ```sh pnpm astro add preact ``` * Yarn ```sh yarn astro add preact ``` If you run into any issues, [feel free to report them to us on GitHub](https://github.com/withastro/astro/issues) and try the manual installation steps below. ### Manual Install [Section titled ‚ÄúManual Install‚Äù](#manual-install) First, install the `@astrojs/preact` package: * npm ```sh npm install @astrojs/preact ``` * pnpm ```sh pnpm add @astrojs/preact ``` * Yarn ```sh yarn add @astrojs/preact ``` Most package managers will install associated peer dependencies as well. If you see a `Cannot find package 'preact'` (or similar) warning when you start up Astro, you‚Äôll need to install Preact: * npm ```sh npm install preact ``` * pnpm ```sh pnpm add preact ``` * Yarn ```sh yarn add preact ``` Then, apply the integration to your `astro.config.*` file using the `integrations` property: astro.config.mjs ```diff import { defineConfig } from 'astro/config'; +import preact from '@astrojs/preact'; export default defineConfig({ // ... integrations: [preact()], }); ``` And add the following code to the `tsconfig.json` file. tsconfig.json ```diff { "extends": "astro/tsconfigs/strict", "include": [".astro/types.d.ts", "**/*"], "exclude": ["dist"], +"compilerOptions": { +"jsx": "react-jsx", +"jsxImportSource": "preact" + } } ``` ## Usage [Section titled ‚ÄúUsage‚Äù](#usage) To use your first Preact component in Astro, head to our [UI framework documentation](/en/guides/framework-components/#using-framework-components). You‚Äôll explore: * üì¶ how framework components are loaded, * üíß client-side hydration options, and * ü§ù opportunities to mix and nest frameworks together Also check our [Astro Integration Documentation](/en/guides/integrations-guide/) for more on integrations. ## Configuration [Section titled ‚ÄúConfiguration‚Äù](#configuration) The Astro Preact integration handles how Preact components are rendered and it has its own options. Change these in the `astro.config.mjs` file which is where your project‚Äôs integration settings live. For basic usage, you do not need to configure the Preact integration. ### `compat` [Section titled ‚Äúcompat‚Äù](#compat) **Type:** `boolean` **Added in:** `@astrojs/preact@0.3.0` You can enable `preact/compat`, Preact‚Äôs compatibility layer for rendering React components without needing to install or ship React‚Äôs larger libraries to your users‚Äô web browsers. To do so, pass an object to the Preact integration and set `compat: true`. astro.config.mjs ```js import { defineConfig } from 'astro/config'; import preact from '@astrojs/preact'; export default defineConfig({ integrations: [preact({ compat: true })], }); ``` With the `compat` option enabled, the Preact integration will render React components as well as Preact components in your project and also allow you to import React components inside Preact components. Read more in [‚ÄúSwitching to Preact (from React)‚Äù](https://preactjs.com/guide/v10/switching-to-preact) on the Preact website. When importing React component libraries, in order to swap out the `react` and `react-dom` dependencies as `preact/compat`, you can use [`overrides`](https://docs.npmjs.com/cli/v8/configuring-npm/package-json#overrides) to do so. package.json ```json { "overrides": { "react": "npm:@preact/compat@latest", "react-dom": "npm:@preact/compat@latest" } } ``` Check out the [`pnpm` overrides](https://pnpm.io/package_json#pnpmoverrides) and [`yarn` resolutions](https://yarnpkg.com/configuration/manifest#resolutions) docs for their respective overrides features. ### `devtools` [Section titled ‚Äúdevtools‚Äù](#devtools) **Type:** `boolean` **Added in:** `@astrojs/preact@3.3.0` You can enable [Preact devtools](https://preactjs.github.io/preact-devtools/) in development by passing an object with `devtools: true` to your `preact()` integration config: astro.config.mjs ```js import { defineConfig } from 'astro/config'; import preact from '@astrojs/preact'; export default defineConfig({ // ... integrations: [preact({ devtools: true })], }); ``` ## Options [Section titled ‚ÄúOptions‚Äù](#options) ### Combining multiple JSX frameworks [Section titled ‚ÄúCombining multiple JSX frameworks‚Äù](#combining-multiple-jsx-frameworks) When you are using multiple JSX frameworks (React, Preact, Solid) in the same project, Astro needs to determine which JSX framework-specific transformations should be used for each of your components. If you have only added one JSX framework integration to your project, no extra configuration is needed. Use the `include` (required) and `exclude` (optional) configuration options to specify which files belong to which framework. Provide an array of files and/or folders to `include` for each framework you are using. Wildcards may be used to include multiple file paths. We recommend placing common framework components in the same folder (e.g. `/components/react/` and `/components/solid/`) to make specifying your includes easier, but this is not required: astro.config.mjs ```js import { defineConfig } from 'astro/config'; import preact from '@astrojs/preact'; import react from '@astrojs/react'; import svelte from '@astrojs/svelte'; import vue from '@astrojs/vue'; import solid from '@astrojs/solid-js'; export default defineConfig({ // Enable many frameworks to support all different kinds of components. // No `include` is needed if you are only using a single JSX framework! integrations: [ preact({ include: ['**/preact/*'], }), react({ include: ['**/react/*'], }), solid({ include: ['**/solid/*'], }), ], }); ``` ## Examples [Section titled ‚ÄúExamples‚Äù](#examples) * The [Astro Preact example](https://github.com/withastro/astro/tree/latest/examples/framework-preact) shows how to use an interactive Preact component in an Astro project. * The [Astro Nanostores example](https://github.com/withastro/astro/tree/latest/examples/with-nanostores) shows how to share state between different components ‚Äî and even different frameworks! ‚Äî in an Astro project.

# @astrojs/prefetch

> The deprecated prefetch integration.

Removed `@astrojs/prefetch` has been replaced by the [built-in `prefetch` feature](/en/guides/prefetch/) introduced in Astro 3.5. See the [migration guide](/en/guides/prefetch/#migrating-from-astrojsprefetch) for instructions on updating an older project. If you are still using this integration in a pre-v3.5 Astro project, you can read an archived copy of [the `@astrojs/prefetch` README](https://github.com/withastro/astro/blob/c47478bbf6b21973419f25234c68efb59466b368/packages%2Fintegrations%2Fprefetch%2FREADME.md) on GitHub.

# @astrojs/react

> Learn how to use the @astrojs/react framework integration to extend component support in your Astro project.

This **[Astro integration](/en/guides/integrations-guide/)** enables rendering and client-side hydration for your [React](https://react.dev/) components. ## Installation [Section titled ‚ÄúInstallation‚Äù](#installation) Astro includes an `astro add` command to automate the setup of official integrations. If you prefer, you can [install integrations manually](#manual-install) instead. To install `@astrojs/react`, run the following from your project directory and follow the prompts: * npm ```sh npx astro add react ``` * pnpm ```sh pnpm astro add react ``` * Yarn ```sh yarn astro add react ``` If you run into any issues, [feel free to report them to us on GitHub](https://github.com/withastro/astro/issues) and try the manual installation steps below. ### Manual Install [Section titled ‚ÄúManual Install‚Äù](#manual-install) First, install the `@astrojs/react` package: * npm ```sh npm install @astrojs/react ``` * pnpm ```sh pnpm add @astrojs/react ``` * Yarn ```sh yarn add @astrojs/react ``` Most package managers will install associated peer dependencies as well. If you see a `Cannot find package 'react'` (or similar) warning when you start up Astro, you‚Äôll need to install `react` and `react-dom` with its type definitions: * npm ```sh npm install react react-dom @types/react @types/react-dom ``` * pnpm ```sh pnpm add react react-dom @types/react @types/react-dom ``` * Yarn ```sh yarn add react react-dom @types/react @types/react-dom ``` Then, apply the integration to your `astro.config.*` file using the `integrations` property: astro.config.mjs ```diff import { defineConfig } from 'astro/config'; +import react from '@astrojs/react'; export default defineConfig({ // ... integrations: [react()], }); ``` And add the following code to the `tsconfig.json` file. tsconfig.json ```diff { "extends": "astro/tsconfigs/strict", "include": [".astro/types.d.ts", "**/*"], "exclude": ["dist"], +"compilerOptions": { +"jsx": "react-jsx", +"jsxImportSource": "react" + } } ``` ## Getting started [Section titled ‚ÄúGetting started‚Äù](#getting-started) To use your first React component in Astro, head to our [UI framework documentation](/en/guides/framework-components/#using-framework-components). You‚Äôll explore: * üì¶ how framework components are loaded, * üíß client-side hydration options, and * ü§ù opportunities to mix and nest frameworks together ## Integrate Actions with `useActionState()` [Section titled ‚ÄúIntegrate Actions with useActionState()‚Äù](#integrate-actions-with-useactionstate) The `@astrojs/react` integration provides two functions for use with [Astro Actions](/en/guides/actions/): `withState()` and `getActionState()`. These are used with [React‚Äôs useActionState() hook](https://react.dev/reference/react/useActionState) to read and update client-side state when triggering actions during form submission. ### `withState()` [Section titled ‚ÄúwithState()‚Äù](#withstate) **Type:** `(action: FormFn<T>) => (state: T, formData: FormData) => FormFn<T>` **Added in:** `@astrojs/react@4.4.0` New You can pass `withState()` and the action you want to trigger to React‚Äôs `useActionState()` hook as the form action function. The example below passes a `like` action to increase a counter along with an initial state of `0` likes. Like.tsx ```diff import { actions } from 'astro:actions'; +import { withState } from '@astrojs/react/actions'; import { useActionState } from "react"; export function Like({ postId }: { postId: string }) { const [state, action, pending] = useActionState( +withState(actions.like), { data: 0, error: undefined }, // initial likes and errors ); return ( <form action={action}> <input type="hidden" name="postId" value={postId} /> <button disabled={pending}>{state.data} ‚ù§Ô∏è</button> </form> ); } ``` The `withState()` function will match the action‚Äôs types with React‚Äôs expectations and preserve metadata used for progressive enhancement, allowing it to work even when JavaScript is disabled on the user‚Äôs device. ### `getActionState()` [Section titled ‚ÄúgetActionState()‚Äù](#getactionstate) **Type:** `(context: ActionAPIContext) => Promise<T>` **Added in:** `@astrojs/react@4.4.0` New You can access the state stored by `useActionState()` on the server in your action `handler` with `getActionState()`. It accepts the [Astro API context](/en/reference/api-reference/#the-context-object), and optionally, you can apply a type to the result. The example below gets the current value of likes from a counter, typed as a number, in order to create an incrementing `like` action: actions.ts ```diff import { defineAction, type SafeResult } from 'astro:actions'; import { z } from 'astro/zod'; +import { getActionState } from '@astrojs/react/actions'; export const server = { like: defineAction({ input: z.object({ postId: z.string(), }), handler: async ({ postId }, ctx) => { const { data: currentLikes = 0, error } = await getActionState<SafeResult<any, number>>(ctx); // handle errors if (error) throw error; // write to database return currentLikes + 1; }, }) }; ``` ## Options [Section titled ‚ÄúOptions‚Äù](#options) ### Combining multiple JSX frameworks [Section titled ‚ÄúCombining multiple JSX frameworks‚Äù](#combining-multiple-jsx-frameworks) When you are using multiple JSX frameworks (React, Preact, Solid) in the same project, Astro needs to determine which JSX framework-specific transformations should be used for each of your components. If you have only added one JSX framework integration to your project, no extra configuration is needed. Use the `include` (required) and `exclude` (optional) configuration options to specify which files belong to which framework. Provide an array of files and/or folders to `include` for each framework you are using. Wildcards may be used to include multiple file paths. We recommend placing common framework components in the same folder (e.g. `/components/react/` and `/components/solid/`) to make specifying your includes easier, but this is not required: astro.config.mjs ```js import { defineConfig } from 'astro/config'; import preact from '@astrojs/preact'; import react from '@astrojs/react'; import svelte from '@astrojs/svelte'; import vue from '@astrojs/vue'; import solid from '@astrojs/solid-js'; export default defineConfig({ // Enable many frameworks to support all different kinds of components. // No `include` is needed if you are only using a single JSX framework! integrations: [ preact({ include: ['**/preact/*'], }), react({ include: ['**/react/*'], }), solid({ include: ['**/solid/*'], }), ], }); ``` ### Children parsing [Section titled ‚ÄúChildren parsing‚Äù](#children-parsing) Children passed into a React component from an Astro component are parsed as plain strings, not React nodes. For example, the `<ReactComponent />` below will only receive a single child element: ```astro --- import ReactComponent from './ReactComponent'; --- <ReactComponent> <div>one</div> <div>two</div> </ReactComponent> ``` If you are using a library that *expects* more than one child element to be passed, for example so that it can slot certain elements in different places, you might find this to be a blocker. You can set the experimental flag `experimentalReactChildren` to tell Astro to always pass children to React as React virtual DOM nodes. There is some runtime cost to this, but it can help with compatibility. You can enable this option in the configuration for the React integration: astro.config.mjs ```diff import { defineConfig } from 'astro/config'; import react from '@astrojs/react'; export default defineConfig({ // ... integrations: [ react({ + experimentalReactChildren: true, }), ], }); ``` ### Disable streaming (experimental) [Section titled ‚ÄúDisable streaming (experimental)‚Äù](#disable-streaming-experimental) Astro streams the output of React components by default. However, you can disable this behavior by enabling the `experimentalDisableStreaming` option. This is particularly helpful for supporting libraries that don‚Äôt work well with streaming, like some CSS-in-JS solutions. To disable streaming for all React components in your project, configure `@astrojs/react` with `experimentalDisableStreaming: true`: astro.config.mjs ```diff import { defineConfig } from 'astro/config'; import react from '@astrojs/react'; export default defineConfig({ // ... integrations: [ react({ + experimentalDisableStreaming: true, }) ] }); ```

# @astrojs/sitemap

> Learn how to use the @astrojs/sitemap integration in your Astro project.

This **[Astro integration](/en/guides/integrations-guide/)** generates a sitemap based on your pages when you build your Astro project. ## Why Astro Sitemap [Section titled ‚ÄúWhy Astro Sitemap‚Äù](#why-astro-sitemap) A Sitemap is an XML file that outlines all of the pages, videos, and files on your site. Search engines like Google read this file to crawl your site more efficiently. [See Google‚Äôs own advice on sitemaps](https://developers.google.com/search/docs/advanced/sitemaps/overview) to learn more. A sitemap file is recommended for large multi-page sites. If you don‚Äôt use a sitemap, most search engines will still be able to list your site‚Äôs pages, but a sitemap is a great way to ensure that your site is as search engine friendly as possible. With Astro Sitemap, you don‚Äôt have to worry about creating this XML file yourself: the Astro Sitemap integration will crawl your statically-generated routes and create the sitemap file, including [dynamic routes](/en/guides/routing/#dynamic-routes) like `[...slug]` or `src/pages/[lang]/[version]/info.astro` generated by `getStaticPaths()`. This integration cannot generate sitemap entries for dynamic routes in [SSR mode](/en/guides/on-demand-rendering/). ## Installation [Section titled ‚ÄúInstallation‚Äù](#installation) Astro includes an `astro add` command to automate the setup of official integrations. If you prefer, you can [install integrations manually](#manual-install) instead. Run one of the following commands in a new terminal window. * npm ```sh npx astro add sitemap ``` * pnpm ```sh pnpm astro add sitemap ``` * Yarn ```sh yarn astro add sitemap ``` If you run into any issues, [feel free to report them to us on GitHub](https://github.com/withastro/astro/issues) and try the manual installation steps below. ### Manual Install [Section titled ‚ÄúManual Install‚Äù](#manual-install) First, install the `@astrojs/sitemap` package using your package manager. * npm ```sh npm install @astrojs/sitemap ``` * pnpm ```sh pnpm add @astrojs/sitemap ``` * Yarn ```sh yarn add @astrojs/sitemap ``` Then, apply the integration to your `astro.config.*` file using the `integrations` property: ```diff import { defineConfig } from 'astro/config'; +import sitemap from '@astrojs/sitemap'; export default defineConfig({ // ... integrations: [sitemap()], }); ``` ## Usage [Section titled ‚ÄúUsage‚Äù](#usage) `@astrojs/sitemap` needs to know your site‚Äôs deployed URL to generate a sitemap. Add your site‚Äôs URL as the [`site`](/en/reference/configuration-reference/#site) option in `astro.config.mjs`. This must begin with `http://` or `https://`. astro.config.mjs ```js import { defineConfig } from 'astro/config'; import sitemap from '@astrojs/sitemap'; export default defineConfig({ site: 'https://example.com', integrations: [sitemap()], // ... }); ``` With the sitemap integration configured, `sitemap-index.xml` and `sitemap-0.xml` files will be added to your output directory when building your site. `sitemap-index.xml` links to all the numbered sitemap files. `sitemap-0.xml` lists the pages on your site. For extremely large sites, there may also be additional numbered files like `sitemap-1.xml` and `sitemap-2.xml`. ### Sitemap discovery [Section titled ‚ÄúSitemap discovery‚Äù](#sitemap-discovery) You can make it easier for crawlers to find your sitemap with links in your site‚Äôs `<head>` and `robots.txt` file. #### Sitemap link in `<head>` [Section titled ‚ÄúSitemap link in \<head>‚Äù](#sitemap-link-in-head) Add a `<link rel="sitemap">` element to your site‚Äôs `<head>` pointing to the sitemap index file: src/layouts/Layout.astro ```diff <head> <link rel="sitemap" href="/sitemap-index.xml" /> </head> ``` #### Sitemap link in `robots.txt` [Section titled ‚ÄúSitemap link in robots.txt‚Äù](#sitemap-link-in-robotstxt) If you have a `robots.txt` for your website, you can add the URL for the sitemap index to help crawlers: public/robots.txt ```diff User-agent: * Allow: / +Sitemap: https://<YOUR SITE>/sitemap-index.xml ``` If you want to reuse the `site` value from `astro.config.mjs`, you can also generate `robots.txt` dynamically. Instead of using a static file in the `public/` directory, create a `src/pages/robots.txt.ts` file and add the following code: src/pages/robots.txt.ts ```ts import type { APIRoute } from 'astro'; const getRobotsTxt = (sitemapURL: URL) => `\ User-agent: * Allow: / Sitemap: ${sitemapURL.href} `; export const GET: APIRoute = ({ site }) => { const sitemapURL = new URL('sitemap-index.xml', site); return new Response(getRobotsTxt(sitemapURL)); }; ``` ## Configuration [Section titled ‚ÄúConfiguration‚Äù](#configuration) To configure this integration, pass an object to the `sitemap()` function in `astro.config.mjs`. astro.config.mjs ```js import { defineConfig } from 'astro/config'; import sitemap from '@astrojs/sitemap'; export default defineConfig({ integrations: [ sitemap({ // configuration options }), ], }); ``` ### `filter` [Section titled ‚Äúfilter‚Äù](#filter) **Type:** `(page: string) => boolean` All pages are included in your sitemap by default. By adding a custom `filter` function, you can filter included pages by URL. astro.config.mjs ```diff import { defineConfig } from 'astro/config'; import sitemap from '@astrojs/sitemap'; export default defineConfig({ site: 'https://example.com', integrations: [ sitemap({ +filter: (page) => page !== 'https://example.com/secret-vip-lounge/', }), ], }); ``` The function will be called for every page on your site. The `page` function parameter is the full URL of the page currently under consideration, including your `site` domain. Return `true` to include the page in your sitemap, and `false` to leave it out. To filter multiple pages, add arguments with target URLs. astro.config.mjs ```js import { defineConfig } from 'astro/config'; import sitemap from '@astrojs/sitemap'; export default defineConfig({ site: 'https://example.com', integrations: [ sitemap({ filter: (page) => page !== 'https://example.com/secret-vip-lounge-1/' && page !== 'https://example.com/secret-vip-lounge-2/' && page !== 'https://example.com/secret-vip-lounge-3/' && page !== 'https://example.com/secret-vip-lounge-4/', }), ], }); ``` ### `customPages` [Section titled ‚ÄúcustomPages‚Äù](#custompages) **Type:** `string[]` An array of externally-generated pages to be included in the generated sitemap file. Use this option to include pages in your sitemap that are a part of your deployed site but are not created by Astro. astro.config.mjs ```diff import { defineConfig } from 'astro/config'; import sitemap from '@astrojs/sitemap'; export default defineConfig({ site: 'https://example.com', integrations: [ sitemap({ + customPages: ['https://example.com/external-page1', 'https://example.com/external-page2'], }), ], }); ``` ### `customSitemaps` [Section titled ‚ÄúcustomSitemaps‚Äù](#customsitemaps) **Type:** `string[]`\ **Default:** `[]` **Added in:** `@astrojs/sitemap@3.5.0` An array of externally-generated sitemaps to be included in the `sitemap-index.xml` file along with the generated sitemap entries. Use this option to include external sitemaps in the `sitemap-index.xml` file created by Astro for sections of your deployed site that have their own sitemaps not created by Astro. This is helpful when you host multiple services under the same domain. astro.config.mjs ```diff import { defineConfig } from 'astro/config'; import sitemap from '@astrojs/sitemap'; export default defineConfig({ site: 'https://example.com', integrations: [ sitemap({ + customSitemaps: ['https://example.com/blog/sitemap.xml', 'https://example.com/shop/sitemap.xml'], }), ], }); ``` ### `entryLimit` [Section titled ‚ÄúentryLimit‚Äù](#entrylimit) **Type:** `number`\ **Default:** `45000` The maximum number entries per sitemap file. The default value is 45000. A sitemap index and multiple sitemaps are created if you have more entries. See this [explanation of splitting up a large sitemap](https://developers.google.com/search/docs/advanced/sitemaps/large-sitemaps). astro.config.mjs ```diff import { defineConfig } from 'astro/config'; import sitemap from '@astrojs/sitemap'; export default defineConfig({ site: 'https://example.com', integrations: [ sitemap({ + entryLimit: 10000, }), ], }); ``` ### `changefreq`, `lastmod`, and `priority` [Section titled ‚Äúchangefreq, lastmod, and priority‚Äù](#changefreq-lastmod-and-priority) **Type:** `{ changefreq?: ChangeFreq; lastmod?: Date; priority?: number; }` **Added in:** `@astrojs/sitemap@0.2.0` These options correspond to the `<changefreq>`, `<lastmod>`, and `<priority>` tags in the [Sitemap XML specification.](https://www.sitemaps.org/protocol.html) Note that `changefreq` and `priority` are ignored by Google. astro.config.mjs ```diff import { defineConfig } from 'astro/config'; import sitemap from '@astrojs/sitemap'; export default defineConfig({ site: 'https://example.com', integrations: [ sitemap({ + changefreq: 'weekly', + priority: 0.7, + lastmod: new Date('2022-02-24'), }), ], }); ``` ### `serialize` [Section titled ‚Äúserialize‚Äù](#serialize) **Type:** `(item: SitemapItem) => SitemapItem | Promise<SitemapItem | undefined> | undefined` A function called for each sitemap entry just before writing to a disk. This function can be asynchronous. It receives as its parameter a `SitemapItem` object that can have these properties: * `url` (absolute page URL). This is the only property that is guaranteed to be on `SitemapItem`. * `changefreq` * `lastmod` (ISO formatted date, `String` type) * `priority` * `links`. This `links` property contains a `LinkItem` list of alternate pages including a parent page. The `LinkItem` type has two fields: `url` (the fully-qualified URL for the version of this page for the specified language) and `lang` (a supported language code targeted by this version of the page). The `serialize` function should return `SitemapItem`, touched or not. The example below shows the ability to add sitemap specific properties individually. astro.config.mjs ```diff import { defineConfig } from 'astro/config'; import sitemap from '@astrojs/sitemap'; export default defineConfig({ site: 'https://example.com', integrations: [ sitemap({ +serialize(item) { +if (/exclude-from-sitemap/.test(item.url)) { +return undefined; + } +if (/your-special-page/.test(item.url)) { +item.changefreq = 'daily'; +item.lastmod = new Date(); +item.priority = 0.9; + } +return item; + }, }), ], }); ``` ### `chunks` [Section titled ‚Äúchunks‚Äù](#chunks) **Type:** `Record<string, (item: SitemapItem) => SitemapItem | undefined>` **Added in:** `@astrojs/sitemap@3.7.0` New A map of functions that allows you to split your sitemap into multiple files based on custom logic. Each key in the object becomes the name of a separate sitemap file, and its corresponding function determines which URLs will be included in that chunk. This can be useful for instance if a specific section of your website changes very often and you‚Äôd like to specify a different change frequency for its entries. Each chunk function receives a `SitemapItem` and for each item returns either: * the modified `SitemapItem`, if the URL should be included in this chunk * `undefined`, if the URL should not be included in this chunk The example below shows how to split URLs into different sitemap files based on their path: astro.config.mjs ```diff import { defineConfig } from 'astro/config'; import sitemap from '@astrojs/sitemap'; export default defineConfig({ site: 'https://example.com', integrations: [ sitemap({ + chunks: { +'blog': (item) => { +if (/blog/.test(item.url)) { +item.changefreq = 'weekly'; +item.lastmod = new Date(); +item.priority = 0.9; +return item; + } + }, +'glossary': (item) => { +if (/glossary/.test(item.url)) { +item.changefreq = 'monthly'; +item.lastmod = new Date(); +item.priority = 0.7; +return item; + } + } + }, }), ], }); ``` This configuration will generate the following files: * `sitemap-blog-0.xml` * `sitemap-glossary-0.xml` URLs that don‚Äôt match any chunk will be placed in a default `sitemap-pages-0.xml` file. ### `i18n` [Section titled ‚Äúi18n‚Äù](#i18n) **Type:** `{ defaultLocale: string; locales: Record<string, string>; }` To [localize a sitemap](https://developers.google.com/search/docs/advanced/crawling/localized-versions#all-method-guidelines), pass an object to this `i18n` option. This object has two required properties: * `defaultLocale`: Its value must exist as one of `locales` keys. * `locales`: key/value - pairs. The key is used to look for a locale part in a page path. The value is a [language attribute](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/lang), only English alphabet and hyphen allowed. astro.config.mjs ```diff import { defineConfig } from 'astro/config'; import sitemap from '@astrojs/sitemap'; export default defineConfig({ site: 'https://example.com', integrations: [ sitemap({ + i18n: { + defaultLocale: 'en', // All urls that don't contain `es` or `fr` after `https://example.com/` will be treated as default locale, i.e. `en` + locales: { + en: 'en-US', // The `defaultLocale` value must present in `locales` keys + es: 'es-ES', + fr: 'fr-CA', + }, + }, }), ], }); ``` The resulting sitemap looks like this: sitemap-0.xml ```xml ... <url> <loc>https://example.com/</loc> <xhtml:link rel="alternate" hreflang="en-US" href="https://example.com/"/> <xhtml:link rel="alternate" hreflang="es-ES" href="https://example.com/es/"/> <xhtml:link rel="alternate" hreflang="fr-CA" href="https://example.com/fr/"/> </url> <url> <loc>https://example.com/es/</loc> <xhtml:link rel="alternate" hreflang="en-US" href="https://example.com/"/> <xhtml:link rel="alternate" hreflang="es-ES" href="https://example.com/es/"/> <xhtml:link rel="alternate" hreflang="fr-CA" href="https://example.com/fr/"/> </url> <url> <loc>https://example.com/fr/</loc> <xhtml:link rel="alternate" hreflang="en-US" href="https://example.com/"/> <xhtml:link rel="alternate" hreflang="es-ES" href="https://example.com/es/"/> <xhtml:link rel="alternate" hreflang="fr-CA" href="https://example.com/fr/"/> </url> <url> <loc>https://example.com/es/second-page/</loc> <xhtml:link rel="alternate" hreflang="es-ES" href="https://example.com/es/second-page/"/> <xhtml:link rel="alternate" hreflang="fr-CA" href="https://example.com/fr/second-page/"/> <xhtml:link rel="alternate" hreflang="en-US" href="https://example.com/second-page/"/> </url> ... ``` ### `xslURL` [Section titled ‚ÄúxslURL‚Äù](#xslurl) **Type:** `string` **Added in:** `@astrojs/sitemap@3.2.0` The URL of an XSL stylesheet to style and prettify your sitemap. The value set can be either a path relative to your configured `site` URL for a local stylesheet, or can be an absolute URL link to an external stylesheet. astro.config.mjs ```diff import { defineConfig } from 'astro/config'; import sitemap from '@astrojs/sitemap'; export default defineConfig({ site: 'https://example.com', integrations: [ sitemap({ + xslURL: '/sitemap.xsl' }), ], }); ``` ### `filenameBase` [Section titled ‚ÄúfilenameBase‚Äù](#filenamebase) **Type:** `string`\ **Default:** `sitemap` **Added in:** `@astrojs/sitemap@3.4.0` The name prefix string used when generating the sitemap XML files. The default value is `sitemap`. This option may be useful when integrating an Astro site into a domain with preexisting sitemap files. astro.config.mjs ```diff import { defineConfig } from 'astro/config'; import sitemap from '@astrojs/sitemap'; export default defineConfig({ site: 'https://example.com', integrations: [ sitemap({ + filenameBase: 'astronomy-sitemap' }), ], }); ``` The given configuration will generate sitemap files at `https://example.com/astronomy-sitemap-0.xml` and `https://example.com/astronomy-sitemap-index.xml`. ### `namespaces` [Section titled ‚Äúnamespaces‚Äù](#namespaces) **Type:** `{ news?: boolean; xhtml?: boolean; image?: boolean; video?: boolean; }`\ **Default:** `{ news: true, xhtml: true, image: true, video: true }` **Added in:** `@astrojs/sitemap@3.6.0` An object of XML namespaces to exclude from the generated sitemap. Excluding unused namespaces can help create more focused sitemaps that are faster for search engines to parse and use less bandwidth. For example, if your site doesn‚Äôt have news content, videos, or multiple languages, you can exclude those namespaces to reduce XML bloat. By default, all configurable namespaces (`news`, `xhtml`, `image`, and `video`) are included in your generated sitemap XML. To exclude one or more of these namespaces from your sitemap generation, add a `namespaces` configuration object and set individual options to `false`: astro.config.mjs ```diff import { defineConfig } from 'astro/config'; import sitemap from '@astrojs/sitemap'; export default defineConfig({ site: 'https://example.com', integrations: [ sitemap({ + namespaces: { + news: false, + xhtml: false, + } }) ] }); ``` ## Examples [Section titled ‚ÄúExamples‚Äù](#examples) * The official Astro website uses Astro Sitemap to generate [its sitemap](https://astro.build/sitemap-index.xml). * [Browse projects with Astro Sitemap on GitHub](https://github.com/search?q=%22%40astrojs%2Fsitemap%22+path%3Apackage.json\&type=Code) for more examples!

# @astrojs/solid-js

> Learn how to use the @astrojs/solid-js framework integration to extend component support in your Astro project.

This **[Astro integration](/en/guides/integrations-guide/)** enables rendering and client-side hydration for your [SolidJS](https://www.solidjs.com/) components. ## Installation [Section titled ‚ÄúInstallation‚Äù](#installation) Astro includes an `astro add` command to automate the setup of official integrations. If you prefer, you can [install integrations manually](#manual-install) instead. To install `@astrojs/solid-js`, run the following from your project directory and follow the prompts: * npm ```sh npx astro add solid ``` * pnpm ```sh pnpm astro add solid ``` * Yarn ```sh yarn astro add solid ``` If you run into any issues, [feel free to report them to us on GitHub](https://github.com/withastro/astro/issues) and try the manual installation steps below. ### Manual Install [Section titled ‚ÄúManual Install‚Äù](#manual-install) First, install the `@astrojs/solid-js` package: * npm ```sh npm install @astrojs/solid-js ``` * pnpm ```sh pnpm add @astrojs/solid-js ``` * Yarn ```sh yarn add @astrojs/solid-js ``` Most package managers will install associated peer dependencies as well. If you see a `Cannot find package 'solid-js'` (or similar) warning when you start up Astro, you‚Äôll need to install SolidJS: * npm ```sh npm install solid-js ``` * pnpm ```sh pnpm add solid-js ``` * Yarn ```sh yarn add solid-js ``` Then, apply the integration to your `astro.config.*` file using the `integrations` property: astro.config.mjs ```diff import { defineConfig } from 'astro/config'; +import solidJs from '@astrojs/solid-js'; export default defineConfig({ // ... integrations: [solidJs()], }); ``` And add the following code to the `tsconfig.json` file. tsconfig.json ```diff { "extends": "astro/tsconfigs/strict", "include": [".astro/types.d.ts", "**/*"], "exclude": ["dist"], +"compilerOptions": { +"jsx": "preserve", +"jsxImportSource": "solid-js" + } } ``` ## Getting started [Section titled ‚ÄúGetting started‚Äù](#getting-started) To use your first SolidJS component in Astro, head to our [UI framework documentation](/en/guides/framework-components/#using-framework-components). You‚Äôll explore: * üì¶ how framework components are loaded, * üíß client-side hydration options, and * ü§ù opportunities to mix and nest frameworks together ## Configuration [Section titled ‚ÄúConfiguration‚Äù](#configuration) ### `devtools` [Section titled ‚Äúdevtools‚Äù](#devtools) **Type:** `boolean` **Added in:** `@astrojs/solid-js@4.2.0` You can enable [Solid DevTools](https://github.com/thetarnav/solid-devtools) in development by passing an object with `devtools: true` to your `solid()` integration config and adding `solid-devtools` to your project dependencies: * npm ```sh npm install solid-devtools ``` * pnpm ```sh pnpm add solid-devtools ``` * Yarn ```sh yarn add solid-devtools ``` astro.config.mjs ```js import { defineConfig } from 'astro/config'; import solid from '@astrojs/solid-js'; export default defineConfig({ // ... integrations: [solid({ devtools: true })], }); ``` ## Options [Section titled ‚ÄúOptions‚Äù](#options) ### Combining multiple JSX frameworks [Section titled ‚ÄúCombining multiple JSX frameworks‚Äù](#combining-multiple-jsx-frameworks) When you are using multiple JSX frameworks (React, Preact, Solid) in the same project, Astro needs to determine which JSX framework-specific transformations should be used for each of your components. If you have only added one JSX framework integration to your project, no extra configuration is needed. Use the `include` (required) and `exclude` (optional) configuration options to specify which files belong to which framework. Provide an array of files and/or folders to `include` for each framework you are using. Wildcards may be used to include multiple file paths. We recommend placing common framework components in the same folder (e.g. `/components/react/` and `/components/solid/`) to make specifying your includes easier, but this is not required: astro.config.mjs ```js import { defineConfig } from 'astro/config'; import preact from '@astrojs/preact'; import react from '@astrojs/react'; import svelte from '@astrojs/svelte'; import vue from '@astrojs/vue'; import solid from '@astrojs/solid-js'; export default defineConfig({ // Enable many frameworks to support all different kinds of components. // No `include` is needed if you are only using a single JSX framework! integrations: [ preact({ include: ['**/preact/*'], }), react({ include: ['**/react/*'], }), solid({ include: ['**/solid/*', '**/node_modules/@suid/material/**'], }), ], }); ``` ## Usage [Section titled ‚ÄúUsage‚Äù](#usage) Use a SolidJS component as you would any [UI framework component](/en/guides/framework-components/). ### Suspense Boundaries [Section titled ‚ÄúSuspense Boundaries‚Äù](#suspense-boundaries) In order to support Solid Resources and Lazy Components without excessive configuration, server-only and hydrating components are automatically wrapped in top-level Suspense boundaries and rendered on the server using the [`renderToStringAsync`](https://www.solidjs.com/docs/latest/api#rendertostringasync) function. Therefore, you do not need to add a top-level Suspense boundary around async components. For example, you can use Solid‚Äôs [`createResource`](https://www.solidjs.com/docs/latest/api#createresource) to fetch async remote data on the server. The remote data will be included in the initial server-rendered HTML from Astro: CharacterName.tsx ```tsx function CharacterName() { const [name] = createResource(() => fetch('https://swapi.dev/api/people/1') .then((result) => result.json()) .then((data) => data.name) ); return ( <> <h2>Name:</h2> {/* Luke Skywalker */} <div>{name()}</div> </> ); } ``` Similarly, Solid‚Äôs [Lazy Components](https://www.solidjs.com/docs/latest/api#lazy) will also be resolved and their HTML will be included in the initial server-rendered page. Non-hydrating [`client:only` components](/en/reference/directives-reference/#clientonly) are not automatically wrapped in Suspense boundaries. Feel free to add additional Suspense boundaries according to your preference.

# @astrojs/svelte

> Learn how to use the @astrojs/svelte framework integration to extend component support in your Astro project.

This **[Astro integration](/en/guides/integrations-guide/)** enables rendering and client-side hydration for your [Svelte](https://svelte.dev/) 5 components. For Svelte 3 and 4 support, install `@astrojs/svelte@5` instead. ## Installation [Section titled ‚ÄúInstallation‚Äù](#installation) Astro includes an `astro add` command to automate the setup of official integrations. If you prefer, you can [install integrations manually](#manual-install) instead. To install `@astrojs/svelte`, run the following from your project directory and follow the prompts: * npm ```sh npx astro add svelte ``` * pnpm ```sh pnpm astro add svelte ``` * Yarn ```sh yarn astro add svelte ``` If you run into any issues, [feel free to report them to us on GitHub](https://github.com/withastro/astro/issues) and try the manual installation steps below. ### Manual Install [Section titled ‚ÄúManual Install‚Äù](#manual-install) First, install the `@astrojs/svelte` package: * npm ```sh npm install @astrojs/svelte ``` * pnpm ```sh pnpm add @astrojs/svelte ``` * Yarn ```sh yarn add @astrojs/svelte ``` Most package managers will install associated peer dependencies as well. If you see a `Cannot find package 'svelte'` (or similar) warning when you start up Astro, you‚Äôll need to install Svelte and TypeScript: * npm ```sh npm install svelte typescript ``` * pnpm ```sh pnpm add svelte typescript ``` * Yarn ```sh yarn add svelte typescript ``` Then, apply the integration to your `astro.config.*` file using the `integrations` property: astro.config.mjs ```diff import { defineConfig } from 'astro/config'; +import svelte from '@astrojs/svelte'; export default defineConfig({ // ... integrations: [svelte()], }); ``` And create a new file called `svelte.config.js` in your project root directory and add the following code: svelte.config.js ```js import { vitePreprocess } from '@astrojs/svelte'; export default { preprocess: vitePreprocess(), } ``` ## Getting started [Section titled ‚ÄúGetting started‚Äù](#getting-started) To use your first Svelte component in Astro, head to our [UI framework documentation](/en/guides/framework-components/#using-framework-components). You‚Äôll explore: * üì¶ how framework components are loaded, * üíß client-side hydration options, and * ü§ù opportunities to mix and nest frameworks together ## Options [Section titled ‚ÄúOptions‚Äù](#options) This integration is powered by `@sveltejs/vite-plugin-svelte`. To customize the Svelte compiler, options can be provided to the integration. See the [`@sveltejs/vite-plugin-svelte` docs](https://github.com/sveltejs/vite-plugin-svelte/blob/HEAD/docs/config.md) for more details. You can set options either by passing them to the `svelte` integration in `astro.config.mjs` or in `svelte.config.js`. The options in `astro.config.mjs` will take precedence over the options in `svelte.config.js` if both are present: astro.config.mjs ```js import { defineConfig } from 'astro/config'; import svelte from '@astrojs/svelte'; export default defineConfig({ integrations: [svelte({ extensions: ['.svelte'] })], }); ``` svelte.config.js ```js export default { extensions: ['.svelte'], }; ``` ## Preprocessors [Section titled ‚ÄúPreprocessors‚Äù](#preprocessors) **Added in:** `@astrojs/svelte@2.0.0` If you‚Äôre using SCSS or Stylus in your Svelte files, you can create a `svelte.config.js` file so that they are preprocessed by Svelte, and the Svelte IDE extension can correctly parse the Svelte files. svelte.config.js ```js import { vitePreprocess } from '@astrojs/svelte'; export default { preprocess: vitePreprocess(), }; ``` This config file will be automatically added for you when you run `astro add svelte`. See the [`@sveltejs/vite-plugin-svelte` docs](https://github.com/sveltejs/vite-plugin-svelte/blob/HEAD/docs/preprocess.md) for more details about `vitePreprocess`.

# @astrojs/tailwind

> Learn how to use the @astrojs/tailwind integration in your Astro project.

Deprecated Tailwind CSS now offers a Vite plugin which is the preferred way to use Tailwind 4 in Astro. To use Tailwind in Astro, follow the [styling guide for Tailwind](/en/guides/styling/#tailwind).

# @astrojs/vercel

> Learn how to use the @astrojs/vercel adapter to deploy your Astro project.

This adapter allows Astro to deploy your [on-demand rendered routes and features](/en/guides/on-demand-rendering/) to [Vercel](https://www.vercel.com/), including [server islands](/en/guides/server-islands/), [actions](/en/guides/actions/), and [sessions](/en/guides/sessions/). If you‚Äôre using Astro as a static site builder, you only need this adapter if you are using additional Vercel services (e.g. [Vercel Web Analytics](https://vercel.com/docs/analytics), [Vercel Image Optimization](https://vercel.com/docs/image-optimization)). Otherwise, you do not need an adapter to deploy your static site. Learn how to deploy your Astro site in our [Vercel deployment guide](/en/guides/deploy/vercel/). ## Why Astro Vercel? [Section titled ‚ÄúWhy Astro Vercel?‚Äù](#why-astro-vercel) [Vercel](https://www.vercel.com/) is a deployment platform that allows you to host your site by connecting directly to your GitHub repository. This adapter enhances the Astro build process to prepare your project for deployment through Vercel. ## Installation [Section titled ‚ÄúInstallation‚Äù](#installation) Astro includes an `astro add` command to automate the setup of official integrations. If you prefer, you can [install integrations manually](#manual-install) instead. Add the Vercel adapter to enable on-demand rendering in your Astro project with the following `astro add` command. This will install `@astrojs/vercel` and make the appropriate changes to your `astro.config.mjs` file in one step. * npm ```sh npx astro add vercel ``` * pnpm ```sh pnpm astro add vercel ``` * Yarn ```sh yarn astro add vercel ``` Now, you can enable [on-demand rendering per page](/en/guides/on-demand-rendering/#enabling-on-demand-rendering), or set your build output configuration to `output: 'server'` to [server-render all your pages by default](/en/guides/on-demand-rendering/#server-mode). ### Manual Install [Section titled ‚ÄúManual Install‚Äù](#manual-install) First, add the `@astrojs/vercel` adapter to your project‚Äôs dependencies using your preferred package manager: * npm ```sh npm install @astrojs/vercel ``` * pnpm ```sh pnpm add @astrojs/vercel ``` * Yarn ```sh yarn add @astrojs/vercel ``` Then, add the adapter to your `astro.config.*` file: astro.config.mjs ```diff import { defineConfig } from 'astro/config'; +import vercel from '@astrojs/vercel'; export default defineConfig({ // ... + adapter: vercel(), }); ``` ## Usage [Section titled ‚ÄúUsage‚Äù](#usage) Find out more about [deploying your project to Vercel](/en/guides/deploy/vercel/). You can deploy by CLI (`vercel deploy`) or by connecting your new repo in the [Vercel Dashboard](https://vercel.com/). Alternatively, you can create a production build locally: ```sh astro build vercel deploy --prebuilt ``` ## Configuration [Section titled ‚ÄúConfiguration‚Äù](#configuration) To configure this adapter, pass an object to the `vercel()` function call in `astro.config.mjs`: ### `webAnalytics` [Section titled ‚ÄúwebAnalytics‚Äù](#webanalytics) **Type:** `VercelWebAnalyticsConfig`\ **Available for:** Serverless, Static **Added in:** `@astrojs/vercel@3.8.0` With `@vercel/analytics@1.3.x` or earlier, you can set `webAnalytics: { enabled: true }` in your Astro config to inject Vercel‚Äôs tracking scripts into all of your pages. For `@vercel/analytics@1.4.0` and later, use Vercel‚Äôs Analytics component to enable [Vercel Web Analytics](https://vercel.com/docs/concepts/analytics) instead. astro.config.mjs ```diff import { defineConfig } from 'astro/config'; import vercel from '@astrojs/vercel'; export default defineConfig({ // ... adapter: vercel({ + webAnalytics: { + enabled: true, + }, }), }); ``` ### `imagesConfig` [Section titled ‚ÄúimagesConfig‚Äù](#imagesconfig) **Type:** `VercelImageConfig`\ **Available for:** Serverless, Static **Added in:** `@astrojs/vercel@3.3.0` Configuration options for [Vercel‚Äôs Image Optimization API](https://vercel.com/docs/concepts/image-optimization). See [Vercel‚Äôs image configuration documentation](https://vercel.com/docs/build-output-api/v3/configuration#images) for a complete list of supported parameters. The `domains` and `remotePatterns` properties will automatically be filled using [the Astro corresponding `image` settings](/en/reference/configuration-reference/#image-options). astro.config.mjs ```diff import { defineConfig } from 'astro/config'; import vercel from '@astrojs/vercel'; export default defineConfig({ // ... output: 'static', adapter: vercel({ + imagesConfig: { + sizes: [320, 640, 1280], + }, }), }); ``` ### `imageService` [Section titled ‚ÄúimageService‚Äù](#imageservice) **Type:** `boolean`\ **Available for:** Serverless, Static **Added in:** `@astrojs/vercel@3.3.0` When enabled, an [Image Service](/en/reference/image-service-reference/) powered by the Vercel Image Optimization API will be automatically configured and used in production. In development, the image service specified by [`devImageService`](#devimageservice) will be used instead. astro.config.mjs ```diff import { defineConfig } from 'astro/config'; import vercel from '@astrojs/vercel'; export default defineConfig({ // ... output: 'static', adapter: vercel({ + imageService: true, }), }); ``` src/pages/index.astro ```astro --- import { Image } from 'astro:assets'; import astroLogo from '../assets/logo.png'; --- <!-- This component --> <Image src={astroLogo} alt="My super logo!" /> <!-- will become the following HTML --> <img src="/_vercel/image?url=_astro/logo.hash.png&w=...&q=..." alt="My super logo!" loading="lazy" decoding="async" width="..." height="..." /> ``` ### `devImageService` [Section titled ‚ÄúdevImageService‚Äù](#devimageservice) **Type:** `'sharp' | string`\ **Default:** `sharp`\ **Available for:** Serverless, Static **Added in:** `@astrojs/vercel@3.8.0` Allows you to configure which image service to use in development when [imageService](#imageservice) is enabled. This can be useful if you cannot install Sharp‚Äôs dependencies on your development machine, but using another image service like Squoosh would allow you to preview images in your dev environment. Build is unaffected and will always use Vercel‚Äôs Image Optimization. It can also be set to any arbitrary value in order to use a custom image service instead of Astro‚Äôs built-in ones. astro.config.mjs ```diff import { defineConfig } from 'astro/config'; import vercel from '@astrojs/vercel'; export default defineConfig({ // ... adapter: vercel({ + imageService: true, + devImageService: 'sharp', }), }); ``` ### `isr` [Section titled ‚Äúisr‚Äù](#isr) **Type:** `boolean | VercelISRConfig`\ **Default:** `false`\ **Available for:** Serverless **Added in:** `@astrojs/vercel@7.2.0` Allows your project to be deployed as an [ISR (Incremental Static Regeneration)](https://vercel.com/docs/incremental-static-regeneration) function, which caches your on-demand rendered pages in the same way as prerendered pages after first request. To enable this feature, set `isr` to true in your Vercel adapter configuration in `astro.config.mjs`: astro.config.mjs ```diff import { defineConfig } from 'astro/config'; import vercel from '@astrojs/vercel'; export default defineConfig({ // ... adapter: vercel({ + isr: true, }), }); ``` Note that ISR function requests do not include search params, similar to [requests](/en/reference/api-reference/#request) in static mode. #### ISR cache invalidation [Section titled ‚ÄúISR cache invalidation‚Äù](#isr-cache-invalidation) By default, an ISR function caches for the duration of your deployment. You can further control caching by setting an expiration time, or by excluding particular routes from caching entirely. ##### Time-based invalidation [Section titled ‚ÄúTime-based invalidation‚Äù](#time-based-invalidation) By default, when ISR is enabled, routes use [Vercel‚Äôs cache shielding](https://vercel.com/docs/incremental-static-regeneration#differences-between-isr-and-cache-control-headers) and any Cache-Control headers are ignored. Configuring an `expiration` value (in seconds) allows you to control how long routes are cached. This means Cache-Control directives set by your application are also respected. The following example defines `expiration` to cache all pages on first request and save them for 1 day: astro.config.mjs ```js import { defineConfig } from 'astro/config'; import vercel from '@astrojs/vercel'; export default defineConfig({ // ... adapter: vercel({ isr: { expiration: 60 * 60 * 24, }, }), }); ``` ##### On-demand invalidation [Section titled ‚ÄúOn-demand invalidation‚Äù](#on-demand-invalidation) To programmatically invalidate cached pages, create a bypass token and provide it to the `isr` config: astro.config.mjs ```js import { defineConfig } from 'astro/config'; import vercel from '@astrojs/vercel'; export default defineConfig({ adapter: vercel({ isr: { // A secret random string that you create. bypassToken: "005556d774a8", } }) }) ``` You can then invalidate a cached page by sending a HEAD or GET request to the page URL with the `x-prerender-revalidate` header set to your bypass token. See [Vercel‚Äôs on-demand ISR documentation](https://vercel.com/docs/build-output-api/v3/features#on-demand-incremental-static-regeneration-isr) for details. ##### Draft mode [Section titled ‚ÄúDraft mode‚Äù](#draft-mode) To bypass the ISR cache and render fresh content (e.g., for previewing unpublished CMS content), use [Vercel‚Äôs Draft mode](https://vercel.com/docs/build-output-api/v3/features#draft-mode). This requires [defining a `bypassToken`](#on-demand-invalidation) in your configuration and reusing its value in your pages to [set a cookie](/en/guides/on-demand-rendering/#cookies) named `__prerender_bypass`. ##### Excluding paths from caching [Section titled ‚ÄúExcluding paths from caching‚Äù](#excluding-paths-from-caching) Use the `exclude` option to prevent specific routes from being cached by ISR. These paths will always be rendered fresh on each request: astro.config.mjs ```js import { defineConfig } from 'astro/config'; import vercel from '@astrojs/vercel'; export default defineConfig({ adapter: vercel({ isr: { // Paths that will always be served fresh. exclude: [ '/preview', '/auth/[page]', /^\/api\/.+/ // Regular expressions supported since @astrojs/vercel@v8.1.0 ] } }) }) ``` ### `includeFiles` [Section titled ‚ÄúincludeFiles‚Äù](#includefiles) **Type:** `string[]`\ **Available for:** Serverless Use this property to force files to be bundled with your function. This is helpful when you notice missing files. astro.config.mjs ```diff import { defineConfig } from 'astro/config'; import vercel from '@astrojs/vercel'; export default defineConfig({ // ... adapter: vercel({ + includeFiles: ['./my-data.json'], }), }); ``` ### `excludeFiles` [Section titled ‚ÄúexcludeFiles‚Äù](#excludefiles) **Type:** `string[]`\ **Available for:** Serverless Use this property to exclude any files from the bundling process that would otherwise be included. astro.config.mjs ```diff import { defineConfig } from 'astro/config'; import vercel from '@astrojs/vercel'; export default defineConfig({ // ... adapter: vercel({ + excludeFiles: ['./src/some_big_file.jpg'], }), }); ``` ### `maxDuration` [Section titled ‚ÄúmaxDuration‚Äù](#maxduration) **Type:** `number`\ **Available for:** Serverless Use this property to extend or limit the maximum duration (in seconds) that Serverless Functions can run before timing out. See the [Vercel documentation](https://vercel.com/docs/functions/serverless-functions/runtimes#maxduration) for the default and maximum limit for your account plan. astro.config.mjs ```diff import { defineConfig } from 'astro/config'; import vercel from '@astrojs/vercel'; export default defineConfig({ // ... adapter: vercel({ + maxDuration: 60 }), }); ``` ### `skewProtection` [Section titled ‚ÄúskewProtection‚Äù](#skewprotection) **Type:** `boolean`\ **Available for:** Serverless **Added in:** `@astrojs/vercel@7.6.0` Use this property to enable [Vercel Skew protection](https://vercel.com/docs/deployments/skew-protection) (available with Vercel Pro and Enterprise accounts). astro.config.mjs ```diff import { defineConfig } from 'astro/config'; import vercel from '@astrojs/vercel'; export default defineConfig({ // ... adapter: vercel({ + skewProtection: true }), }); ``` ### Running Astro middleware on Vercel Edge Functions [Section titled ‚ÄúRunning Astro middleware on Vercel Edge Functions‚Äù](#running-astro-middleware-on-vercel-edge-functions) The `@astrojs/vercel` adapter can create an [edge function](https://vercel.com/docs/functions/edge-functions) from an Astro middleware in your code base. When `edgeMiddleware` is enabled, an edge function will execute your middleware code for all requests including static assets, prerendered pages, and on-demand rendered pages. For on-demand rendered pages, the `context.locals` object is serialized using JSON and sent in a header for the serverless function, which performs the rendering. As a security measure, the serverless function will refuse to serve requests with a `403 Forbidden` response unless they come from the generated edge function. This is an opt-in feature. To enable it, set `edgeMiddleware` to `true`: astro.config.mjs ```js import { defineConfig } from 'astro/config'; import vercel from '@astrojs/vercel'; export default defineConfig({ // ... adapter: vercel({ edgeMiddleware: true, }), }); ``` The edge middleware has access to Vercel‚Äôs [`RequestContext`](https://vercel.com/docs/functions/edge-middleware/middleware-api#requestcontext) as `ctx.locals.vercel.edge`. If you‚Äôre using TypeScript, you can [get proper typings](/en/guides/typescript/#extending-global-types) by updating `src/env.d.ts` to use `EdgeLocals`: ```ts type EdgeLocals = import('@astrojs/vercel').EdgeLocals declare namespace App { interface Locals extends EdgeLocals { // ... } } ``` ### Sessions [Section titled ‚ÄúSessions‚Äù](#sessions) The Astro [Sessions API](/en/guides/sessions/) allows you to easily store user data between requests. This can be used for things like user data and preferences, shopping carts, and authentication credentials. Unlike cookie storage, there are no size limits on the data, and it can be restored on different devices. When using sessions on Vercel, you need to [configure a driver](/en/reference/configuration-reference/#sessiondriver) for session storage. You can install a storage provider from [the Vercel marketplace](https://vercel.com/marketplace?category=storage). For example, if you have installed [a Redis integration](https://vercel.com/marketplace?category=storage\&search=redis) and linked a database to your site: 1. Install the `ioredis` package: * npm ```sh npm install ioredis ``` * pnpm ```sh pnpm install ioredis ``` * Yarn ```sh yarn add ioredis ``` 2. Use [the Vercel CLI](https://vercel.com/docs/cli) to load your environment variables: ```sh vercel env pull .env.local ``` This will create a `.env.local` file in your project root with the environment variables needed to connect to your Redis database when developing locally. 3. Configure the session driver: astro.config.mjs ```diff import { defineConfig } from 'astro/config'; import vercel from '@astrojs/vercel'; export default defineConfig({ adapter: vercel(), + session: { + driver: 'redis', + options: { + url: process.env.REDIS_URL, + }, + }, }); ``` ## Node.js Version Support [Section titled ‚ÄúNode.js Version Support‚Äù](#nodejs-version-support) The `@astrojs/vercel` adapter supports specific Node.js versions for deploying your Astro project on Vercel. To view the supported Node.js versions on Vercel, click on the settings tab for a project and scroll down to ‚ÄúNode.js Version‚Äù section. Check out the [Vercel documentation](https://vercel.com/docs/functions/serverless-functions/runtimes/node-js#default-and-available-versions) to learn more. ## Experimental features [Section titled ‚ÄúExperimental features‚Äù](#experimental-features) The following features are also available for use, but may be subject to breaking changes in future updates. Please follow the [`@astrojs/vercel` CHANGELOG](https://github.com/withastro/astro/tree/main/packages/integrations/vercel/CHANGELOG.md) carefully for updates if you are using these features in your project. ### `experimentalStaticHeaders` [Section titled ‚ÄúexperimentalStaticHeaders‚Äù](#experimentalstaticheaders) **Type:** `boolean`\ **Default:** `false`\ **Available for:** Serverless **Added in:** `@astrojs/vercel@8.2.0` Enables specifying custom headers for prerendered pages in Vercel‚Äôs configuration. If enabled, the adapter will save [static headers in the Vercel `vercel.json` file](https://vercel.com/docs/project-configuration#headers) when provided by Astro features, such as Content Security Policy. For example, when [experimental Content Security Policy](/en/reference/experimental-flags/csp/) is enabled, `experimentalStaticHeaders` can be used to add the CSP `headers` to your Vercel configuration, instead of creating a `<meta>` element: astro.config.mjs ```js import { defineConfig } from 'astro/config'; import vercel from '@astrojs/vercel'; export default defineConfig({ experimental: { csp: true }, adapter: vercel({ experimentalStaticHeaders: true }) }); ```

# @astrojs/vue

> Learn how to use the @astrojs/vue framework integration to extend component support in your Astro project.

This **[Astro integration](/en/guides/integrations-guide/)** enables rendering and client-side hydration for your [Vue 3](https://vuejs.org/) components. ## Installation [Section titled ‚ÄúInstallation‚Äù](#installation) Astro includes an `astro add` command to automate the setup of official integrations. If you prefer, you can [install integrations manually](#manual-install) instead. To install `@astrojs/vue`, run the following from your project directory and follow the prompts: * npm ```sh npx astro add vue ``` * pnpm ```sh pnpm astro add vue ``` * Yarn ```sh yarn astro add vue ``` If you run into any issues, [feel free to report them to us on GitHub](https://github.com/withastro/astro/issues) and try the manual installation steps below. ### Manual Install [Section titled ‚ÄúManual Install‚Äù](#manual-install) First, install the `@astrojs/vue` package: * npm ```sh npm install @astrojs/vue ``` * pnpm ```sh pnpm add @astrojs/vue ``` * Yarn ```sh yarn add @astrojs/vue ``` Most package managers will install associated peer dependencies as well. If you see a `Cannot find package 'vue'` (or similar) warning when you start up Astro, you‚Äôll need to install Vue: * npm ```sh npm install vue ``` * pnpm ```sh pnpm add vue ``` * Yarn ```sh yarn add vue ``` Then, apply the integration to your `astro.config.*` file using the `integrations` property: astro.config.mjs ```diff import { defineConfig } from 'astro/config'; +import vue from '@astrojs/vue'; export default defineConfig({ // ... integrations: [vue()], }); ``` ## Getting started [Section titled ‚ÄúGetting started‚Äù](#getting-started) To use your first Vue component in Astro, head to our [UI framework documentation](/en/guides/framework-components/#using-framework-components). You‚Äôll explore: * üì¶ how framework components are loaded, * üíß client-side hydration options, and * ü§ù opportunities to mix and nest frameworks together ## Troubleshooting [Section titled ‚ÄúTroubleshooting‚Äù](#troubleshooting) For help, check out the `#support` channel on [Discord](https://astro.build/chat). Our friendly Support Squad members are here to help! You can also check our [Astro Integration Documentation](/en/guides/integrations-guide/) for more on integrations. ## Contributing [Section titled ‚ÄúContributing‚Äù](#contributing) This package is maintained by Astro‚Äôs Core team. You‚Äôre welcome to submit an issue or PR! ## Options [Section titled ‚ÄúOptions‚Äù](#options) This integration is powered by `@vitejs/plugin-vue`. To customize the Vue compiler, options can be provided to the integration. See the `@vitejs/plugin-vue` [docs](https://www.npmjs.com/package/@vitejs/plugin-vue) for more details. astro.config.mjs ```js import { defineConfig } from 'astro/config'; import vue from '@astrojs/vue'; export default defineConfig({ // ... integrations: [ vue({ template: { compilerOptions: { // treat any tag that starts with ion- as custom elements isCustomElement: (tag) => tag.startsWith('ion-'), }, }, // ... }), ], }); ``` ### `appEntrypoint` [Section titled ‚ÄúappEntrypoint‚Äù](#appentrypoint) **Type:** `string` **Added in:** `@astrojs/vue@1.2.0` You can extend the Vue `app` instance setting the `appEntrypoint` option to a root-relative import specifier (for example, `appEntrypoint: "/src/pages/_app"`). The default export of this file should be a function that accepts a Vue `App` instance prior to rendering, allowing the use of [custom Vue plugins](https://vuejs.org/guide/reusability/plugins.html), `app.use`, and other customizations for advanced use cases. astro.config.mjs ```js import { defineConfig } from 'astro/config'; import vue from '@astrojs/vue'; export default defineConfig({ // ... integrations: [vue({ appEntrypoint: '/src/pages/_app' })], }); ``` src/pages/\_app.ts ```ts import type { App } from 'vue'; import i18nPlugin from 'my-vue-i18n-plugin'; export default (app: App) => { app.use(i18nPlugin); }; ``` ### `jsx` [Section titled ‚Äújsx‚Äù](#jsx) **Type:** `boolean | object` **Added in:** `@astrojs/vue@1.2.0` You can use Vue JSX by setting `jsx: true`. astro.config.mjs ```js import { defineConfig } from 'astro/config'; import vue from '@astrojs/vue'; export default defineConfig({ // ... integrations: [vue({ jsx: true })], }); ``` This will enable rendering for both Vue and Vue JSX components. To customize the Vue JSX compiler, pass an options object instead of a boolean. See the `@vitejs/plugin-vue-jsx` [docs](https://www.npmjs.com/package/@vitejs/plugin-vue-jsx) for more details. astro.config.mjs ```js import { defineConfig } from 'astro/config'; import vue from '@astrojs/vue'; export default defineConfig({ // ... integrations: [ vue({ jsx: { // treat any tag that starts with ion- as custom elements isCustomElement: (tag) => tag.startsWith('ion-'), }, }), ], }); ``` ### `devtools` [Section titled ‚Äúdevtools‚Äù](#devtools) **Type:** `boolean | object` **Added in:** `@astrojs/vue@4.2.0` You can enable [Vue DevTools](https://devtools-next.vuejs.org/) in development by passing an object with `devtools: true` to your `vue()` integration config: astro.config.mjs ```js import { defineConfig } from 'astro/config'; import vue from '@astrojs/vue'; export default defineConfig({ // ... integrations: [vue({ devtools: true })], }); ``` #### Customizing Vue DevTools [Section titled ‚ÄúCustomizing Vue DevTools‚Äù](#customizing-vue-devtools) **Added in:** `@astrojs/vue@4.3.0` For more customization, you can instead pass options that the [Vue DevTools Vite Plugin](https://devtools-next.vuejs.org/guide/vite-plugin#options) supports. (Note: `appendTo` is not supported.) For example, you can set `launchEditor` to your preferred editor if you are not using Visual Studio Code: astro.config.mjs ```js import { defineConfig } from "astro/config"; import vue from "@astrojs/vue"; export default defineConfig({ // ... integrations: [ vue({ devtools: { launchEditor: "webstorm" }, }), ], }); ```

# Internationalization (i18n) Routing

> Learn how to use Astro‚Äôs i18n routing features to localize your site‚Äôs pages.

Astro‚Äôs internationalization (i18n) features allow you to adapt your project for an international audience. This routing API helps you generate, use, and verify the URLs that your multi-language site produces. Astro‚Äôs i18n routing allows you to bring your multilingual content with support for configuring a default language, computing relative page URLs, and accepting preferred languages provided by your visitor‚Äôs browser. You can also specify fallback languages on a per-language basis so that your visitors can always be directed to existing content on your site. ## Routing Logic [Section titled ‚ÄúRouting Logic‚Äù](#routing-logic) Astro uses a [middleware](/en/guides/middleware/) to implement its routing logic. This middleware function is placed in the [first position](/en/guides/middleware/#chaining-middleware) where it awaits every `Response` coming from any additional middleware and each page route before finally executing its own logic. This means that operations (e.g. redirects) from your own middleware and your page logic are run first, your routes are rendered, and then the i18n middleware performs its own actions such as verifying that a localized URL corresponds to a valid route. You can also choose to [add your own i18n logic in addition to or instead of Astro‚Äôs i18n middleware](#manual), giving you even more control over your routes while still having access to the `astro:i18n` helper functions. ## Configure i18n routing [Section titled ‚ÄúConfigure i18n routing‚Äù](#configure-i18n-routing) Both a list of all supported languages ([`locales`](/en/reference/configuration-reference/#i18nlocales)) and a default language ([`defaultLocale`](/en/reference/configuration-reference/#i18ndefaultlocale)), which must be one of the languages listed in `locales`, need to be specified in an `i18n` configuration object. Additionally, you can configure more specific routing and fallback behavior to match your desired URLs. astro.config.mjs ```js import { defineConfig } from "astro/config" export default defineConfig({ i18n: { locales: ["es", "en", "pt-br"], defaultLocale: "en", } }) ``` ### Create localized folders [Section titled ‚ÄúCreate localized folders‚Äù](#create-localized-folders) Organize your content folders with localized content by language. Create individual `/[locale]/` folders anywhere within `src/pages/` and Astro‚Äôs [file-based routing](/en/guides/routing/) will create your pages at corresponding URL paths. Your folder names must match the items in `locales` exactly. Include a localized folder for your `defaultLocale` only if you configure `prefixDefaultLocale: true` to show a localized URL path for your default language (e.g. `/en/about/`). ### Create links [Section titled ‚ÄúCreate links‚Äù](#create-links) With i18n routing configured, you can now compute links to pages within your site using the helper functions such as [`getRelativeLocaleUrl()`](/en/reference/modules/astro-i18n/#getrelativelocaleurl) available from the [`astro:i18n` module](/en/reference/modules/astro-i18n/). These generated links will always provide the correct, localized route and can help you correctly use, or check, URLs on your site. You can also still write the links manually. src/pages/es/index.astro ```astro --- import { getRelativeLocaleUrl } from 'astro:i18n'; // defaultLocale is "es" const aboutURL = getRelativeLocaleUrl("es", "about"); --- <a href="/get-started/">¬°Vamos!</a> <a href={getRelativeLocaleUrl('es', 'blog')}>Blog</a> <a href={aboutURL}>Acerca</a> ``` ## `routing` [Section titled ‚Äúrouting‚Äù](#routing) Astro‚Äôs built-in file-based routing automatically creates URL routes for you based on your file structure within `src/pages/`. When you configure i18n routing, information about this file structure (and the corresponding URL paths generated) is available to the i18n helper functions so they can generate, use, and verify the routes in your project. Many of these options can be used together for even more customization and per-language flexibility. You can even choose to [implement your own routing logic manually](#manual) for even greater control. ### `prefixDefaultLocale` [Section titled ‚ÄúprefixDefaultLocale‚Äù](#prefixdefaultlocale) **Added in:** `astro@3.5.0` This routing option defines whether or not your default language‚Äôs URLs should use a language prefix (e.g. `/en/about/`). All non-default supported languages **will** use a localized prefix (e.g. `/fr/` or `/french/`) and content files must be located in appropriate folders. This configuration option allows you to specify whether your default language should also follow a localized URL structure. This setting also determines where the page files for your default language must exist (e.g. `src/pages/about/` or `src/pages/en/about`) as the file structure and URL structure must match for all languages. * `"prefixDefaultLocale: false"` (default): URLs in your default language will **not** have a `/[locale]/` prefix. All other locales will. * `"prefixDefaultLocale: true"`: All URLs, including your default language, will have a `/[locale]/` prefix. #### `prefixDefaultLocale: false` [Section titled ‚ÄúprefixDefaultLocale: false‚Äù](#prefixdefaultlocale-false) astro.config.mjs ```diff import { defineConfig } from "astro/config" export default defineConfig({ i18n: { locales: ["es", "en", "fr"], defaultLocale: "en", routing: { + prefixDefaultLocale: false } } }) ``` This is the **default** value. Set this option when URLs in your default language will **not** have a `/[locale]/` prefix and files in your default language exist at the root of `src/pages/`: * `src/pages/about.astro` will produce the route `example.com/about/` * `src/pages/fr/about.astro` will produce the route `example.com/fr/about/` #### `prefixDefaultLocale: true` [Section titled ‚ÄúprefixDefaultLocale: true‚Äù](#prefixdefaultlocale-true) astro.config.mjs ```diff import { defineConfig } from "astro/config" export default defineConfig({ i18n: { locales: ["es", "en", "fr"], defaultLocale: "en", routing: { + prefixDefaultLocale: true } } }) ``` Set this option when all routes will have their `/locale/` prefix in their URL and when all page content files, including those for your `defaultLocale`, exist in a localized folder: * URLs without a locale prefix, (e.g. `example.com/about/`) will return a 404 (not found) status code unless you specify a [fallback strategy](#fallback). ### `redirectToDefaultLocale` [Section titled ‚ÄúredirectToDefaultLocale‚Äù](#redirecttodefaultlocale) **Added in:** `astro@4.2.0` Configures whether or not the home URL (`/`) generated by `src/pages/index.astro` will redirect to `/<defaultLocale>`. Setting `prefixDefaultLocale: true` will also automatically set `redirectToDefaultLocale: true` in your `routing` config object. By default, the required `src/pages/index.astro` file will automatically redirect to the index page of your default locale. You can opt out of this behavior by [setting `redirectToDefaultLocale: false`](/en/reference/configuration-reference/#i18nroutingredirecttodefaultlocale). This allows you to have a site home page that exists outside of your configured locale folder structure. ### `manual` [Section titled ‚Äúmanual‚Äù](#manual) **Added in:** `astro@4.6.0` When this option is enabled, Astro will **disable** its i18n middleware so that you can implement your own custom logic. No other `routing` options (e.g. `prefixDefaultLocale`) may be configured with `routing: "manual"`. You will be responsible for writing your own routing logic, or [executing Astro‚Äôs i18n middleware manually](#middleware-function) alongside your own. astro.config.mjs ```js import { defineConfig } from "astro/config" export default defineConfig({ i18n: { locales: ["es", "en", "fr"], defaultLocale: "en", routing: "manual" } }) ``` Astro provides helper functions for your middleware so you can control your own default routing, exceptions, fallback behavior, error catching, etc: [`redirectToDefaultLocale()`](/en/reference/modules/astro-i18n/#redirecttodefaultlocale), [`notFound()`](/en/reference/modules/astro-i18n/#notfound), and [`redirectToFallback()`](/en/reference/modules/astro-i18n/#redirecttofallback): src/middleware.js ```js import { defineMiddleware } from "astro:middleware"; import { redirectToDefaultLocale } from "astro:i18n"; // function available with `manual` routing export const onRequest = defineMiddleware(async (ctx, next) => { if (ctx.url.startsWith("/about")) { return next(); } else { return redirectToDefaultLocale(302); } }) ``` #### middleware function [Section titled ‚Äúmiddleware function‚Äù](#middleware-function) The [`middleware`](#middleware-function) function manually creates Astro‚Äôs i18n middleware. This allows you to extend Astro‚Äôs i18n routing instead of completely replacing it. You can run `middleware` with [routing options](#routing) in combination with your own middleware, using the [`sequence`](/en/reference/modules/astro-middleware/#sequence) utility to determine the order: src/middleware.js ```js import {defineMiddleware, sequence} from "astro:middleware"; import { middleware } from "astro:i18n"; // Astro's own i18n routing config export const userMiddleware = defineMiddleware(async (ctx, next) => { // this response might come from Astro's i18n middleware, and it might return a 404 const response = await next(); // the /about page is an exception and we want to render it if (ctx.url.startsWith("/about")) { return new Response("About page", { status: 200 }); } else { return response; } }); export const onRequest = sequence( userMiddleware, middleware({ redirectToDefaultLocale: false, prefixDefaultLocale: true }) ) ``` ## `domains` [Section titled ‚Äúdomains‚Äù](#domains) **Added in:** `astro@4.9.0` This routing option allows you to customize your domains on a per-language basis for `server` rendered projects using the [`@astrojs/node`](/en/guides/integrations-guide/node/) or [`@astrojs/vercel`](/en/guides/integrations-guide/vercel/) adapter with a `site` configured. Add `i18n.domains` to map any of your supported `locales` to custom URLs: astro.config.mjs ```diff import { defineConfig } from "astro/config" export default defineConfig({ site: "https://example.com", output: "server", // required, with no prerendered pages adapter: node({ mode: 'standalone', }), i18n: { locales: ["es", "en", "fr", "ja"], defaultLocale: "en", routing: { prefixDefaultLocale: false }, + domains: { + fr: "https://fr.example.com", + es: "https://example.es" + } } }) ``` All non-mapped `locales` will follow your `prefixDefaultLocales` configuration. With the above configuration: * The file `/fr/about.astro` will create the URL `https://fr.example.com/about`. * The file `/es/about.astro` will create the URL `https://example.es/about`. * The file `/ja/about.astro` will create the URL `https://example.com/ja/about`. * The file `/about.astro` will create the URL `https://example.com/about`. The above URLs will also be returned by the `getAbsoluteLocaleUrl()` and `getAbsoluteLocaleUrlList()` functions. ## Fallback [Section titled ‚ÄúFallback‚Äù](#fallback) When a page in one language doesn‚Äôt exist (e.g. a page that is not yet translated), instead of displaying a 404 page, you can choose to display fallback content from another `locale` on a per-language basis. This is useful when you do not yet have a page for every route, but you want to still provide some content to your visitors. Your fallback strategy consists of two parts: choosing which languages should fallback to which other languages ([`i18n.fallback`](/en/reference/configuration-reference/#i18nfallback)) and choosing whether to perform a [redirect](/en/guides/routing/#redirects) or a [rewrite](/en/guides/routing/#rewrites) to show the fallback content ([`i18n.routing.fallbackType`](/en/reference/configuration-reference/#i18nroutingfallbacktype) added in Astro v4.15.0). For example, when you configure `i18n.fallback: { fr: "es" }`, Astro will ensure that a page is built in `src/pages/fr/` for every page that exists in `src/pages/es/`. If any page does not already exist, then a page will be created depending on your `fallbackType`: * With a redirect to the corresponding `es` route (default behavior). * With the content of the `/es/` page (`i18n.routing.fallbackType: "rewrite"`). For example, the configuration below sets `es` as the fallback locale for any missing `fr` routes. This means that a user visiting `example.com/fr/my-page/` will be shown the content for `example.com/es/my-page/` (without being redirected) instead of being taken to a 404 page when `src/pages/fr/my-page.astro` does not exist. astro.config.mjs ```diff import { defineConfig } from "astro/config" export default defineConfig({ i18n: { locales: ["es", "en", "fr"], defaultLocale: "en", + fallback: { + fr: "es" + }, routing: { + fallbackType: "rewrite" } } }) ``` ## Custom locale paths [Section titled ‚ÄúCustom locale paths‚Äù](#custom-locale-paths) In addition to defining your site‚Äôs supported `locales` as strings (e.g. ‚Äúen‚Äù, ‚Äúpt-br‚Äù), Astro also allows you to map an arbitrary number of [browser-recognized language `codes`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language#syntax) to a custom URL `path`. While locales can be strings of any format as long as they correspond to your project folder structure, `codes` must follow the browser‚Äôs accepted syntax. Pass an object to the `locales` array with a `path` key to define a custom URL prefix, and `codes` to indicate the languages mapped to this URL. In this case, your `/[locale]/` folder name must match exactly the value of the `path` and your URLs will be generated using the `path` value. This is useful if you support multiple variations of a language (e.g. `"fr"`, `"fr-BR"`, and `"fr-CA"`) and you want to have all these variations mapped under the same URL `/fr/`, or even customize it entirely (e.g. `/french/`): astro.config.mjs ```diff import { defineConfig } from "astro/config" export default defineConfig({ i18n: { - locales: ["es", "en", "fr"], + locales: ["es", "en", { + path: "french", // no slashes included + codes: ["fr", "fr-BR", "fr-CA"] + }], defaultLocale: "en", routing: { prefixDefaultLocale: true } } }) ``` When using functions from the [`astro:i18n` virtual module](/en/reference/modules/astro-i18n/) to compute valid URL paths based on your configuration (e.g. `getRelativeLocaleUrl()`), [use the `path` as the value for `locale`](/en/reference/modules/astro-i18n/#getlocalebypath). #### Limitations [Section titled ‚ÄúLimitations‚Äù](#limitations) This feature has some restrictions: * The `site` option is mandatory. * The `output` option must be set to `"server"`. * There cannot be any individual prerendered pages. Astro relies on the following headers in order to support the feature: * [`X-Forwarded-Host`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-Host) and [`Host`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Host). Astro will use the former, and if not present, will try the latter. * [`X-Forwarded-Proto`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-Proto) and [`URL#protocol`](https://developer.mozilla.org/en-US/docs/Web/API/URL/protocol) of the server request. Make sure that your server proxy/hosting platform is able to provide this information. Failing to retrieve these headers will result in a 404 (status code) page. ## Browser language detection [Section titled ‚ÄúBrowser language detection‚Äù](#browser-language-detection) Astro‚Äôs i18n routing allows you to access two properties for browser language detection in pages rendered on demand: `Astro.preferredLocale` and `Astro.preferredLocaleList`. All pages, including static prerendered pages, have access to `Astro.currentLocale`. These combine the browser‚Äôs `Accept-Language` header, and your `locales` (strings or `codes`) to automatically respect your visitor‚Äôs preferred languages. * [`Astro.preferredLocale`](/en/reference/api-reference/#preferredlocale): Astro can compute a **preferred locale** for your visitor if their browser‚Äôs preferred locale is included in your `locales` array. This value is undefined if no such match exists. * [`Astro.preferredLocaleList`](/en/reference/api-reference/#preferredlocalelist): An array of all locales that are both requested by the browser and supported by your website. This produces a list of all compatible languages between your site and your visitor. The value is `[]` if none of the browser‚Äôs requested languages are found in your `locales` array. If the browser does not specify any preferred languages, then this value will be [`i18n.locales`](/en/reference/configuration-reference/#i18nlocales). * [`Astro.currentLocale`](/en/reference/api-reference/#currentlocale): The locale computed from the current URL, using the syntax specified in your `locales` configuration. If the URL does not contain a `/[locale]/` prefix, then the value will default to [`i18n.defaultLocale`](/en/reference/configuration-reference/#i18ndefaultlocale). In order to successfully match your visitors‚Äô preferences, provide your `codes` using the same pattern [used by the browser](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language#syntax).

# Markdown in Astro

> Learn about Astro's built-in support for Markdown.

[Markdown](https://daringfireball.net/projects/markdown/) is commonly used to author text-heavy content like blog posts and documentation. Astro includes built-in support for Markdown files that can also include [frontmatter YAML](https://dev.to/paulasantamaria/introduction-to-yaml-125f) (or [TOML](https://toml.io)) to define custom properties such as a title, description, and tags. In Astro, you can author content in [GitHub Flavored Markdown](https://github.github.com/gfm/), then render it in `.astro` components. This combines a familiar writing format designed for content with the flexibility of Astro‚Äôs component syntax and architecture. ## Organizing Markdown files [Section titled ‚ÄúOrganizing Markdown files‚Äù](#organizing-markdown-files) Your local Markdown files can be kept anywhere within your `src/` directory. Markdown files located within `src/pages/` will automatically generate [Markdown pages on your site](#individual-markdown-pages). Your Markdown content and frontmatter properties are available to use in components through [local file imports](#importing-markdown) or when [queried and rendered from data fetched by a content collections helper function](#markdown-from-content-collections-queries). ### File imports vs content collections queries [Section titled ‚ÄúFile imports vs content collections queries‚Äù](#file-imports-vs-content-collections-queries) Local Markdown can be imported into `.astro` components using an `import` statement for a single file and [Vite‚Äôs `import.meta.glob()`](/en/guides/imports/#importmetaglob) to query multiple files at once. The [exported data from these Markdown files](#importing-markdown) can then be used in the `.astro` component. If you have groups of related Markdown files, consider [defining them as collections](/en/guides/content-collections/). This gives you several advantages, including the ability to store Markdown files anywhere on your filesystem or remotely. Collections use content-specific, optimized APIs for [querying and rendering your Markdown content](#markdown-from-content-collections-queries) instead of file imports. Collections are intended for sets of data that share the same structure, such as blog posts or product items. When you define that shape in a schema, you additionally get validation, type safety, and Intellisense in your editor. See more about [when to use content collections](/en/guides/content-collections/#when-to-create-a-collection) instead of file imports. ## Dynamic JSX-like expressions [Section titled ‚ÄúDynamic JSX-like expressions‚Äù](#dynamic-jsx-like-expressions) After importing or querying Markdown files, you can write dynamic HTML templates in your `.astro` components that include frontmatter data and body content. src/pages/posts/great-post.md ```md --- title: 'The greatest post of all time' author: 'Ben' --- Here is my _great_ post! ``` src/pages/my-posts.astro ```astro --- import * as greatPost from './posts/great-post.md'; const posts = Object.values(import.meta.glob('./posts/*.md', { eager: true })); --- <p>{greatPost.frontmatter.title}</p> <p>Written by: {greatPost.frontmatter.author}</p> {greatPost.compiledContent()} <p>Post Archive:</p> <ul> {posts.map(post => <li><a href={post.url}>{post.frontmatter.title}</a></li>)} </ul> ``` ### Available Properties [Section titled ‚ÄúAvailable Properties‚Äù](#available-properties) #### Markdown from content collections queries [Section titled ‚ÄúMarkdown from content collections queries‚Äù](#markdown-from-content-collections-queries) When fetching data from your collections with the helper functions `getCollection()` or `getEntry()`, your Markdown‚Äôs frontmatter properties are available on a `data` object (e.g. `post.data.title`). Additionally, `body` contains the raw, uncompiled body content as a string. The [`render()`](/en/reference/modules/astro-content/#render) function returns your Markdown body content, a generated list of headings, as well as a modified frontmatter object after any remark or rehype plugins have been applied. Read more about [using content returned by a collections query](/en/guides/content-collections/#using-content-in-astro-templates). #### Importing Markdown [Section titled ‚ÄúImporting Markdown‚Äù](#importing-markdown) The following exported properties are available in your `.astro` component when importing Markdown using `import` or `import.meta.glob()`: * **`file`** - The absolute file path (e.g. `/home/user/projects/.../file.md`). * **`url`** - The URL of the page (e.g. `/en/guides/markdown-content`). * **`frontmatter`** - Contains any data specified in the file‚Äôs YAML (or TOML) frontmatter. * **`<Content />`** - A component that returns the full, rendered contents of the file. * **`rawContent()`** - A function that returns the raw Markdown document as a string. * **`compiledContent()`** - An async function that returns the Markdown document compiled to an HTML string. * **`getHeadings()`** - An async function that returns an array of all headings (`<h1>` to `<h6>`) in the file with the type: `{ depth: number; slug: string; text: string }[]`. Each heading‚Äôs `slug` corresponds to the generated ID for a given heading and can be used for anchor links. An example Markdown blog post may pass the following `Astro.props` object: ```js Astro.props = { file: "/home/user/projects/.../file.md", url: "/en/guides/markdown-content/", frontmatter: { /** Frontmatter from a blog post */ title: "Astro 0.18 Release", date: "Tuesday, July 27 2021", author: "Matthew Phillips", description: "Astro 0.18 is our biggest release since Astro launch.", }, getHeadings: () => [ {"depth": 1, "text": "Astro 0.18 Release", "slug": "astro-018-release"}, {"depth": 2, "text": "Responsive partial hydration", "slug": "responsive-partial-hydration"} /* ... */ ], rawContent: () => "# Astro 0.18 Release\nA little over a month ago, the first public beta [...]", compiledContent: () => "<h1>Astro 0.18 Release</h1>\n<p>A little over a month ago, the first public beta [...]</p>", } ``` ## The `<Content />` Component [Section titled ‚ÄúThe \<Content /> Component‚Äù](#the-content--component) The `<Content />` component is available by importing `Content` from a Markdown file. This component returns the file‚Äôs full body content, rendered to HTML. You can optionally rename `Content` to any component name you prefer. You can similarly [render the HTML content of a Markdown collection entry](/en/guides/content-collections/#rendering-body-content) by rendering a `<Content />` component. src/pages/content.astro ```astro --- // Import statement import {Content as PromoBanner} from '../components/promoBanner.md'; // Collections query import { getEntry, render } from 'astro:content'; const product = await getEntry('products', 'shirt'); const { Content } = await render(product); --- <h2>Today's promo</h2> <PromoBanner /> <p>Sale Ends: {product.data.saleEndDate.toDateString()}</p> <Content /> ``` ## Heading IDs [Section titled ‚ÄúHeading IDs‚Äù](#heading-ids) Writing headings in Markdown will automatically give you anchor links so you can link directly to certain sections of your page. src/pages/page-1.md ```markdown --- title: My page of content --- ## Introduction I can link internally to [my conclusion](#conclusion) on the same page when writing Markdown. ## Conclusion I can visit `https://example.com/page-1/#introduction` in a browser to navigate directly to my Introduction. ``` Astro generates heading `id`s based on `github-slugger`. You can find more examples in [the github-slugger documentation](https://github.com/Flet/github-slugger#usage). ### Heading IDs and plugins [Section titled ‚ÄúHeading IDs and plugins‚Äù](#heading-ids-and-plugins) Astro injects an `id` attribute into all heading elements (`<h1>` to `<h6>`) in Markdown and MDX files. You can retrieve this data from the `getHeadings()` utility available as a [Markdown exported property](#available-properties) from an imported file, or from the `render()` function when [using Markdown returned from a content collections query](#markdown-from-content-collections-queries). You can customize these heading IDs by adding a rehype plugin that injects `id` attributes (e.g. `rehype-slug`). Your custom IDs, instead of Astro‚Äôs defaults, will be reflected in the HTML output and the items returned by `getHeadings()`. By default, Astro injects `id` attributes after your rehype plugins have run. If one of your custom rehype plugins needs to access the IDs injected by Astro, you can import and use Astro‚Äôs `rehypeHeadingIds` plugin directly. Be sure to add `rehypeHeadingIds` before any plugins that rely on it: astro.config.mjs ```diff import { defineConfig } from 'astro/config'; +import { rehypeHeadingIds } from '@astrojs/markdown-remark'; import { otherPluginThatReliesOnHeadingIDs } from 'some/plugin/source'; export default defineConfig({ markdown: { rehypePlugins: [ + rehypeHeadingIds, otherPluginThatReliesOnHeadingIDs, ], }, }); ``` ## Markdown Plugins [Section titled ‚ÄúMarkdown Plugins‚Äù](#markdown-plugins) Markdown support in Astro is powered by [remark](https://remark.js.org/), a powerful parsing and processing tool with an active ecosystem. Other Markdown parsers like Pandoc and markdown-it are not currently supported. Astro applies the [GitHub-flavored Markdown](https://github.com/remarkjs/remark-gfm) and [SmartyPants](https://github.com/silvenon/remark-smartypants) plugins by default. This brings some niceties like generating clickable links from text, and formatting for [quotations and em-dashes](https://daringfireball.net/projects/smartypants/). You can customize how remark parses your Markdown in `astro.config.mjs`. See the full list of [Markdown configuration options](/en/reference/configuration-reference/#markdown-options). ### Adding remark and rehype plugins [Section titled ‚ÄúAdding remark and rehype plugins‚Äù](#adding-remark-and-rehype-plugins) Astro supports adding third-party [remark](https://github.com/remarkjs/remark) and [rehype](https://github.com/rehypejs/rehype) plugins for Markdown. These plugins allow you to extend your Markdown with new capabilities, like [auto-generating a table of contents](https://github.com/remarkjs/remark-toc), [applying accessible emoji labels](https://github.com/florianeckerstorfer/remark-a11y-emoji), and [styling your Markdown](/en/guides/styling/#markdown-styling). We encourage you to browse [awesome-remark](https://github.com/remarkjs/awesome-remark) and [awesome-rehype](https://github.com/rehypejs/awesome-rehype) for popular plugins! See each plugin‚Äôs own README for specific installation instructions. This example applies [`remark-toc`](https://github.com/remarkjs/remark-toc) and [`rehype-accessible-emojis`](https://www.npmjs.com/package/rehype-accessible-emojis) to Markdown files: astro.config.mjs ```js import { defineConfig } from 'astro/config'; import remarkToc from 'remark-toc'; import { rehypeAccessibleEmojis } from 'rehype-accessible-emojis'; export default defineConfig({ markdown: { remarkPlugins: [ [remarkToc, { heading: 'toc', maxDepth: 3 } ] ], rehypePlugins: [rehypeAccessibleEmojis], }, }); ``` ### Customizing a plugin [Section titled ‚ÄúCustomizing a plugin‚Äù](#customizing-a-plugin) In order to customize a plugin, provide an options object after it in a nested array. The example below adds the [heading option to the `remarkToc` plugin](https://github.com/remarkjs/remark-toc#options) to change where the table of contents is placed, and the [`behavior` option to the `rehype-autolink-headings` plugin](https://github.com/rehypejs/rehype-autolink-headings#options) in order to add the anchor tag after the headline text. astro.config.mjs ```js import remarkToc from 'remark-toc'; import rehypeSlug from 'rehype-slug'; import rehypeAutolinkHeadings from 'rehype-autolink-headings'; export default { markdown: { remarkPlugins: [ [remarkToc, { heading: "contents"} ] ], rehypePlugins: [rehypeSlug, [rehypeAutolinkHeadings, { behavior: 'append' }]], }, } ``` ### Modifying frontmatter programmatically [Section titled ‚ÄúModifying frontmatter programmatically‚Äù](#modifying-frontmatter-programmatically) You can add frontmatter properties to all of your Markdown and MDX files by using a [remark or rehype plugin](#markdown-plugins). 1. Append a `customProperty` to the `data.astro.frontmatter` property from your plugin‚Äôs `file` argument: example-remark-plugin.mjs ```js export function exampleRemarkPlugin() { // All remark and rehype plugins return a separate function return function (tree, file) { file.data.astro.frontmatter.customProperty = 'Generated property'; } } ``` 2. Apply this plugin to your `markdown` or `mdx` integration config: astro.config.mjs ```js import { defineConfig } from 'astro/config'; import { exampleRemarkPlugin } from './example-remark-plugin.mjs'; export default defineConfig({ markdown: { remarkPlugins: [exampleRemarkPlugin] }, }); ``` or astro.config.mjs ```js import { defineConfig } from 'astro/config'; import { exampleRemarkPlugin } from './example-remark-plugin.mjs'; export default defineConfig({ integrations: [ mdx({ remarkPlugins: [exampleRemarkPlugin], }), ], }); ``` Now, every Markdown or MDX file will have `customProperty` in its frontmatter, making it available when [importing your markdown](#importing-markdown) and from [the `Astro.props.frontmatter` property in your layouts](#frontmatter-layout-property). ![](/houston_chef.webp) **Related recipe:** [Add reading time](/en/recipes/reading-time/) ### Extending Markdown config from MDX [Section titled ‚ÄúExtending Markdown config from MDX‚Äù](#extending-markdown-config-from-mdx) Astro‚Äôs MDX integration will extend [your project‚Äôs existing Markdown configuration](/en/reference/configuration-reference/#markdown-options) by default. To override individual options, you can specify their equivalent in your MDX configuration. The following example disables GitHub-Flavored Markdown and applies a different set of remark plugins for MDX files: astro.config.mjs ```ts import { defineConfig } from 'astro/config'; import mdx from '@astrojs/mdx'; export default defineConfig({ markdown: { syntaxHighlight: 'prism', remarkPlugins: [remarkPlugin1], gfm: true, }, integrations: [ mdx({ // `syntaxHighlight` inherited from Markdown // Markdown `remarkPlugins` ignored, // only `remarkPlugin2` applied. remarkPlugins: [remarkPlugin2], // `gfm` overridden to `false` gfm: false, }) ] }); ``` To avoid extending your Markdown config from MDX, set [the `extendMarkdownConfig` option](/en/guides/integrations-guide/mdx/#extendmarkdownconfig) (enabled by default) to `false`: astro.config.mjs ```ts import { defineConfig } from 'astro/config'; import mdx from '@astrojs/mdx'; export default defineConfig({ markdown: { remarkPlugins: [remarkPlugin], }, integrations: [ mdx({ // Markdown config now ignored extendMarkdownConfig: false, // No `remarkPlugins` applied }) ] }); ``` ## Individual Markdown pages [Section titled ‚ÄúIndividual Markdown pages‚Äù](#individual-markdown-pages) Astro treats [any supported file inside of the `/src/pages/` directory](/en/basics/astro-pages/#supported-page-files) as a page, including `.md` and other Markdown file types. Placing a file in this directory, or any sub-directory, will automatically build a page route using the pathname of the file and display the Markdown content rendered to HTML. Astro will automatically add a `<meta charset="utf-8">` tag to your page to allow easier authoring of non-ASCII content. src/pages/page-1.md ```markdown --- title: Hello, World --- # Hi there! This Markdown file creates a page at `your-domain.com/page-1/` It probably isn't styled much, but Markdown does support: - **bold** and _italics._ - lists - [links](https://astro.build) - <p>HTML elements</p> - and more! ``` ### Frontmatter `layout` property [Section titled ‚ÄúFrontmatter layout property‚Äù](#frontmatter-layout-property) To help with the limited functionality of individual Markdown pages, Astro provides a special frontmatter `layout` property which is a relative path to an Astro [Markdown layout component](/en/basics/layouts/#markdown-layouts). `layout` is not a special property when using [content collections](/en/guides/content-collections/) to query and render your Markdown content, and is not guaranteed to be supported outside of its intended use case. If your Markdown file is located within `src/pages/`, create a layout component and add it in this layout property to provide a page shell around your Markdown content. src/pages/posts/post-1.md ```markdown --- layout: ../../layouts/BlogPostLayout.astro title: Astro in brief author: Himanshu description: Find out what makes Astro awesome! --- This is a post written in Markdown. ``` This layout component is a regular Astro component with [specific properties automatically available](/en/basics/layouts/#markdown-layout-props) through `Astro.props` for your Astro template. For example, you can access your Markdown file‚Äôs frontmatter properties through `Astro.props.frontmatter`: src/layouts/BlogPostLayout.astro ```astro --- const {frontmatter} = Astro.props; --- <html> <head> <!-- ... --> <meta charset="utf-8"> // no longer added by default </head> <!-- ... --> <h1>{frontmatter.title}</h1> <h2>Post author: {frontmatter.author}</h2> <p>{frontmatter.description}</p> <slot /> <!-- Markdown content is injected here --> <!-- ... --> </html> ``` When using the frontmatter `layout` property, you must include the `<meta charset="utf-8">` tag in your layout as Astro will no longer add it automatically. You can now also [style your Markdown](/en/guides/styling/#markdown-styling) in your layout component. Learn more about [Markdown Layouts](/en/basics/layouts/#markdown-layouts). ## Fetching Remote Markdown [Section titled ‚ÄúFetching Remote Markdown‚Äù](#fetching-remote-markdown) Astro‚Äôs internal Markdown processor is not available for processing remote Markdown. To fetch remote Markdown for use in [content collections](/en/guides/content-collections/), you can [build a custom loader](/en/guides/content-collections/#building-a-custom-loader) with access to a [`renderMarkdown()` function](/en/reference/content-loader-reference/#rendermarkdown). To fetch remote Markdown directly and render it to HTML, you will need to install and configure your own Markdown parser from NPM. This will not inherit from any of Astro‚Äôs built-in Markdown settings that you have configured. Be sure that you understand these limitations before implementing this in your project, and consider fetching your remote Markdown using a content collections loader instead. src/pages/remote-example.astro ```astro --- // Example: Fetch Markdown from a remote API // and render it to HTML, at runtime. // Using "marked" (https://github.com/markedjs/marked) import { marked } from 'marked'; const response = await fetch('https://raw.githubusercontent.com/wiki/adam-p/markdown-here/Markdown-Cheatsheet.md'); const markdown = await response.text(); const content = marked.parse(markdown); --- <article set:html={content} /> ```

# Middleware

> Learn how to use middleware in Astro.

**Middleware** allows you to intercept requests and responses and inject behaviors dynamically every time a page or endpoint is about to be rendered. This rendering occurs at build time for all prerendered pages, but occurs when the route is requested for pages rendered on demand, making [additional SSR features like cookies and headers](/en/guides/on-demand-rendering/#on-demand-rendering-features) available. Middleware also allows you to set and share request-specific information across endpoints and pages by mutating a `locals` object that is available in all Astro components and API endpoints. This object is available even when this middleware runs at build time. ## Basic Usage [Section titled ‚ÄúBasic Usage‚Äù](#basic-usage) 1. Create `src/middleware.js|ts` (Alternatively, you can create `src/middleware/index.js|ts`.) 2. Inside this file, export an [`onRequest()`](/en/reference/modules/astro-middleware/#onrequest) function that can be passed a [`context` object](#the-context-object) and `next()` function. This must not be a default export. src/middleware.js ```js export function onRequest (context, next) { // intercept data from a request // optionally, modify the properties in `locals` context.locals.title = "New title"; // return a Response or the result of calling `next()` return next(); }; ``` 3. Inside any `.astro` file, access response data using `Astro.locals`. src/components/Component.astro ```astro --- const data = Astro.locals; --- <h1>{data.title}</h1> <p>This {data.property} is from middleware.</p> ``` ### The `context` object [Section titled ‚ÄúThe context object‚Äù](#the-context-object) The [`context`](/en/reference/api-reference/) object includes information to be made available to other middleware, API routes and `.astro` routes during the rendering process. This is an optional argument passed to `onRequest()` that may contain the `locals` object as well as any additional properties to be shared during rendering. For example, the `context` object may include cookies used in authentication. ### Storing data in `context.locals` [Section titled ‚ÄúStoring data in context.locals‚Äù](#storing-data-in-contextlocals) `context.locals` is an object that can be manipulated inside the middleware. This `locals` object is forwarded across the request handling process and is available as a property to [`APIContext`](/en/reference/api-reference/#locals) and [`AstroGlobal`](/en/reference/api-reference/#locals). This allows data to be shared between middlewares, API routes, and `.astro` pages. This is useful for storing request-specific data, such as user data, across the rendering step. You can store any type of data inside `locals`: strings, numbers, and even complex data types such as functions and maps. src/middleware.js ```js export function onRequest (context, next) { // intercept data from a request // optionally, modify the properties in `locals` context.locals.user.name = "John Wick"; context.locals.welcomeTitle = () => { return "Welcome back " + locals.user.name; }; // return a Response or the result of calling `next()` return next(); }; ``` Then you can use this information inside any `.astro` file with `Astro.locals`. src/pages/orders.astro ```astro --- const title = Astro.locals.welcomeTitle(); const orders = Array.from(Astro.locals.orders.entries()); const data = Astro.locals; --- <h1>{title}</h1> <p>This {data.property} is from middleware.</p> <ul> {orders.map(order => { return <li>{/* do something with each order */}</li>; })} </ul> ``` `locals` is an object that lives and dies within a single Astro route; when your route page is rendered, `locals` won‚Äôt exist anymore and a new one will be created. Information that needs to persist across multiple page requests must be stored elsewhere. ## Example: redacting sensitive information [Section titled ‚ÄúExample: redacting sensitive information‚Äù](#example-redacting-sensitive-information) The example below uses middleware to replace ‚ÄúPRIVATE INFO‚Äù with the word ‚ÄúREDACTED‚Äù to allow you to render modified HTML on your page: src/middleware.js ```js export const onRequest = async (context, next) => { const response = await next(); const html = await response.text(); const redactedHtml = html.replaceAll("PRIVATE INFO", "REDACTED"); return new Response(redactedHtml, { status: 200, headers: response.headers }); }; ``` ## Middleware types [Section titled ‚ÄúMiddleware types‚Äù](#middleware-types) You can import and use the utility function [`defineMiddleware()`](/en/reference/modules/astro-middleware/#definemiddleware) to take advantage of type safety: src/middleware.ts ```ts import { defineMiddleware } from "astro:middleware"; // `context` and `next` are automatically typed export const onRequest = defineMiddleware((context, next) => { }); ``` Instead, if you‚Äôre using JsDoc to take advantage of type safety, you can use `MiddlewareHandler`: src/middleware.js ```js /** * @type {import("astro").MiddlewareHandler} */ // `context` and `next` are automatically typed export const onRequest = (context, next) => { }; ``` To type the information inside `Astro.locals`, which gives you autocompletion inside `.astro` files and middleware code, [extend the global types](/en/guides/typescript/#extending-global-types) by declaring a global namespace in the `env.d.ts` file: src/env.d.ts ```ts type User = { id: number; name: string; }; declare namespace App { interface Locals { user: User; welcomeTitle: () => string; orders: Map<string, object>; session: import("./lib/server/session").Session | null; } } ``` Then, inside the middleware file, you can take advantage of autocompletion and type safety. ## Chaining middleware [Section titled ‚ÄúChaining middleware‚Äù](#chaining-middleware) Multiple middlewares can be joined in a specified order using [`sequence()`](/en/reference/modules/astro-middleware/#sequence): src/middleware.js ```js import { sequence } from "astro:middleware"; async function validation(_, next) { console.log("validation request"); const response = await next(); console.log("validation response"); return response; } async function auth(_, next) { console.log("auth request"); const response = await next(); console.log("auth response"); return response; } async function greeting(_, next) { console.log("greeting request"); const response = await next(); console.log("greeting response"); return response; } export const onRequest = sequence(validation, auth, greeting); ``` This will result in the following console order: ```sh validation request auth request greeting request greeting response auth response validation response ``` ## Rewriting [Section titled ‚ÄúRewriting‚Äù](#rewriting) **Added in:** `astro@4.13.0` The `APIContext` exposes a method called [`rewrite()`](/en/reference/api-reference/#rewrite) which works the same way as [Astro.rewrite](/en/guides/routing/#rewrites). Use `context.rewrite()` inside middleware to display a different page‚Äôs content without [redirecting](/en/guides/routing/#dynamic-redirects) your visitor to a new page. This will trigger a new rendering phase, causing any middleware to be re-executed. src/middleware.js ```js import { isLoggedIn } from "~/auth.js" export function onRequest (context, next) { if (!isLoggedIn(context)) { // If the user is not logged in, update the Request to render the `/login` route and // add header to indicate where the user should be sent after a successful login. // Re-execute middleware. return context.rewrite(new Request("/login", { headers: { "x-redirect-to": context.url.pathname } })); } return next(); }; ``` You can also pass the `next()` function an optional URL path parameter to rewrite the current `Request` without retriggering a new rendering phase. The location of the rewrite path can be provided as a string, URL, or `Request`: src/middleware.js ```js import { isLoggedIn } from "~/auth.js" export function onRequest (context, next) { if (!isLoggedIn(context)) { // If the user is not logged in, update the Request to render the `/login` route and // add header to indicate where the user should be sent after a successful login. // Return a new `context` to any following middlewares. return next(new Request("/login", { headers: { "x-redirect-to": context.url.pathname } })); } return next(); }; ``` The `next()` function accepts the same payload of [the `Astro.rewrite()` function](/en/reference/api-reference/#rewrite). The location of the rewrite path can be provided as a string, URL, or `Request`. When you have multiple middleware functions chained via [sequence()](#chaining-middleware), submitting a path to `next()` will rewrite the `Request` in place and the middleware will not execute again. The next middleware function in the chain will receive the new `Request` with its updated `context`. Calling `next()` with this signature will create a new `Request` object using the old `ctx.request`. This means that trying to consume `Request.body`, either before or after this rewrite, will throw a runtime error. This error is often raised with [Astro Actions that use HTML forms](/en/guides/actions/#call-actions-from-an-html-form-action). In these cases, we recommend handling rewrites from your Astro templates using `Astro.rewrite()` instead of using middleware. src/middleware.js ```js // Current URL is https://example.com/blog // First middleware function async function first(context, next) { console.log(context.url.pathname) // this will log "/blog" // Rewrite to a new route, the homepage // Return updated `context` which is passed to next function return next("/") } // Current URL is still https://example.com/blog // Second middleware function async function second(context, next) { // Receives updated `context` console.log(context.url.pathname) // this will log "/" return next() } export const onRequest = sequence(first, second); ``` ## Error pages [Section titled ‚ÄúError pages‚Äù](#error-pages) Middleware will attempt to run for all on-demand rendered pages, even when a matching route cannot be found. This includes Astro‚Äôs default (blank) 404 page and any custom 404 pages. However, it is up to the [adapter](/en/guides/on-demand-rendering/) to decide whether that code runs. Some adapters may serve a platform-specific error page instead. Middleware will also attempt to run before serving a 500 error page, including a custom 500 page, unless the server error occurred in the execution of the middleware itself. If your middleware does not run successfully, then you will not have access to `Astro.locals` to render your 500 page.

# On-demand rendering

> Generate server-rendered pages and routes on demand with an adapter.

Your Astro project code must be **rendered** to HTML in order to be displayed on the web. By default, Astro pages, routes, and API endpoints will be pre-rendered at build time as static pages. However, you can choose to render some or all of your routes on demand by a server when a route is requested. On-demand rendered pages and routes are generated per visit, and can be customized for each viewer. For example, a page rendered on demand can show a logged-in user their account information or display freshly updated data without requiring a full-site rebuild. On-demand rendering on the server at request time is also known as **server-side rendering (SSR)**. ## Server adapters [Section titled ‚ÄúServer adapters‚Äù](#server-adapters) To render any page on demand, you need to add an **adapter**. Each adapter allows Astro to output a script that runs your project on a specific **runtime**: the environment that runs code on the server to generate pages when they are requested (e.g. Netlify, Cloudflare). You may also wish to add an adapter even if your site is entirely static and you are not rendering any pages on demand. For example, the [Netlify adapter](/en/guides/integrations-guide/netlify/) enables Netlify‚Äôs Image CDN, and [server islands](/en/guides/server-islands/) require an adapter installed to use `server:defer` on a component. ### Adapters * ![](/logos/cloudflare-pages.svg) ### [@astrojs/‚Äãcloudflare](/en/guides/integrations-guide/cloudflare/) * ![](/logos/netlify.svg) ### [@astrojs/‚Äãnetlify](/en/guides/integrations-guide/netlify/) * ![](/logos/node.svg) ### [@astrojs/‚Äãnode](/en/guides/integrations-guide/node/) * ![](/logos/vercel.svg) ### [@astrojs/‚Äãvercel](/en/guides/integrations-guide/vercel/) Astro maintains official adapters for [Node.js](https://nodejs.org/), [Netlify](https://www.netlify.com/), [Vercel](https://vercel.com/), and [Cloudflare](https://www.cloudflare.com/). You can find both [official and community adapters in our integrations directory](https://astro.build/integrations/?search=\&categories%5B%5D=adapters). Choose the one that corresponds to your [deployment environment](/en/guides/deploy/). ### Add an Adapter [Section titled ‚ÄúAdd an Adapter‚Äù](#add-an-adapter) You can add any of the [official adapter integrations maintained by Astro](/en/guides/integrations-guide/#official-integrations) with the following `astro add` command. This will install the adapter and make the appropriate changes to your `astro.config.mjs` file in one step. For example, to install the Netlify adapter, run: * npm ```shell npx astro add netlify ``` * pnpm ```shell pnpm astro add netlify ``` * Yarn ```shell yarn astro add netlify ``` You can also [add an adapter manually by installing the NPM package](/en/guides/integrations-guide/#installing-an-npm-package) (e.g. `@astrojs/netlify`) and updating `astro.config.mjs` yourself. Note that different adapters may have different configuration settings. Read each adapter‚Äôs documentation, and apply any necessary config options to your chosen adapter in `astro.config.mjs` ## Enabling on-demand rendering [Section titled ‚ÄúEnabling on-demand rendering‚Äù](#enabling-on-demand-rendering) **By default, your entire Astro site will be prerendered**, and static HTML pages will be sent to the browser. However, you may opt out of prerendering on any routes that require server rendering, for example, a page that checks for cookies and displays personalized content. First, [add an adapter integration](#add-an-adapter) for your server runtime to enable on-demand server rendering in your Astro project. Then, add `export const prerender = false` at the top of the individual page or endpoint you want to render on demand. The rest of your site will remain a static site: src/pages/page-rendered-on-demand.astro ```diff --- +export const prerender = false --- <html> <!-- This content will be server-rendered on demand! Just add an adapter integration for a server runtime! All other pages are statically-generated at build time! --> <html> ``` The following example shows opting out of prerendering in order to display a random number each time the endpoint is hit: src/pages/randomnumber.js ```diff +export const prerender = false; export async function GET() { let number = Math.random(); return new Response( JSON.stringify({ number, message: `Here's a random number: ${number}`, }), ); } ``` ### `'server'` mode [Section titled ‚Äú'server' mode‚Äù](#server-mode) For a **highly dynamic app**, after adding an adapter, you can [set your build output configuration to `output: 'server'`](/en/reference/configuration-reference/#output) to **server-render all your pages by default**. This is the equivalent of opting out of prerendering on every page. Then, if needed, you can choose to prerender any individual pages that do not require a server to execute, such as a privacy policy or about page. src/pages/about-my-app.astro ```diff --- +export const prerender = true --- <html> <!-- `output: 'server'` is configured, but this page is static! The rest of my site is rendered on demand! --> <html> ``` Add `export const prerender = true` to any page or route to prerender a static page or endpoint: src/pages/myendpoint.js ```diff +export const prerender = true; export async function GET() { return new Response( JSON.stringify({ message: `This is my static endpoint`, }), ); } ``` See more about the [`output` setting](/en/reference/configuration-reference/#output) in the configuration reference. ## On-demand rendering features [Section titled ‚ÄúOn-demand rendering features‚Äù](#on-demand-rendering-features) ### HTML streaming [Section titled ‚ÄúHTML streaming‚Äù](#html-streaming) With HTML streaming, a document is broken up into chunks, sent over the network in order, and rendered on the page in that order. Astro uses HTML streaming in on-demand rendering to send each component to the browser as it renders them. This makes sure the user sees your HTML as fast as possible, although network conditions can cause large documents to be downloaded slowly, and waiting for data fetches can block page rendering. ![](/houston_chef.webp) **Related recipe:** [Using streaming to improve page performance](/en/recipes/streaming-improve-page-performance/) Caution Features that modify the [Response headers](https://developer.mozilla.org/en-US/docs/Glossary/Response_header) are only available at the **page level**. (You can‚Äôt use them inside of components, including layout components.) By the time Astro runs your component code, it has already sent the Response headers and they cannot be modified. ### Cookies [Section titled ‚ÄúCookies‚Äù](#cookies) A page or API endpoint rendered on demand can check, set, get, and delete cookies. The example below updates the value of a cookie for a page view counter: src/pages/index.astro ```astro --- export const prerender = false; // Not needed in 'server' mode let counter = 0 if (Astro.cookies.has('counter')) { const cookie = Astro.cookies.get('counter') const value = cookie?.number() if (value !== undefined && !isNaN(value)) counter = value + 1 } Astro.cookies.set('counter', String(counter)) --- <html> <h1>Counter = {counter}</h1> </html> ``` See more details about [`Astro.cookies` and the `AstroCookie` type](/en/reference/api-reference/#cookies) in the API reference. ### `Response` [Section titled ‚ÄúResponse‚Äù](#response) [`Astro.response`](/en/reference/api-reference/#response) is a standard [`ResponseInit`](https://developer.mozilla.org/en-US/docs/Web/API/Response/Response#options) object. It can be used to set the response status and headers. The example below sets a response status and status text for a product page when the product does not exist: src/pages/product/\[id].astro ```astro --- export const prerender = false; // Not needed in 'server' mode import { getProduct } from '../api'; const product = await getProduct(Astro.params.id); // No product found if (!product) { Astro.response.status = 404; Astro.response.statusText = 'Not found'; } --- <html> <!-- Page here... --> </html> ``` #### `Astro.response.headers` [Section titled ‚ÄúAstro.response.headers‚Äù](#astroresponseheaders) You can set headers using the `Astro.response.headers` object: src/pages/index.astro ```astro --- export const prerender = false; // Not needed in 'server' mode Astro.response.headers.set('Cache-Control', 'public, max-age=3600'); --- <html> <!-- Page here... --> </html> ``` #### Return a `Response` object [Section titled ‚ÄúReturn a Response object‚Äù](#return-a-response-object) You can also return a [Response](https://developer.mozilla.org/en-US/docs/Web/API/Response) object directly from any page using on-demand rendering either manually or with [`Astro.redirect`](/en/reference/api-reference/#redirect). The example below looks up an ID in the database on a dynamic page and either it returns a 404 if the product does not exist, or it redirects the user to another page if the product is no longer available, or it displays the product: src/pages/product/\[id].astro ```astro --- export const prerender = false; // Not needed in 'server' mode import { getProduct } from '../api'; const product = await getProduct(Astro.params.id); // No product found if (!product) { return new Response(null, { status: 404, statusText: 'Not found' }); } // The product is no longer available if (!product.isAvailable) { return Astro.redirect("/products", 301); } --- <html> <!-- Page here... --> </html> ``` ### `Request` [Section titled ‚ÄúRequest‚Äù](#request) `Astro.request` is a standard [Request](https://developer.mozilla.org/en-US/docs/Web/API/Request) object. It can be used to get the `url`, `headers`, `method`, and even the body of the request. You can access additional information from this object for pages that are not statically generated. #### `Astro.request.headers` [Section titled ‚ÄúAstro.request.headers‚Äù](#astrorequestheaders) The headers for the request are available on `Astro.request.headers`. This works like the browser‚Äôs [`Request.headers`](https://developer.mozilla.org/en-US/docs/Web/API/Request/headers). It is a [Headers](https://developer.mozilla.org/en-US/docs/Web/API/Headers) object where you can retrieve headers such as the cookie. src/pages/index.astro ```astro --- export const prerender = false; // Not needed in 'server' mode const cookie = Astro.request.headers.get('cookie'); // ... --- <html> <!-- Page here... --> </html> ``` #### `Astro.request.method` [Section titled ‚ÄúAstro.request.method‚Äù](#astrorequestmethod) The HTTP method used in the request is available as `Astro.request.method`. This works like the browser‚Äôs [`Request.method`](https://developer.mozilla.org/en-US/docs/Web/API/Request/method). It returns the string representation of the HTTP method used in the request. src/pages/index.astro ```astro --- export const prerender = false; // Not needed in 'server' mode console.log(Astro.request.method) // GET (when navigated to in the browser) --- ``` See more details about [`Astro.request`](/en/reference/api-reference/#request) in the API reference. ### Server Endpoints [Section titled ‚ÄúServer Endpoints‚Äù](#server-endpoints) A server endpoint, also known as an **API route**, is a special function exported from a `.js` or `.ts` file within the `src/pages/` folder. A powerful feature of server-side rendering on demand, API routes are able to securely execute code on the server. The function takes an [endpoint context](/en/reference/api-reference/) and returns a [Response](https://developer.mozilla.org/en-US/docs/Web/API/Response). To learn more, see our [Endpoints Guide](/en/guides/endpoints/#server-endpoints-api-routes).

# Prefetch

> Prefetch links for snappier navigation between pages.

Page load times play a big role in the usability and overall enjoyment of a site. Astro‚Äôs **opt-in prefetching** brings the benefits of near-instant page navigations to your multi-page application (MPA) as your visitors interact with the site. ## Enable prefetching [Section titled ‚ÄúEnable prefetching‚Äù](#enable-prefetching) You can enable prefetching with the `prefetch` config: astro.config.mjs ```diff import { defineConfig } from 'astro/config'; export default defineConfig({ + prefetch: true }); ``` A prefetch script will be added to all pages of your site. You can then add the `data-astro-prefetch` attribute to any `<a />` links on your site to opt-in to prefetching. When you hover over the link, the script will fetch the page in the background. ```html <a href="/about" data-astro-prefetch> ``` Note that prefetching only works for links within your site, and not external links. ## Prefetch configuration [Section titled ‚ÄúPrefetch configuration‚Äù](#prefetch-configuration) The `prefetch` config also accepts an option object to further customize prefetching. ### Prefetch strategies [Section titled ‚ÄúPrefetch strategies‚Äù](#prefetch-strategies) Astro supports 4 prefetch strategies for various use cases: * `hover` (default): Prefetch when you hover over or focus on the link. * `tap`: Prefetch just before you click on the link. * `viewport`: Prefetch as the links enter the viewport. * `load`: Prefetch all links on the page after the page is loaded. You can specify a strategy for an individual link by passing it to the `data-astro-prefetch` attribute: ```html <a href="/about" data-astro-prefetch="tap">About</a> ``` Each strategy is fine-tuned to only prefetch when needed and save your users‚Äô bandwidth. For example: * If a visitor is using [data saver mode](https://developer.mozilla.org/en-US/docs/Web/API/NetworkInformation/saveData) or has a [slow connection](https://developer.mozilla.org/en-US/docs/Web/API/NetworkInformation/effectiveType), prefetch will fallback to the `tap` strategy. * Quickly hovering or scrolling over links will not prefetch them. ### Default prefetch strategy [Section titled ‚ÄúDefault prefetch strategy‚Äù](#default-prefetch-strategy) The default prefetch strategy when adding the `data-astro-prefetch` attribute is `hover`. To change it, you can configure [`prefetch.defaultStrategy`](/en/reference/configuration-reference/#prefetchdefaultstrategy) in your `astro.config.mjs` file: astro.config.mjs ```diff import { defineConfig } from 'astro/config'; export default defineConfig({ + prefetch: { + defaultStrategy: 'viewport' + } }); ``` ### Prefetch all links by default [Section titled ‚ÄúPrefetch all links by default‚Äù](#prefetch-all-links-by-default) If you want to prefetch all links, including those without the `data-astro-prefetch` attribute, you can set [`prefetch.prefetchAll`](/en/reference/configuration-reference/#prefetchprefetchall) to `true`: astro.config.mjs ```diff import { defineConfig } from 'astro/config'; export default defineConfig({ + prefetch: { + prefetchAll: true + } }); ``` You can then opt-out of prefetching for individual links by setting `data-astro-prefetch="false"`: ```html <a href="/about" data-astro-prefetch="false">About</a> ``` The default prefetch strategy for all links can be changed with `prefetch.defaultStrategy` as shown in the [Default prefetch strategy section](#default-prefetch-strategy). ## Prefetch programmatically [Section titled ‚ÄúPrefetch programmatically‚Äù](#prefetch-programmatically) As some navigation might not always appear as `<a />` links, you can also prefetch programmatically with the `prefetch()` API from the `astro:prefetch` module: ```astro <button id="btn">Click me</button> <script> import { prefetch } from 'astro:prefetch'; const btn = document.getElementById('btn'); btn.addEventListener('click', () => { prefetch('/about'); }); </script> ``` The `prefetch()` API includes the same [data saver mode](https://developer.mozilla.org/en-US/docs/Web/API/NetworkInformation/saveData) and [slow connection](https://developer.mozilla.org/en-US/docs/Web/API/NetworkInformation/effectiveType) detection so that it only prefetches when needed. To ignore slow connection detection, you can use the `ignoreSlowConnection` option: ```js // Prefetch even on data saver mode or slow connection prefetch('/about', { ignoreSlowConnection: true }); ``` ### `eagerness` [Section titled ‚Äúeagerness‚Äù](#eagerness) **Type:** `'immediate' | 'eager' | 'moderate' | 'conservative'`\ **Default:** `'immediate'` **Added in:** `astro@5.6.0` With the experimental [`clientPrerender`](/en/reference/experimental-flags/client-prerender/) flag enabled, you can use the `eagerness` option on `prefetch()` to suggest to the browser how eagerly it should prefetch/prerender link targets. This follows the same API described in the [Speculation Rules API](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script/type/speculationrules#eagerness) and defaults to `immediate` (the most eager option). In decreasing order of eagerness, the other options are `eager`, `moderate`, and `conservative`. The `eagerness` option allows you to balance the benefit of reduced wait times against bandwidth, memory, and CPU costs for your site visitors. Some browsers, such as Chrome, have [limits in place to guard against over-speculating](https://developer.chrome.com/blog/speculation-rules-improvements#chrome-limits) (prerendering/prefetching too many links). ```astro --- --- <script> // Control prefetching eagerness with `experimental.clientPrerender` import { prefetch } from 'astro:prefetch'; // This page is resource-intensive prefetch('/data-heavy-dashboard', { eagerness: 'conservative' }); // This page is critical to the visitor's journey prefetch('/getting-started'); // defaults to `{ eagerness: 'immediate' }` // This page may not be visited prefetch('/terms-of-service', { eagerness: 'moderate' }); </script> ``` To use `prefetch()` programmatically with large sets of links, you can set `eagerness: 'moderate'` to take advantage of [First In, First Out (FIFO)](https://en.wikipedia.org/wiki/FIFO_\(computing_and_electronics\)) strategies and browser heuristics to let the browser decide when to prerender/prefetch them and in what order: ```astro <a class="link-moderate" href="/nice-link-1">A Nice Link 1</a> <a class="link-moderate" href="/nice-link-2">A Nice Link 2</a> <a class="link-moderate" href="/nice-link-3">A Nice Link 3</a> <a class="link-moderate" href="/nice-link-4">A Nice Link 4</a> ... <a class="link-moderate" href="/nice-link-20">A Nice Link 20</a> <script> import { prefetch } from 'astro:prefetch'; const linkModerate = document.getElementsByClassName('link-moderate'); linkModerate.forEach((link) => prefetch(link.getAttribute('href'), {eagerness: 'moderate'})); </script> ``` Make sure to only import `prefetch()` in client-side scripts as it relies on browser APIs. ## Using with View Transitions [Section titled ‚ÄúUsing with View Transitions‚Äù](#using-with-view-transitions) When you use [Astro‚Äôs `<ClientRouter />`](/en/guides/view-transitions/#enabling-view-transitions-spa-mode) on a page, prefetching will also be enabled by default. It sets a default configuration of `{ prefetchAll: true }` which enables [prefetching for all links](#prefetch-all-links-by-default) on the page. You can customize the prefetch configuration in `astro.config.mjs` to override the default. For example: astro.config.mjs ```js import { defineConfig } from 'astro/config'; export default defineConfig({ // Disable prefetch completely prefetch: false }); ``` astro.config.mjs ```js import { defineConfig } from 'astro/config'; export default defineConfig({ // Keep prefetch, but only prefetch for links with `data-astro-prefetch` prefetch: { prefetchAll: false } }); ``` ## Browser support [Section titled ‚ÄúBrowser support‚Äù](#browser-support) Astro‚Äôs prefetching uses [`<link rel="prefetch">`](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/rel/prefetch) if supported by the browser, and falls back to the [`fetch()` API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API) otherwise. The most common browsers support Astro‚Äôs prefetching with subtle differences: ### Chrome [Section titled ‚ÄúChrome‚Äù](#chrome) Chrome supports `<link rel="prefetch">`. Prefetching works as intended. It also fully supports `<script type="speculationrules">` from the [Speculation Rules API](https://developer.mozilla.org/en-US/docs/Web/API/Speculation_Rules_API), which can be used to further describe [prefetching strategies and rules](#eagerness), enhancing user experience for your Chrome users. You‚Äôll need to enable [`clientPrerender`](/en/reference/experimental-flags/client-prerender/) experiment to utilize this functionality with `prefetch()` ### Firefox [Section titled ‚ÄúFirefox‚Äù](#firefox) Firefox supports `<link rel="prefetch">` but may display errors or fail entirely: * Without an explicit cache header (e.g. [`Cache-Control`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control) or [`Expires`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Expires)), prefetching will error with `NS_BINDING_ABORTED`. * Even in the event of an error, if the response has a proper [`ETag`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag) header, it will be re-used on navigation. * Otherwise, if it errors with no other cache headers, the prefetch will not work. ### Safari [Section titled ‚ÄúSafari‚Äù](#safari) Safari does not support `<link rel="prefetch">` and will fall back to the `fetch()` API which requires cache headers (e.g. [`Cache-Control`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control), [`Expires`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Expires), and [`ETag`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag)) to be set. Otherwise, the prefetch will not work. **Edge case:** `ETag` headers do not work in private windows. ### Recommendations [Section titled ‚ÄúRecommendations‚Äù](#recommendations) To best support all browsers, make sure your pages have the proper cache headers. For static or prerendered pages, the `ETag` header is often automatically set by the deployment platform and is expected to work out of the box. For dynamic and server-side rendered pages, set the appropriate cache headers yourself based on the page content. Visit the [MDN documentation on HTTP caching](https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching) for more information. ## Migrating from `@astrojs/prefetch` [Section titled ‚ÄúMigrating from @astrojs/prefetch‚Äù](#migrating-from-astrojsprefetch) The `@astrojs/prefetch` integration was deprecated in v3.5.0 and will eventually be removed entirely. Use the following instructions to migrate to Astro‚Äôs built-in prefetching which replaces this integration. 1. Remove the `@astrojs/prefetch` integration and enable the `prefetch` config in `astro.config.mjs`: astro.config.mjs ```diff import { defineConfig } from 'astro/config'; -import prefetch from '@astrojs/prefetch'; export default defineConfig({ - integrations: [prefetch()], + prefetch: true }); ``` 2. Convert from `@astrojs/prefetch`‚Äôs configuration options: * The deprecated integration used the `selector` config option to specify which links should be prefetched upon entering the viewport. Add `data-astro-prefetch="viewport"` to these individual links instead. ```html <a href="/about" data-astro-prefetch="viewport"> ``` * The deprecated integration used the `intentSelector` config option to specify which links should be prefetched when they were hovered over or focused. Add `data-astro-prefetch` or `data-astro-prefetch="hover"` to these individual links instead: ```html <!-- You can omit the value if `defaultStrategy` is set to `hover` (default) --> <a href="/about" data-astro-prefetch> <!-- Otherwise, you can explicitly define the prefetch strategy --> <a href="/about" data-astro-prefetch="hover"> ``` * The `throttles` option from `@astrojs/prefetch` is no longer needed as the new prefetch feature will automatically schedule and prefetch optimally.

# Routing

> An intro to routing with Astro.

Astro uses **file-based routing** to generate your build URLs based on the file layout of your project `src/pages/` directory. ## Navigating between pages [Section titled ‚ÄúNavigating between pages‚Äù](#navigating-between-pages) Astro uses standard HTML [`<a>` elements](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a) to navigate between routes. There is no framework-specific `<Link>` component provided. src/pages/index.astro ```astro <p>Read more <a href="/about/">about</a> Astro!</p> <!-- With `base: "/docs"` configured --> <p>Learn more in our <a href="/docs/reference/">reference</a> section!</p> ``` ## Static routes [Section titled ‚ÄúStatic routes‚Äù](#static-routes) `.astro` [page components](/en/basics/astro-pages/) as well as Markdown and MDX Files (`.md`, `.mdx`) within the `src/pages/` directory **automatically become pages on your website**. Each page‚Äôs route corresponds to its path and filename within the `src/pages/` directory. ```diff # Example: Static routes src/pages/index.astro -> mysite.com/ src/pages/about.astro -> mysite.com/about src/pages/about/index.astro -> mysite.com/about src/pages/about/me.astro -> mysite.com/about/me src/pages/posts/1.md -> mysite.com/posts/1 ``` ## Dynamic routes [Section titled ‚ÄúDynamic routes‚Äù](#dynamic-routes) An Astro page file can specify dynamic route parameters in its filename to generate multiple, matching pages. For example, `src/pages/authors/[author].astro` generates a bio page for every author on your blog. `author` becomes a *parameter* that you can access from inside the page. In Astro‚Äôs default static output mode, these pages are generated at build time, and so you must predetermine the list of `author`s that get a corresponding file. In SSR mode, a page will be generated on request for any route that matches. ### Static (SSG) Mode [Section titled ‚ÄúStatic (SSG) Mode‚Äù](#static-ssg-mode) Because all routes must be determined at build time, a dynamic route must export a `getStaticPaths()` that returns an array of objects with a `params` property. Each of these objects will generate a corresponding route. `[dog].astro` defines the dynamic `dog` parameter in its filename, so the objects returned by `getStaticPaths()` must include `dog` in their `params`. The page can then access this parameter using `Astro.params`. src/pages/dogs/\[dog].astro ```astro --- export function getStaticPaths() { return [ { params: { dog: "clifford" }}, { params: { dog: "rover" }}, { params: { dog: "spot" }}, ]; } const { dog } = Astro.params; --- <div>Good dog, {dog}!</div> ``` This will generate three pages: `/dogs/clifford`, `/dogs/rover`, and `/dogs/spot`, each displaying the corresponding dog name. The filename can include multiple parameters, which must all be included in the `params` objects in `getStaticPaths()`: src/pages/\[lang]-\[version]/info.astro ```astro --- export function getStaticPaths() { return [ { params: { lang: "en", version: "v1" }}, { params: { lang: "fr", version: "v2" }}, ]; } const { lang, version } = Astro.params; --- ``` This will generate `/en-v1/info` and `/fr-v2/info`. Parameters can be included in separate parts of the path. For example, the file `src/pages/[lang]/[version]/info.astro` with the same `getStaticPaths()` above will generate the routes `/en/v1/info` and `/fr/v2/info`. #### Decoding `params` [Section titled ‚ÄúDecoding params‚Äù](#decoding-params) `params` returned by a `getStaticPaths()` function are not decoded. Use [`decodeURI()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/decodeURI) when you need to decode parameter values. src/pages/\[slug].astro ```astro --- export function getStaticPaths() { return [ { params: { slug: decodeURI("%5Bpage%5D") }}, // decodes to "[page]" ] } --- ``` Learn more about [`getStaticPaths()`](/en/reference/routing-reference/#getstaticpaths). ![](/houston_chef.webp) **Related recipe:** [Add i18n features](/en/recipes/i18n/) #### Rest parameters [Section titled ‚ÄúRest parameters‚Äù](#rest-parameters) If you need more flexibility in your URL routing, you can use a [rest parameter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters) (`[...path]`) in your `.astro` filename to match file paths of any depth: src/pages/sequences/\[...path].astro ```astro --- export function getStaticPaths() { return [ { params: { path: "one/two/three" }}, { params: { path: "four" }}, { params: { path: undefined }} ] } const { path } = Astro.params; --- ``` This will generate `/sequences/one/two/three`, `/sequences/four`, and `/sequences`. (Setting the rest parameter to `undefined` allows it to match the top level page.) Rest parameters can be used with **other named parameters**. For example, GitHub‚Äôs file viewer can be represented with the following dynamic route: ```plaintext /[org]/[repo]/tree/[branch]/[...file] ``` In this example, a request for `/withastro/astro/tree/main/docs/public/favicon.svg` would be split into the following named parameters: ```js { org: "withastro", repo: "astro", branch: "main", file: "docs/public/favicon.svg" } ``` #### Example: Dynamic pages at multiple levels [Section titled ‚ÄúExample: Dynamic pages at multiple levels‚Äù](#example-dynamic-pages-at-multiple-levels) In the following example, a rest parameter (`[...slug]`) and the [`props`](/en/reference/routing-reference/#data-passing-with-props) feature of `getStaticPaths()` generate pages for slugs of different depths. src/pages/\[...slug].astro ```astro --- export function getStaticPaths() { const pages = [ { slug: undefined, title: "Astro Store", text: "Welcome to the Astro store!", }, { slug: "products", title: "Astro products", text: "We have lots of products for you", }, { slug: "products/astro-handbook", title: "The ultimate Astro handbook", text: "If you want to learn Astro, you must read this book.", }, ]; return pages.map(({ slug, title, text }) => { return { params: { slug }, props: { title, text }, }; }); } const { title, text } = Astro.props; --- <html> <head> <title>{title}</title> </head> <body> <h1>{title}</h1> <p>{text}</p> </body> </html> ``` ### On-demand dynamic routes [Section titled ‚ÄúOn-demand dynamic routes‚Äù](#on-demand-dynamic-routes) For [on-demand rendering](/en/guides/on-demand-rendering/) with an adapter, dynamic routes are defined the same way: include `[param]` or `[...path]` brackets in your file names to match arbitrary strings or paths. But because the routes are no longer built ahead of time, the page will be served to any matching route. Since these are not ‚Äústatic‚Äù routes, `getStaticPaths` should not be used. For on-demand rendered routes, only one rest parameter using the spread notation may be used in the file name (e.g. `src/pages/[locale]/[...slug].astro` or `src/pages/[...locale]/[slug].astro`, but not `src/pages/[...locale]/[...slug].astro`). src/pages/resources/\[resource]/\[id].astro ```astro --- export const prerender = false; // Not needed in 'server' mode const { resource, id } = Astro.params; --- <h1>{resource}: {id}</h1> ``` This page will be served for any value of `resource` and `id`: `resources/users/1`, `resources/colors/blue`, etc. #### Modifying the `[...slug]` example for SSR [Section titled ‚ÄúModifying the \[...slug\] example for SSR‚Äù](#modifying-the-slug-example-for-ssr) Because SSR pages can‚Äôt use `getStaticPaths()`, they can‚Äôt receive props. The [previous example](#example-dynamic-pages-at-multiple-levels) can be adapted for SSR mode by looking up the value of the `slug` param in an object. If the route is at the root (‚Äù/‚Äù), the `slug` param will be `undefined`. If the value doesn‚Äôt exist in the object, we redirect to a 404 page. src/pages/\[...slug].astro ```astro --- const pages = [ { slug: undefined, title: 'Astro Store', text: 'Welcome to the Astro store!', }, { slug: 'products', title: 'Astro products', text: 'We have lots of products for you', }, { slug: 'products/astro-handbook', title: 'The ultimate Astro handbook', text: 'If you want to learn Astro, you must read this book.', } ]; const { slug } = Astro.params; const page = pages.find((page) => page.slug === slug); if (!page) return Astro.redirect("/404"); const { title, text } = page; --- <html> <head> <title>{title}</title> </head> <body> <h1>{title}</h1> <p>{text}</p> </body> </html> ``` ## Redirects [Section titled ‚ÄúRedirects‚Äù](#redirects) Sometimes you will need to redirect your readers to a new page, either permanently because your site structure has changed or in response to an action such as logging in to an authenticated route. You can define rules to [redirect users to permanently-moved pages](#configured-redirects) in your Astro config. Or, [redirect users dynamically](#dynamic-redirects) as they use your site. ### Configured Redirects [Section titled ‚ÄúConfigured Redirects‚Äù](#configured-redirects) **Added in:** `astro@2.9.0` You can specify a mapping of permanent redirects in your Astro config with the [`redirects`](/en/reference/configuration-reference/#redirects) value. For internal redirects, this is a mapping of an old route path to the new route. As of Astro v5.2.0, it is also possible to redirect to external URLs that start with `http` or `https` and [can be parsed](https://developer.mozilla.org/en-US/docs/Web/API/URL/canParse_static): astro.config.mjs ```js import { defineConfig } from "astro/config"; export default defineConfig({ redirects: { "/old-page": "/new-page", "/blog": "https://example.com/blog" } }); ``` These redirects follow [the same priority rules as file-based routes](#route-priority-order) and will always take lower precedence than an existing page file of the same name in your project. For example, `/old-page` will not redirect to `/new-page` if your project contains the file `src/pages/old-page.astro`. Dynamic routes are allowed as long as both the new and old routes contain the same parameters, for example: ```js { "/blog/[...slug]": "/articles/[...slug]" } ``` Using SSR or a static adapter, you can also provide an object as the value, allowing you to specify the `status` code in addition to the new `destination`: astro.config.mjs ```js import { defineConfig } from "astro/config"; export default defineConfig({ redirects: { "/old-page": { status: 302, destination: "/new-page" }, "/news": { status: 302, destination: "https://example.com/news" } } }); ``` When running `astro build`, Astro will output HTML files with the [meta refresh](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta#examples) tag by default. Supported adapters will instead write out the host‚Äôs configuration file with the redirects. The status code is `301` by default. If building to HTML files the status code is not used by the server. ### Dynamic redirects [Section titled ‚ÄúDynamic redirects‚Äù](#dynamic-redirects) On the `Astro` global, the `Astro.redirect` method allows you to redirect to another page dynamically. You might do this after checking if the user is logged in by getting their session from a cookie. src/pages/account.astro ```astro --- import { isLoggedIn } from "../utils"; const cookie = Astro.request.headers.get("cookie"); // If the user is not logged in, redirect them to the login page if (!isLoggedIn(cookie)) { return Astro.redirect("/login"); } --- ``` Because Astro uses [HTML streaming](/en/guides/on-demand-rendering/#html-streaming) in on-demand rendering, redirects must be done at the page level, not inside child components. ## Rewrites [Section titled ‚ÄúRewrites‚Äù](#rewrites) **Added in:** `astro@4.13.0` A rewrite allows you to serve a different route without redirecting the browser to a different page. The browser will show the original address in the URL bar, but will instead display the content of the URL provided to [`Astro.rewrite()`](/en/reference/api-reference/#rewrite). Rewrites can be useful for showing the same content at multiple paths (e.g. `/products/shoes/men/` and `/products/men/shoes/`) without needing to maintain two different source files. Rewrites are also useful for SEO purposes and user experience. They allow you to display content that otherwise would require redirecting your visitor to a different page or would return a 404 status. One common use of rewrites is to show the same localized content for different variants of a language. The following example uses a rewrite to render the `/es/` version of a page when the `/es-CU/` (Cuban Spanish) URL path is visited. When a visitor navigates to the URL `/es-cu/articles/introduction`, Astro will render the content generated by the file `src/pages/es/articles/introduction.astro`. src/pages/es-cu/articles/introduction.astro ```astro --- return Astro.rewrite("/es/articles/introduction"); --- ``` Use `context.rewrite()` in your endpoint files to reroute to a different page: src/pages/api.js ```js export function GET(context) { if (!context.locals.allowed) { return context.rewrite("/"); } } ``` If the URL passed to `Astro.rewrite()` emits a runtime error, Astro will show the overlay error in development and return a 500 status code in production. If the URL does not exist in your project, a 404 status code will be returned. You can intentionally create a rewrite to render your `/404` page, for example to indicate that a product in your e-commerce shop is no longer available: src/pages/\[item].astro ```astro --- const { item } = Astro.params; if (!itemExists(item)) { return Astro.rewrite("/404"); } --- ``` You can also conditionally rewrite based on an HTTP response status, for example to display a certain page on your site when visiting a URL that doesn‚Äôt exist: src/middleware.mjs ```js export const onRequest = async (context, next) => { const response = await next(); if (response.status === 404) { return context.rewrite("/"); } return response; } ``` Before displaying the content from the specified rewrite path, the function `Astro.rewrite()` will trigger a new, complete rendering phase. This re-executes any middleware for the new route/request. See the [`Astro.rewrite()` API reference](/en/reference/api-reference/#rewrite) for more information. ## Route Priority Order [Section titled ‚ÄúRoute Priority Order‚Äù](#route-priority-order) It‚Äôs possible for multiple defined routes to attempt to build the same URL path. For example, all of these routes could build `/posts/create`: Astro needs to know which route should be used to build the page. To do so, it sorts them according to the following rules in order: * Astro [reserved routes](#reserved-routes) * Routes with more path segments will take precedence over less specific routes. In the example above, all routes under `/posts/` take precedence over `/[...slug].astro` at the root. * Static routes without path parameters will take precedence over dynamic routes. E.g. `/posts/create.astro` takes precedence over all the other routes in the example. * Dynamic routes using named parameters take precedence over rest parameters. E.g. `/posts/[page].astro` takes precedence over `/posts/[...slug].astro`. * Pre-rendered dynamic routes take precedence over server dynamic routes. * Endpoints take precedence over pages. * File-based routes take precedence over redirects. * If none of the rules above decide the order, routes are sorted alphabetically based on the default locale of your Node installation. Given the example above, here are a few examples of how the rules will match a requested URL to the route used to build the HTML: * `pages/posts/create.astro` - Will build only `/posts/create` * `pages/posts/[pid].ts` - Will build `/posts/abc`, `/posts/xyz`, etc. But not `/posts/create` * `pages/posts/[page].astro` - Will build `/posts/1`, `/posts/2`, etc. But not `/posts/create`, `/posts/abc` nor `/posts/xyz` * `pages/posts/[...slug].astro` - Will build `/posts/1/2`, `/posts/a/b/c`, etc. But not `/posts/create`, `/posts/1`, `/posts/abc`, etc. * `pages/[...slug].astro` - Will build `/abc`, `/xyz`, `/abc/xyz`, etc. But not `/posts/create`, `/posts/1`, `/posts/abc`, etc. ### Reserved routes [Section titled ‚ÄúReserved routes‚Äù](#reserved-routes) Internal routes take priority over any user-defined or integration-defined routes as they are required for Astro features to work. The following are Astro‚Äôs reserved routes: * `_astro/`: Serves all of the static assets to the client, including CSS documents, bundled client scripts, optimized images, and any Vite assets. * `_server_islands/`: Serves the dynamic components deferred into a [server island](/en/guides/server-islands/). * `_actions/`: Serves any defined [actions](/en/guides/actions/). ## Pagination [Section titled ‚ÄúPagination‚Äù](#pagination) Astro supports built-in pagination for large collections of data that need to be split into multiple pages. Astro will generate common pagination properties, including previous/next page URLs, total number of pages, and more. Paginated route names should use the same `[bracket]` syntax as a standard dynamic route. For instance, the file name `/astronauts/[page].astro` will generate routes for `/astronauts/1`, `/astronauts/2`, etc, where `[page]` is the generated page number. You can use the `paginate()` function to generate these pages for an array of values like so: src/pages/astronauts/\[page].astro ```astro --- export function getStaticPaths({ paginate }) { const astronautPages = [ { astronaut: "Neil Armstrong" }, { astronaut: "Buzz Aldrin" }, { astronaut: "Sally Ride" }, { astronaut: "John Glenn" }, ]; // Generate pages from our array of astronauts, with 2 to a page return paginate(astronautPages, { pageSize: 2 }); } // All paginated data is passed on the "page" prop const { page } = Astro.props; --- <!-- Display the current page number. `Astro.params.page` can also be used! --> <h1>Page {page.currentPage}</h1> <ul> <!-- List the array of astronaut info --> {page.data.map(({ astronaut }) => <li>{astronaut}</li>)} </ul> ``` This generates the following pages, with 2 items to a page: * `/astronauts/1` - Page 1: Displays ‚ÄúNeil Armstrong‚Äù and ‚ÄúBuzz Aldrin‚Äù * `/astronauts/2` - Page 2: Displays ‚ÄúSally Ride‚Äù and ‚ÄúJohn Glenn‚Äù ### The `page` prop [Section titled ‚ÄúThe page prop‚Äù](#the-page-prop) When you use the `paginate()` function, each page will be passed its data via a `page` prop. The `page` prop has many useful properties that you can use to build pages and links between them: ```ts interface Page<T = any> { /** array containing the page‚Äôs slice of data that you passed to the paginate() function */ data: T[]; /** metadata */ /** the count of the first item on the page, starting from 0 */ start: number; /** the count of the last item on the page, starting from 0 */ end: number; /** total number of results */ total: number; /** the current page number, starting from 1 */ currentPage: number; /** number of items per page (default: 10) */ size: number; /** number of last page */ lastPage: number; url: { /** url of the current page */ current: string; /** url of the previous page (if there is one) */ prev: string | undefined; /** url of the next page (if there is one) */ next: string | undefined; /** url of the first page (if the current page is not the first page) */ first: string | undefined; /** url of the last page (if the current page in not the last page) */ last: string | undefined; }; } ``` The following example displays current information for the page along with links to navigate between pages: src/pages/astronauts/\[page].astro ```astro --- // Paginate same list of `{ astronaut }` objects as the previous example export function getStaticPaths({ paginate }) { /* ... */ } const { page } = Astro.props; --- <h1>Page {page.currentPage}</h1> <ul> {page.data.map(({ astronaut }) => <li>{astronaut}</li>)} </ul> {page.url.first ? <a href={page.url.first}>First</a> : null} {page.url.prev ? <a href={page.url.prev}>Previous</a> : null} {page.url.next ? <a href={page.url.next}>Next</a> : null} {page.url.last ? <a href={page.url.last}>Last</a> : null} ``` Learn more about [the pagination `page` prop](/en/reference/routing-reference/#the-pagination-page-prop). ### Nested Pagination [Section titled ‚ÄúNested Pagination‚Äù](#nested-pagination) A more advanced use-case for pagination is **nested pagination.** This is when pagination is combined with other dynamic route params. You can use nested pagination to group your paginated collection by some property or tag. For example, if you want to group your paginated Markdown posts by some tag, you would use nested pagination by creating a `/src/pages/[tag]/[page].astro` page that would match the following URLS: * `/red/1` (tag=red) * `/red/2` (tag=red) * `/blue/1` (tag=blue) * `/green/1` (tag=green) Nested pagination works by returning an array of `paginate()` results from `getStaticPaths()`, one for each grouping. In the following example, we will implement nested pagination to build the URLs listed above: src/pages/\[tag]/\[page].astro ```astro --- export function getStaticPaths({ paginate }) { const allTags = ["red", "blue", "green"]; const allPosts = Object.values(import.meta.glob("../pages/post/*.md", { eager: true })); // For every tag, return a `paginate()` result. // Make sure that you pass `{ params: { tag }}` to `paginate()` // so that Astro knows which tag grouping the result is for. return allTags.flatMap((tag) => { const filteredPosts = allPosts.filter((post) => post.frontmatter.tag === tag); return paginate(filteredPosts, { params: { tag }, pageSize: 10 }); }); } const { page } = Astro.props; const params = Astro.params; ``` ## Excluding pages [Section titled ‚ÄúExcluding pages‚Äù](#excluding-pages) You can exclude pages or directories within `src/pages` from being built by prefixing their names with an underscore (`_`). Files with the `_` prefix won‚Äôt be recognized by the router and won‚Äôt be placed into the `dist/` directory. You can use this to temporarily disable pages, and also to put tests, utilities, and components in the same folder as their related pages. In this example, only `src/pages/index.astro` and `src/pages/projects/project1.md` will be built as page routes and HTML files.

# Server islands

> Combine high performance static HTML with dynamic server-rendered content.

Server islands allow you to on-demand render dynamic or personalized ‚Äúislands‚Äù individually, without sacrificing the performance of the rest of the page. This means your visitor will see the most important parts of your page sooner, and allows your main content to be more aggressively cached, providing faster performance. ## Server island components [Section titled ‚ÄúServer island components‚Äù](#server-island-components) A server island is a normal server-rendered [Astro component](/en/basics/astro-components/) that is instructed to delay rendering until its contents are available. Your page will be rendered immediately with any specified [fallback content as a placeholder](#server-island-fallback-content). Then, the component‚Äôs own contents are fetched on the client and displayed when available. With [an adapter installed](/en/guides/on-demand-rendering/#server-adapters) to perform the delayed rendering, add the [`server:defer` directive](/en/reference/directives-reference/#server-directives) to any component on your page to turn it into its own island: src/pages/index.astro ```astro --- import Avatar from '../components/Avatar.astro'; --- <Avatar server:defer /> ``` These components can do [anything you normally would in an on-demand rendered page](/en/guides/on-demand-rendering/#on-demand-rendering-features) using an adapter, such as fetch content, and access cookies: src/components/Avatar.astro ```astro --- import { getUserAvatar } from '../sessions'; const userSession = Astro.cookies.get('session'); const avatarURL = await getUserAvatar(userSession); --- <img alt="User avatar" src={avatarURL} /> ``` ### Passing props to server islands [Section titled ‚ÄúPassing props to server islands‚Äù](#passing-props-to-server-islands) Props provided to server island components must be [serializable](https://developer.mozilla.org/en-US/docs/Glossary/Serialization): able to be translated into a format suitable for transfer over a network, or storage. Additionally, Astro does not serialize every type of serializable data structure. Therefore, there are some limitations on what can be passed as props to a server island. Notably, functions cannot be passed to components marked with `server:defer` as they cannot be serialized. Objects with circular references are also not serializable. The following prop types are supported: plain object, `number`, `string`, `Array`, `Map`, `Set`, `RegExp`, `Date`, `BigInt`, `URL`, `Uint8Array`, `Uint16Array`, `Uint32Array`, and `Infinity` ## Server island fallback content [Section titled ‚ÄúServer island fallback content‚Äù](#server-island-fallback-content) When using the `server:defer` attribute on a component to delay its rendering, you can ‚Äúslot‚Äù in default loading content using the included named `"fallback"` slot. Your fallback content will be rendered along with the rest of the page initially on page load and will be replaced with your component‚Äôs content when available. To add fallback content, add `slot="fallback"` on a child (other components or HTML elements) passed to your server island component: ```astro --- import Avatar from '../components/Avatar.astro'; import GenericAvatar from '../components/GenericAvatar.astro'; --- <Avatar server:defer> <GenericAvatar slot="fallback" /> </Avatar> ``` This fallback content can be things like: * A generic avatar instead of the user‚Äôs own. * Placeholder UI such as custom messages. * Loading indicators such as spinners. ## How it works [Section titled ‚ÄúHow it works‚Äù](#how-it-works) Server island implementation happens mostly at build-time where component content is swapped out for a small script. Each of the islands marked with `server:defer` is split off into its own special route which the script fetches at run time. When Astro builds your site it will omit the component and inject a script in its place, and any content you‚Äôve marked with `slot="fallback"`. When the page loads in the browser, these components will be requested to a special endpoint that renders them and returns the HTML. This means that users will see the most critical parts of the page instantly. Fallback content will be visible for a short amount of time before the dynamic islands are then loaded. Each island is loaded independently from the rest. This means a slower island won‚Äôt delay the rest of your personalized content from being available. This rendering pattern was built to be portable. It does not depend on any server infrastructure so it will work with any host you have, from a Node.js server in a Docker container to the serverless provider of your choice. ## Caching [Section titled ‚ÄúCaching‚Äù](#caching) The data for server islands is retrieved via a `GET` request, passing props as an encrypted string in the URL query. This allows caching data with the [`Cache-Control` HTTP header](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control) using standard `Cache-Control` directives. However, [the browser limits URLs to a maximum length of 2048 bytes](https://chromium.googlesource.com/chromium/src/+/master/docs/security/url_display_guidelines/url_display_guidelines.md#url-length) for practical reasons and to avoid causing denial-of-service problems. If your query string causes your URL to exceed this limit, Astro will instead send a `POST` request that contains all props in the body. `POST` requests are not cached by browsers because they are used to submit data, and could cause data integrity or security issues. Therefore, any existing caching logic in your project will break. Whenever possible, pass only necessary props to your server islands and avoid sending entire data objects and arrays to keep your query small. ## Accessing the page URL in a server island [Section titled ‚ÄúAccessing the page URL in a server island‚Äù](#accessing-the-page-url-in-a-server-island) In most cases you, your server island component can get information about the page rendering it by [passing props](/en/basics/astro-components/#component-props) like in normal components. However, server islands run in their own isolated context outside of the page request. `Astro.url` and `Astro.request.url` in a server island component both return a URL that looks like `/_server-islands/Avatar` instead of the current page‚Äôs URL in the browser. Additionally, if you are prerendering the page you will not have access to information such as query parameters in order to pass as props. To access information from the page‚Äôs URL, you can check the [Referer](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referer) header, which will contain the address of the page that is loading the island in the browser: ```astro --- const referer = Astro.request.headers.get('Referer'); const url = new URL(referer); const productId = url.searchParams.get('product'); --- ``` ## Reusing the encryption key [Section titled ‚ÄúReusing the encryption key‚Äù](#reusing-the-encryption-key) Astro uses [cryptography](https://developer.mozilla.org/en-US/docs/Glossary/Cryptography) to encrypt props passed to server islands, protecting sensitive data from accidental exposure. This encryption relies on a new, random key that is generated on each build and embedded in the server bundle. Most deploy hosts will handle keeping your front end and back end in sync automatically. However, you may need a constant encryption key if you are using rolling deployments, multi-region hosting or a CDN that caches pages containing server islands. In environments with rolling deployments (e.g., Kubernetes) where your frontend assets (which encrypt props) and your backend functions (which decrypt props) may be temporarily using different keys, or when a CDN is still serving pages built with an old key, encrypted props passed to your server island cannot be decrypted. In these situations, use the Astro CLI to generate a reusable, encoded encryption key to set as an environment variable in your build environment: ```shell astro create-key ``` Use this value to configure the `ASTRO_KEY` environment variable (e.g. in a `.env` file) and include it in your CI/CD or host‚Äôs build settings. This ensures the same key is always reused in the generated bundle so that encryption and decryption remain in sync.

# Sessions

> Share data between requests for on-demand rendered pages.

**Added in:** `astro@5.7.0` Sessions are used to share data between requests for [on-demand rendered pages](/en/guides/on-demand-rendering/). Unlike [`cookies`](/en/guides/on-demand-rendering/#cookies), sessions are stored on the server, so you can store larger amounts of data without worrying about size limits or security issues. They are useful for storing things like user data, shopping carts, and form state, and they work without any client-side JavaScript: src/components/CartButton.astro ```astro --- export const prerender = false; // Not needed with 'server' output const cart = await Astro.session?.get('cart'); --- <a href="/checkout">üõí {cart?.length ?? 0} items</a> ``` ## Configuring sessions [Section titled ‚ÄúConfiguring sessions‚Äù](#configuring-sessions) Sessions require a storage driver to store the session data. The [Node](/en/guides/integrations-guide/node/#sessions), [Cloudflare](/en/guides/integrations-guide/cloudflare/#sessions), and [Netlify](/en/guides/integrations-guide/netlify/#sessions) adapters automatically configure a default driver for you, but other adapters currently require you to [specify a driver manually](/en/reference/configuration-reference/#sessiondriver). astro.config.mjs ```diff { adapter: vercel(), session: { + driver: "redis", }, } ``` See [the `session` configuration option](/en/reference/configuration-reference/#session-options) for more details on setting a storage driver, and other configurable options. ## Interacting with session data [Section titled ‚ÄúInteracting with session data‚Äù](#interacting-with-session-data) The [`session` object](/en/reference/api-reference/#session) allows you to interact with the stored user state (e.g. adding items to a shopping cart) and the session ID (e.g. deleting the session ID cookie when logging out). The object is accessible as `Astro.session` in your Astro components and pages and as `context.session` object in API endpoints, middleware, and actions. The session is generated automatically when it is first used and can be regenerated at any time with [`session.regenerate()`](/en/reference/api-reference/#regenerate) or destroyed with [`session.destroy()`](/en/reference/api-reference/#destroy). For many use cases, you will only need to use [`session.get()`](/en/reference/api-reference/#get) and [`session.set()`](/en/reference/api-reference/#set). See [the Sessions API reference](/en/reference/api-reference/#session) for more details. ### Astro components and pages [Section titled ‚ÄúAstro components and pages‚Äù](#astro-components-and-pages) In `.astro` components and pages, you can access the session object via the global `Astro` object. For example, to display the number of items in a shopping cart: src/components/CartButton.astro ```astro --- export const prerender = false; // Not needed with 'server' output const cart = await Astro.session?.get('cart'); --- <a href="/checkout">üõí {cart?.length ?? 0} items</a> ``` ### API endpoints [Section titled ‚ÄúAPI endpoints‚Äù](#api-endpoints) In API endpoints, the session object is available on the `context` object. For example, to add an item to a shopping cart: src/pages/api/addToCart.ts ```ts export async function POST(context: APIContext) { const cart = await context.session?.get('cart') || []; const data = await context.request.json<{ item: string }>(); if(!data?.item) { return new Response('Item is required', { status: 400 }); } cart.push(data.item); await context.session?.set('cart', cart); return Response.json(cart); } ``` ### Actions [Section titled ‚ÄúActions‚Äù](#actions) In actions, the session object is available on the `context` object. For example, to add an item to a shopping cart: src/actions/addToCart.ts ```ts import { defineAction } from 'astro:actions'; import { z } from 'astro/zod'; export const server = { addToCart: defineAction({ input: z.object({ productId: z.string() }), handler: async (input, context) => { const cart = await context.session?.get('cart'); cart.push(input.productId); await context.session?.set('cart', cart); return cart; }, }), }; ``` ### Middleware [Section titled ‚ÄúMiddleware‚Äù](#middleware) In middleware, the session object is available on the `context` object. For example, to set the last visit time in the session: src/middleware.ts ```ts import { defineMiddleware } from 'astro:middleware'; export const onRequest = defineMiddleware(async (context, next) => { context.session?.set('lastVisit', new Date()); return next(); }); ``` ## Session data types [Section titled ‚ÄúSession data types‚Äù](#session-data-types) By default session data is untyped, and you can store arbitrary data in any key. Values are serialized and deserialized using [devalue](https://github.com/Rich-Harris/devalue), which is the same library used in content collections and actions. This means that supported types are the same, and include strings, numbers, `Date`, `Map`, `Set`, `URL`, arrays, and plain objects. You can optionally [define TypeScript types](/en/guides/typescript/#extending-global-types) for your session data by creating a `src/env.d.ts` file and adding a declaration for the `App.SessionData` type: src/env.d.ts ```ts declare namespace App { interface SessionData { user: { id: string; name: string; }; cart: string[]; } } ``` This will allow you to access the session data with type-checking and auto-completion in your editor: src/components/CartButton.astro ```ts --- const cart = await Astro.session?.get('cart'); // const cart: string[] | undefined const something = await Astro.session?.get('something'); // const something: any Astro.session?.set('user', { id: 1, name: 'Houston' }); // Error: Argument of type '{ id: number; name: string }' is not assignable to parameter of type '{ id: string; name: string; }'. --- ``` Caution This is only used for type-checking and does not affect the runtime behavior of the session. Take extra care if you change the type when users have stored data in the session, as this could cause runtime errors.

# Styles and CSS

> Learn how to style components in Astro with scoped styles, external CSS, and tooling like Sass and PostCSS.

Astro was designed to make styling and writing CSS a breeze. Write your own CSS directly inside of an Astro component or import your favorite CSS library like [Tailwind](https://tailwindcss.com/docs/installation/framework-guides/astro). Advanced styling languages like [Sass](https://sass-lang.com/) and [Less](https://lesscss.org/) are also supported. ## Styling in Astro [Section titled ‚ÄúStyling in Astro‚Äù](#styling-in-astro) Styling an Astro component is as easy as adding a `<style>` tag to your component or page template. When you place a `<style>` tag inside of an Astro component, Astro will detect the CSS and handle your styles for you, automatically. src/components/MyComponent.astro ```astro <style> h1 { color: red; } </style> ``` ### Scoped Styles [Section titled ‚ÄúScoped Styles‚Äù](#scoped-styles) Astro `<style>` CSS rules are automatically **scoped by default**. Scoped styles are compiled behind-the-scenes to only apply to HTML written inside of that same component. The CSS that you write inside of an Astro component is automatically encapsulated inside of that component. This CSS: src/pages/index.astro ```astro <style> h1 { color: red; } .text { color: blue; } </style> ``` Compiles to this: ```astro <style> h1[data-astro-cid-hhnqfkh6] { color: red; } .text[data-astro-cid-hhnqfkh6] { color: blue; } </style> ``` Scoped styles don‚Äôt leak and won‚Äôt impact the rest of your site. In Astro, it is okay to use low-specificity selectors like `h1 {}` or `p {}` because they will be compiled with scopes in the final output. Scoped styles also won‚Äôt apply to other Astro components contained inside of your template. If you need to style a child component, consider wrapping that component in a `<div>` (or other element) that you can then style. The specificity of scoped styles is preserved, allowing them to work consistently alongside other CSS files or CSS libraries while still preserving the exclusive boundaries that prevent styles from applying outside the component. ### Global Styles [Section titled ‚ÄúGlobal Styles‚Äù](#global-styles) While we recommend scoped styles for most components, you may eventually find a valid reason to write global, unscoped CSS. You can opt-out of automatic CSS scoping with the `<style is:global>` attribute. src/components/GlobalStyles.astro ```astro <style is:global> /* Unscoped, delivered as-is to the browser. Applies to all <h1> tags on your site. */ h1 { color: red; } </style> ``` You can also mix global & scoped CSS rules together in the same `<style>` tag using the `:global()` selector. This becomes a powerful pattern for applying CSS styles to children of your component. src/components/MixedStyles.astro ```astro <style> /* Scoped to this component, only. */ h1 { color: red; } /* Mixed: Applies to child `h1` elements only. */ article :global(h1) { color: blue; } </style> <h1>Title</h1> <article><slot /></article> ``` This is a great way to style things like blog posts, or documents with CMS-powered content where the contents live outside of Astro. But be careful: components whose appearance differs based on whether or not they have a certain parent component can become difficult to troubleshoot. Scoped styles should be used as often as possible. Global styles should be used only as-needed. ### Combining classes with `class:list` [Section titled ‚ÄúCombining classes with class:list‚Äù](#combining-classes-with-classlist) If you need to combine classes on an element dynamically, you can use the `class:list` utility attribute in `.astro` files. src/components/ClassList.astro ```astro --- const { isRed } = Astro.props; --- <!-- If `isRed` is truthy, class will be "box red". --> <!-- If `isRed` is falsy, class will be "box". --> <div class:list={['box', { red: isRed }]}><slot /></div> <style> .box { border: 1px solid blue; } .red { border-color: red; } </style> ``` See our [directives reference](/en/reference/directives-reference/#classlist) page to learn more about `class:list`. ### CSS Variables [Section titled ‚ÄúCSS Variables‚Äù](#css-variables) **Added in:** `astro@0.21.0` The Astro `<style>` can reference any CSS variables available on the page. You can also pass CSS variables directly from your component frontmatter using the `define:vars` directive. src/components/DefineVars.astro ```astro --- const foregroundColor = "rgb(221 243 228)"; const backgroundColor = "rgb(24 121 78)"; --- <style define:vars={{ foregroundColor, backgroundColor }}> h1 { background-color: var(--backgroundColor); color: var(--foregroundColor); } </style> <h1>Hello</h1> ``` See our [directives reference](/en/reference/directives-reference/#definevars) page to learn more about `define:vars`. ### Passing a `class` to a child component [Section titled ‚ÄúPassing a class to a child component‚Äù](#passing-a-class-to-a-child-component) In Astro, HTML attributes like `class` do not automatically pass through to child components. Instead, accept a `class` prop in the child component and apply it to the root element. When destructuring, you must rename it, because `class` is a [reserved word](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Lexical_grammar#reserved_words) in JavaScript. Using the default scoped style strategy, you must also pass the `data-astro-cid-*` attribute. You can do this by passing the `...rest` of the props to the component. If you have changed `scopedStyleStrategy` to `'class'` or `'where'`, the `...rest` prop is not necessary. src/components/MyComponent.astro ```astro --- const { class: className, ...rest } = Astro.props; --- <div class={className} {...rest}> <slot/> </div> ``` src/pages/index.astro ```astro --- import MyComponent from "../components/MyComponent.astro" --- <style> .red { color: red; } </style> <MyComponent class="red">This will be red!</MyComponent> ``` ### Inline styles [Section titled ‚ÄúInline styles‚Äù](#inline-styles) You can style HTML elements inline using the `style` attribute. This can be a CSS string or an object of CSS properties: src/pages/index.astro ```astro // These are equivalent: <p style={{ color: "brown", textDecoration: "underline" }}>My text</p> <p style="color: brown; text-decoration: underline;">My text</p> ``` ## External Styles [Section titled ‚ÄúExternal Styles‚Äù](#external-styles) There are two ways to resolve external global stylesheets: an ESM import for files located within your project source, and an absolute URL link for files in your `public/` directory, or hosted outside of your project. Read more about using [static assets](/en/guides/imports/) located in `public/` or `src/`. ### Import a local stylesheet [Section titled ‚ÄúImport a local stylesheet‚Äù](#import-a-local-stylesheet) Using an npm package? You may need to update your `astro.config` when importing from npm packages. See the [‚Äúimport stylesheets from an npm package‚Äù section](#import-a-stylesheet-from-an-npm-package) below. You can import stylesheets in your Astro component frontmatter using ESM import syntax. CSS imports work like [any other ESM import in an Astro component](/en/basics/astro-components/#the-component-script), which should be referenced as **relative to the component** and must be written at the **top** of your component script, with any other imports. src/pages/index.astro ```astro --- // Astro will bundle and optimize this CSS for you automatically // This also works for preprocessor files like .scss, .styl, etc. import '../styles/utils.css'; --- <html><!-- Your page here --></html> ``` CSS `import` via ESM are supported inside of any JavaScript file, including JSX components like React & Preact. This can be useful for writing granular, per-component styles for your React components. ### Import a stylesheet from an npm package [Section titled ‚ÄúImport a stylesheet from an npm package‚Äù](#import-a-stylesheet-from-an-npm-package) You may also need to load stylesheets from an external npm package. This is especially common for utilities like [Open Props](https://open-props.style/). If your package **recommends using a file extension** (i.e. `package-name/styles.css` instead of `package-name/styles`), this should work like any local stylesheet: src/pages/random-page.astro ```astro --- import 'package-name/styles.css'; --- <html><!-- Your page here --></html> ``` If your package **does not suggest using a file extension** (i.e. `package-name/styles`), you‚Äôll need to update your Astro config first! Say you are importing a CSS file from `package-name` called `normalize` (with the file extension omitted). To ensure we can prerender your page correctly, add `package-name` to [the `vite.ssr.noExternal` array](https://vite.dev/config/ssr-options.html#ssr-noexternal): astro.config.mjs ```diff import { defineConfig } from 'astro/config'; export default defineConfig({ vite: { ssr: { + noExternal: ['package-name'], } } }) ``` Now, you are free to import `package-name/normalize`. This will be bundled and optimized by Astro like any other local stylesheet. src/pages/random-page.astro ```astro --- import 'package-name/normalize'; --- <html><!-- Your page here --></html> ``` ### Load a static stylesheet via ‚Äúlink‚Äù tags [Section titled ‚ÄúLoad a static stylesheet via ‚Äúlink‚Äù tags‚Äù](#load-a-static-stylesheet-via-link-tags) You can also use the `<link>` element to load a stylesheet on the page. This should be an absolute URL path to a CSS file located in your `/public` directory, or an URL to an external website. Relative `<link>` href values are not supported. src/pages/index.astro ```astro <head> <!-- Local: /public/styles/global.css --> <link rel="stylesheet" href="/styles/global.css" /> <!-- External --> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.24.1/themes/prism-tomorrow.css" /> </head> ``` Because this approach uses the `public/` directory, it skips the normal CSS processing, bundling and optimizations that are provided by Astro. If you need these transformations, use the [Import a Stylesheet](#import-a-local-stylesheet) method above. ## Cascading Order [Section titled ‚ÄúCascading Order‚Äù](#cascading-order) Astro components will sometimes have to evaluate multiple sources of CSS. For example, your component might import a CSS stylesheet, include its own `<style>` tag, *and* be rendered inside a layout that imports CSS. When conflicting CSS rules apply to the same element, browsers first use *specificity* and then *order of appearance* to determine which value to show. If one rule is more *specific* than another, no matter where the CSS rule appears, its value will take precedence: src/components/MyComponent.astro ```astro <style> h1 { color: red } div > h1 { color: purple } </style> <div> <h1> This header will be purple! </h1> </div> ``` If two rules have the same specificity, then the *order of appearance* is evaluated, and the last rule‚Äôs value will take precedence: src/components/MyComponent.astro ```astro <style> h1 { color: purple } h1 { color: red } </style> <div> <h1> This header will be red! </h1> </div> ``` Astro CSS rules are evaluated in this order of appearance: * **`<link>` tags in the head** (lowest precedence) * **imported styles** * **scoped styles** (highest precedence) ### Scoped Styles [Section titled ‚ÄúScoped Styles‚Äù](#scoped-styles-1) Depending on your chosen value for [`scopedStyleStrategy`](/en/reference/configuration-reference/#scopedstylestrategy), scoped styles may or may not increase the [CLASS column specificity](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_cascade/Specificity#class_column). However, [scoped styles](#scoped-styles) will always come last in the order of appearance. These styles will therefore take precedence over other styles of the same specificity. For example, if you import a stylesheet that conflicts with a scoped style, the scoped style‚Äôs value will apply: src/components/make-it-purple.css ```css h1 { color: purple; } ``` src/components/MyComponent.astro ```astro --- import "./make-it-purple.css" --- <style> h1 { color: red } </style> <div> <h1> This header will be red! </h1> </div> ``` Scoped styles will be overwritten if the imported style is more specific. The style with a higher specificity will take precedence over the scoped style: src/components/make-it-purple.css ```css #intro { color: purple; } ``` src/components/MyComponent.astro ```astro --- import "./make-it-purple.css" --- <style> h1 { color: red } </style> <div> <h1 id="intro"> This header will be purple! </h1> </div> ``` ### Import Order [Section titled ‚ÄúImport Order‚Äù](#import-order) When importing multiple stylesheets in an Astro component, the CSS rules are evaluated in the order that they are imported. A higher specificity will always determine which styles to show, no matter when the CSS is evaluated. But, when conflicting styles have the same specificity, the *last one imported* wins: src/components/make-it-purple.css ```css div > h1 { color: purple; } ``` src/components/make-it-green.css ```css div > h1 { color: green; } ``` src/components/MyComponent.astro ```astro --- import "./make-it-green.css" import "./make-it-purple.css" --- <style> h1 { color: red } </style> <div> <h1> This header will be purple! </h1> </div> ``` While `<style>` tags are scoped and only apply to the component that declares them, *imported* CSS can ‚Äúleak‚Äù. Importing a component applies any CSS it imports, even if the component is never used: src/components/PurpleComponent.astro ```astro --- import "./make-it-purple.css" --- <div> <h1>I import purple CSS.</h1> </div> ``` src/components/MyComponent.astro ```astro --- import "./make-it-green.css" import PurpleComponent from "./PurpleComponent.astro"; --- <style> h1 { color: red } </style> <div> <h1> This header will be purple! </h1> </div> ``` ### Link Tags [Section titled ‚ÄúLink Tags‚Äù](#link-tags) Style sheets loaded via [link tags](#load-a-static-stylesheet-via-link-tags) are evaluated in order, before any other styles in an Astro file. Therefore, these styles will have lower precedence than imported stylesheets and scoped styles: src/pages/index.astro ```astro --- import "../components/make-it-purple.css" --- <html lang="en"> <head> <meta charset="utf-8" /> <link rel="icon" type="image/svg+xml" href="/favicon.svg" /> <meta name="viewport" content="width=device-width" /> <meta name="generator" content={Astro.generator} /> <title>Astro</title> <link rel="stylesheet" href="/styles/make-it-blue.css" /> </head> <body> <div> <h1>This will be purple</h1> </div> </body> </html> ``` ## Tailwind [Section titled ‚ÄúTailwind‚Äù](#tailwind) Astro comes with support for adding popular CSS libraries, tools, and frameworks to your project like [Tailwind](https://tailwindcss.com) and more! Astro supports both Tailwind 3 and 4. You can [add Tailwind 4 support through a Vite plugin](#add-tailwind-4) to your project with a CLI command, or install legacy dependencies manually to add [Tailwind 3 support through an Astro integration](#legacy-tailwind-3-support). To [upgrade your Astro project from Tailwind 3 to 4](#upgrade-from-tailwind-3) you will need to both add Tailwind 4 support, and remove legacy Tailwind 3 support. ### Add Tailwind 4 [Section titled ‚ÄúAdd Tailwind 4‚Äù](#add-tailwind-4) In Astro `>=5.2.0`, use the `astro add tailwind` command for your package manager to install the official Vite Tailwind plugin. To add Tailwind 4 support to earlier versions of Astro, follow the [instructions in the Tailwind docs](https://tailwindcss.com/docs/installation/framework-guides/astro) to add the `@tailwindcss/vite` Vite plugin manually. * npm ```shell npx astro add tailwind ``` * pnpm ```shell pnpm astro add tailwind ``` * Yarn ```shell yarn astro add tailwind ``` Then, import `tailwindcss` into `src/styles/global.css` (or another CSS file of your choosing) to make Tailwind classes available to your Astro project. This file including the import will be created by default if you used the `astro add tailwind` command to install the Vite plugin. src/styles/global.css ```css @import "tailwindcss"; ``` Import this file in the pages where you want Tailwind to apply. This is often done in a layout component so that Tailwind styles can be used on all pages sharing that layout: src/layouts/Layout.astro ```astro --- import "../styles/global.css"; --- ``` ### Upgrade from Tailwind 3 [Section titled ‚ÄúUpgrade from Tailwind 3‚Äù](#upgrade-from-tailwind-3) Follow the steps to update an existing Astro project using Tailwind v3 (using the `@astrojs/tailwind` integration) to Tailwind 4 (using [the `@tailwindcss/vite` plugin](https://tailwindcss.com/docs/installation/framework-guides/astro)). 1. [Add Tailwind 4 support to your project](#add-tailwind-4) through the CLI for the latest version of Astro, or by adding the Vite plugin manually. 2. Uninstall the `@astrojs/tailwind` integration from your project: * npm ```shell npm uninstall @astrojs/tailwind ``` * pnpm ```shell pnpm remove @astrojs/tailwind ``` * Yarn ```shell yarn remove @astrojs/tailwind ``` 3. Remove the `@astrojs/tailwind` integration from your `astro.config.mjs`: astro.config.mjs ```diff import { defineConfig } from 'astro/config'; -import tailwind from '@astrojs/tailwind'; export default defineConfig({ // ... integrations: [tailwind()], // ... }); ``` 4. Then, upgrade your project according to [Tailwind‚Äôs v4 upgrade guide](https://tailwindcss.com/docs/upgrade-guide#changes-from-v3). ### Legacy Tailwind 3 support [Section titled ‚ÄúLegacy Tailwind 3 support‚Äù](#legacy-tailwind-3-support) To add (or keep) support for Tailwind 3, you will need to have both `tailwindcss@3` and the official Astro Tailwind integration `@astrojs/tailwind` installed. Installing these dependencies manually is only used for legacy Tailwind 3 compatibility, and is not required for Tailwind 4. You will also need a [legacy Tailwind configuration](https://v3.tailwindcss.com/docs/configuration#creating-your-configuration-file): 1. Install Tailwind and the Astro Tailwind integration to your project dependencies using your preferred package manager: * npm ```shell npm install tailwindcss@3 @astrojs/tailwind ``` * pnpm ```shell pnpm add tailwindcss@3 @astrojs/tailwind ``` * Yarn ```shell yarn add tailwindcss@3 @astrojs/tailwind ``` 2. Import the integration to your `astro.config.mjs` file, and add it to your `integrations[]` array: astro.config.mjs ```diff import { defineConfig } from 'astro/config'; +import tailwind from '@astrojs/tailwind'; export default defineConfig({ // ... integrations: [tailwind()], // ... }); ``` 3. Create a `tailwind.config.mjs` file in your project‚Äôs root directory. You can use the following command to generate a basic configuration file for you: * npm ```shell npx tailwindcss init ``` * pnpm ```shell pnpm dlx tailwindcss init ``` * Yarn ```shell yarn dlx tailwindcss init ``` 4. Add the following basic configuration to your `tailwind.config.mjs` file: tailwind.config.mjs ```diff /** @type {import('tailwindcss').Config} */ export default { + content: ['./src/**/*.{astro,html,js,jsx,md,mdx,svelte,ts,tsx,vue}'], theme: { extend: {}, }, plugins: [], }; ``` ![](/houston_chef.webp) **Related recipe:** [Style rendered Markdown with Tailwind Typography](/en/recipes/tailwind-rendered-markdown/) ## CSS Preprocessors [Section titled ‚ÄúCSS Preprocessors‚Äù](#css-preprocessors) Astro supports CSS preprocessors such as [Sass](https://sass-lang.com/), [Stylus](https://stylus-lang.com/), and [Less](https://lesscss.org/) through [Vite](https://vite.dev/guide/features.html#css-pre-processors). ### Sass and SCSS [Section titled ‚ÄúSass and SCSS‚Äù](#sass-and-scss) ```shell npm install sass ``` Use `<style lang="scss">` or `<style lang="sass">` in `.astro` files. ### Stylus [Section titled ‚ÄúStylus‚Äù](#stylus) ```shell npm install stylus ``` Use `<style lang="styl">` or `<style lang="stylus">` in `.astro` files. ### Less [Section titled ‚ÄúLess‚Äù](#less) ```shell npm install less ``` Use `<style lang="less">` in `.astro` files. ### LightningCSS [Section titled ‚ÄúLightningCSS‚Äù](#lightningcss) ```shell npm install lightningcss ``` Update your `vite` configuration in `astro.config.mjs`: astro.config.mjs ```diff import { defineConfig } from 'astro/config' export default defineConfig({ + vite: { + css: { + transformer: "lightningcss", + }, + }, }) ``` ### In framework components [Section titled ‚ÄúIn framework components‚Äù](#in-framework-components) You can also use all of the above CSS preprocessors within JS frameworks as well! Be sure to follow the patterns each framework recommends: * **React** / **Preact**: `import Styles from './styles.module.scss';` * **Vue**: `<style lang="scss">` * **Svelte**: `<style lang="scss">` ## PostCSS [Section titled ‚ÄúPostCSS‚Äù](#postcss) Astro comes with PostCSS included as part of [Vite](https://vite.dev/guide/features.html#postcss). To configure PostCSS for your project, create a `postcss.config.cjs` file in the project root. You can import plugins using `require()` after installing them (for example `npm install autoprefixer`). postcss.config.cjs ```diff module.exports = { plugins: [ +require('autoprefixer'), +require('cssnano'), ], }; ``` ## Frameworks and Libraries [Section titled ‚ÄúFrameworks and Libraries‚Äù](#frameworks-and-libraries) ### üìò React / Preact [Section titled ‚Äúüìò React / Preact‚Äù](#-react--preact) `.jsx` files support both global CSS and CSS Modules. To enable the latter, use the `.module.css` extension (or `.module.scss`/`.module.sass` if using Sass). src/components/MyReactComponent.jsx ```jsx import './global.css'; // include global CSS import Styles from './styles.module.css'; // Use CSS Modules (must end in `.module.css`, `.module.scss`, or `.module.sass`!) ``` ### üìó Vue [Section titled ‚Äúüìó Vue‚Äù](#-vue) Vue in Astro supports the same methods as `vue-loader` does: * [vue-loader - Scoped CSS](https://vue-loader.vuejs.org/guide/scoped-css.html) * [vue-loader - CSS Modules](https://vue-loader.vuejs.org/guide/css-modules.html) ### üìï Svelte [Section titled ‚Äúüìï Svelte‚Äù](#-svelte) Svelte in Astro also works exactly as expected: [Svelte Styling Docs](https://svelte.dev/docs#component-format-style). ## Markdown Styling [Section titled ‚ÄúMarkdown Styling‚Äù](#markdown-styling) Any Astro styling methods are available to a [Markdown layout component](/en/basics/layouts/#markdown-layouts), but different methods will have different styling effects on your page. You can apply global styles to your Markdown content by adding [imported stylesheets](#external-styles) to the layout that wraps your page content. It is also possible to style your Markdown with [`<style is:global>` tags](#global-styles) in the layout component. Note that any styles added are subject to [Astro‚Äôs cascading order](#cascading-order), and you should check your rendered page carefully to ensure your styles are being applied as intended. You can also add CSS integrations including [Tailwind](/en/recipes/tailwind-rendered-markdown/). If you are using Tailwind, the [typography plugin](https://tailwindcss.com/docs/typography-plugin) can be useful for styling Markdown. ## Production [Section titled ‚ÄúProduction‚Äù](#production) ### Bundle control [Section titled ‚ÄúBundle control‚Äù](#bundle-control) When Astro builds your site for production deployment, it minifies and combines your CSS into chunks. Each page on your site gets its own chunk, and additionally, CSS that is shared between multiple pages is further split off into their own chunks for reuse. However, when you have several pages sharing styles, some shared chunks can become really small. If all of them were sent separately, it would lead to many stylesheets requests and affect site performance. Therefore, by default Astro will link only those in your HTML above 4kB in size as `<link rel="stylesheet">` tags, while inlining smaller ones into `<style type="text/css">`. This approach provides a balance between the number of additional requests and the volume of CSS that can be cached between pages. You can configure the size at which stylesheets will be linked externally (in bytes) using the `assetsInlineLimit` vite build option. Note that this option affects script and image inlining as well. astro.config.mjs ```js import { defineConfig } from 'astro/config'; export default defineConfig({ vite: { build: { assetsInlineLimit: 1024, } }; }); ``` If you would rather all project styles remain external, you can configure the `inlineStylesheets` build option. astro.config.mjs ```js import { defineConfig } from 'astro/config'; export default defineConfig({ build: { inlineStylesheets: 'never' } }); ``` You can also set this option to `'always'` which will inline all stylesheets. ## Advanced [Section titled ‚ÄúAdvanced‚Äù](#advanced) Caution Be careful when bypassing Astro‚Äôs built-in CSS bundling! Styles won‚Äôt be automatically included in the built output, and it is your responsibility to make sure that the referenced file is properly included in the final page output. ### `?raw` CSS Imports [Section titled ‚Äú?raw CSS Imports‚Äù](#raw-css-imports) For advanced use cases, CSS can be read directly from disk without being bundled or optimized by Astro. This can be useful when you need complete control over some snippet of CSS, and need to bypass Astro‚Äôs automatic CSS handling. This is not recommended for most users. src/components/RawInlineStyles.astro ```astro --- // Advanced example! Not recommended for most users. import rawStylesCSS from '../styles/main.css?raw'; --- <style is:inline set:html={rawStylesCSS}></style> ``` See [Vite‚Äôs docs](https://vite.dev/guide/assets.html#importing-asset-as-string) for full details. ### `?url` CSS Imports [Section titled ‚Äú?url CSS Imports‚Äù](#url-css-imports) For advanced use cases, you can import a direct URL reference for a CSS file inside of your project `src/` directory. This can be useful when you need complete control over how a CSS file is loaded on the page. However, this will prevent the optimization of that CSS file with the rest of your page CSS . This is not recommended for most users. Instead, place your CSS files inside of `public/` to get a consistent URL reference. Caution Importing a smaller CSS file with `?url` may return the base64 encoded contents of the CSS file as a data URL in your final build. Either write your code to support encoded data URLs (`data:text/css;base64,...`) or set the [`vite.build.assetsInlineLimit`](https://vite.dev/config/#build-assetsinlinelimit) config option to `0` to disable this feature. src/components/RawStylesUrl.astro ```astro --- // Advanced example! Not recommended for most users. import stylesUrl from '../styles/main.css?url'; --- <link rel="preload" href={stylesUrl} as="style"> <link rel="stylesheet" href={stylesUrl}> ``` See [Vite‚Äôs docs](https://vite.dev/guide/assets.html#importing-asset-as-url) for full details.

# Syntax Highlighting

> Learn how to highlight your code blocks in Astro.

Astro comes with built-in support for [Shiki](https://shiki.style/) and [Prism](https://prismjs.com/). This provides syntax highlighting for: * all [code fences (\`\`\`)](#markdown-code-blocks) used in a Markdown or MDX file. * content within the [built-in `<Code />` component](#code-) (powered by Shiki) in `.astro` files. * content within the [`<Prism />` component](#prism-) (powered by Prism) in `.astro` files. Add [community integrations such as Expressive Code](https://astro.build/integrations/?search=syntax+highlight) for even more text marking and annotation options in your code blocks. ## Markdown code blocks [Section titled ‚ÄúMarkdown code blocks‚Äù](#markdown-code-blocks) A Markdown code block is indicated by a block with three backticks \`\`\` at the start and end. You can indicate the programming language being used after the opening backticks to indicate how to color and style your code to make it easier to read. ````markdown ```js // Javascript code with syntax highlighting. var fun = function lang(l) { dateformat.i18n = require('./lang/' + l); return true; }; ``` ```` Astro‚Äôs Markdown code blocks are styled by Shiki by default, preconfigured with the `github-dark` theme. The compiled output will be limited to inline `style`s without any extraneous CSS classes, stylesheets, or client-side JS. You can [add a Prism stylesheet and switch to Prism‚Äôs highlighting](#add-a-prism-stylesheet), or disable Astro‚Äôs syntax highlighting entirely, with the [`markdown.syntaxHighlight`](/en/reference/configuration-reference/#markdownsyntaxhighlight) configuration option. See the full [`markdown.shikiConfig` reference](/en/reference/configuration-reference/#markdownshikiconfig) for the complete set of Markdown syntax highlighting options available when using Shiki. ### Setting a default Shiki theme [Section titled ‚ÄúSetting a default Shiki theme‚Äù](#setting-a-default-shiki-theme) You can configure any [built-in Shiki theme](https://shiki.style/themes) for your Markdown code blocks in your Astro config: astro.config.mjs ```js import { defineConfig } from 'astro/config'; export default defineConfig({ markdown: { shikiConfig: { theme: 'dracula', }, }, }); ``` See the full [Shiki config reference](/en/reference/configuration-reference/#markdownshikiconfig) for the complete set of Markdown code block options. ### Setting light and dark mode themes [Section titled ‚ÄúSetting light and dark mode themes‚Äù](#setting-light-and-dark-mode-themes) You can specify dual Shiki themes for light and dark mode in your Astro config: astro.config.mjs ```js import { defineConfig } from 'astro/config'; export default defineConfig({ markdown: { shikiConfig: { themes: { light: 'github-light', dark: 'github-dark', }, }, }, }); ``` Then, [add Shiki‚Äôs dark mode CSS variables via media query or classes](https://shiki.style/guide/dual-themes#query-based-dark-mode) to apply to all your Markdown code blocks by default. Replace the `.shiki` class in the examples from Shiki‚Äôs documentation with `.astro-code`: src/styles/global.css ```diff @media (prefers-color-scheme: dark) { -.shiki, -.shiki span { + .astro-code, + .astro-code span { color: var(--shiki-dark) !important; background-color: var(--shiki-dark-bg) !important; /* Optional, if you also want font styles */ font-style: var(--shiki-dark-font-style) !important; font-weight: var(--shiki-dark-font-weight) !important; text-decoration: var(--shiki-dark-text-decoration) !important; } } ``` See the full [Shiki config reference](/en/reference/configuration-reference/#markdownshikiconfig) for the complete set of Markdown code block options. ### Adding your own Shiki theme [Section titled ‚ÄúAdding your own Shiki theme‚Äù](#adding-your-own-shiki-theme) Instead of using one of Shiki‚Äôs predefined themes, you can import a custom Shiki theme from a local file. astro.config.mjs ```diff import { defineConfig } from 'astro/config'; +import customTheme from './my-shiki-theme.json'; export default defineConfig({ markdown: { shikiConfig: { + theme: customTheme, }, }, }); ``` ### Customizing Shiki themes [Section titled ‚ÄúCustomizing Shiki themes‚Äù](#customizing-shiki-themes) You can follow [Shiki‚Äôs own theme documentation](https://shiki.style/themes) for more customization options for themes, [light vs dark mode toggles](https://shiki.style/guide/dual-themes), or styling via [CSS variables](https://shiki.style/guide/theme-colors#css-variables-theme). You will need to adjust the examples from Shiki‚Äôs documentation for your Astro project by making the following substitutions: * Code blocks are styled using the `.astro-code` class instead of `.shiki` * When using the `css-variables` theme, custom properties are prefixed with `--astro-code-` instead of `--shiki-` ## Components for code blocks [Section titled ‚ÄúComponents for code blocks‚Äù](#components-for-code-blocks) There are two Astro components available for `.astro` and `.mdx` files to render code blocks: [`<Code />`](#code-) and [`<Prism />`](#prism-). You can reference the `Props` of these components using the [`ComponentProps` type](/en/guides/typescript/#componentprops-type) utility. ### `<Code />` [Section titled ‚Äú\<Code />‚Äù](#code-) This component is powered internally by Shiki. It supports all popular Shiki themes and languages as well as several other Shiki options such as custom themes, languages, [transformers](#transformers), and default colors. These values are passed to the `<Code />` component using the `theme`, `lang`, `transformers`, and `defaultColor` attributes respectively as props. The `<Code />` component will not inherit your `shikiConfig` settings for Markdown code blocks. ```astro --- import { Code } from 'astro:components'; --- <!-- Syntax highlight some JavaScript code. --> <Code code={`const foo = 'bar';`} lang="js" /> <!-- Optional: Customize your theme. --> <Code code={`const foo = 'bar';`} lang="js" theme="dark-plus" /> <!-- Optional: Enable word wrapping. --> <Code code={`const foo = 'bar';`} lang="js" wrap /> <!-- Optional: Output inline code. --> <p> <Code code={`const foo = 'bar';`} lang="js" inline /> will be rendered inline. </p> <!-- Optional: defaultColor --> <Code code={`const foo = 'bar';`} lang="js" defaultColor={false} /> ``` #### Transformers [Section titled ‚ÄúTransformers‚Äù](#transformers) **Added in:** `astro@4.11.0` [Shiki transformers](https://shiki.style/packages/transformers#shikijs-transformers) can optionally be applied to code by passing them in through the `transformers` property as an array. Since Astro v4.14.0, you can also provide a string for [Shiki‚Äôs `meta` attribute](https://shiki.style/guide/transformers#meta) to pass options to transformers. Note that `transformers` only applies classes and you must provide your own CSS rules to target the elements of your code block. src/pages/index.astro ```astro --- import { transformerNotationFocus, transformerMetaHighlight } from '@shikijs/transformers' import { Code } from 'astro:components' const code = `const foo = 'hello' const bar = ' world' console.log(foo + bar) // [!code focus] ` --- <Code code={code} lang="js" transformers={[transformerMetaHighlight()]} meta="{1,3}" /> <style is:global> pre.has-focused .line:not(.focused) { filter: blur(1px); } </style> ``` ### `<Prism />` [Section titled ‚Äú\<Prism />‚Äù](#prism-) This component provides language-specific syntax highlighting for code blocks by applying Prism‚Äôs CSS classes. Note that you must [provide a Prism CSS stylesheet](#add-a-prism-stylesheet) (or bring your own) to style the classes. To use the `Prism` highlighter component, you must install the `@astrojs/prism` package: * npm ```shell npm install @astrojs/prism ``` * pnpm ```shell pnpm add @astrojs/prism ``` * Yarn ```shell yarn add @astrojs/prism ``` Then, you can import and use the `<Prism />` component like any other Astro component, passing a language and the code to render. ```astro --- import { Prism } from '@astrojs/prism'; --- <Prism lang="js" code={`const foo = 'bar';`} /> ``` In addition to the [list of languages supported by Prism](https://prismjs.com/#supported-languages), you can also use `lang="astro"` to display Astro code blocks. ## Add a Prism stylesheet [Section titled ‚ÄúAdd a Prism stylesheet‚Äù](#add-a-prism-stylesheet) If you opt to use Prism (either by configuring `markdown.syntaxHighlight: 'prism'` or with the `<Prism />` component), Astro will apply Prism‚Äôs CSS classes instead of Shiki‚Äôs to your code. You will need to bring your own CSS stylesheet for syntax highlighting to appear. 1. Choose a premade stylesheet from the available [Prism Themes](https://github.com/PrismJS/prism-themes). 2. Add this stylesheet to [your project‚Äôs `public/` directory](/en/basics/project-structure/#public). 3. Load this into your page‚Äôs `<head>` in a [layout component](/en/basics/layouts/) via a `<link>` tag. (See [Prism basic usage](https://prismjs.com/#basic-usage).) You can also visit the [list of languages supported by Prism](https://prismjs.com/#supported-languages) for options and usage.

# Troubleshooting

> Need help? Stuck on something? We've got you covered.

Astro provides several different tools to help you troubleshoot and debug your code. ## Tips and tricks [Section titled ‚ÄúTips and tricks‚Äù](#tips-and-tricks) ### Debugging with `console.log()` [Section titled ‚ÄúDebugging with console.log()‚Äù](#debugging-with-consolelog) `console.log()` is a simple-but-popular method of debugging your Astro code. Where you write your `console.log()` statement will determine where your debugging output is printed: ```astro --- console.log('Hi! I‚Äôm the server. This is logged in the terminal where Astro is running.'); --- <script> console.log('Hi! I‚Äôm the client. This is logged in browser dev console.'); </script> ``` A `console.log()` statement in Astro frontmatter will always output to the **terminal** running the Astro CLI. This is because Astro runs on the server, and never in the browser. Code that is written or imported inside of an Astro `<script>` tag is run in the browser. Any `console.log()` statements or other debug output will be printed to the **console in your browser**. ### Debugging framework components [Section titled ‚ÄúDebugging framework components‚Äù](#debugging-framework-components) [Framework components](/en/guides/framework-components/) (like React and Svelte) are unique: They render server-side by default, meaning that `console.log()` debug output will be visible in the terminal. However, they can also be hydrated for the browser, which may cause your debug logs to also appear in the browser. This can be useful for debugging differences between the server output and the hydrated components in the browser. ### Astro `<Debug />` component [Section titled ‚ÄúAstro \<Debug /> component‚Äù](#astro-debug--component) To help you debug your Astro components, Astro provides a built-in `<Debug />` component which renders any value directly into your component HTML template. This component provides a way to inspect values on the client-side, without any JavaScript. It can be useful for quick debugging in the browser without having to flip back-and-forth between your terminal and your browser. ```astro --- import { Debug } from 'astro:components'; const sum = (a, b) => a + b; --- <!-- Example: Outputs {answer: 6} to the browser --> <Debug answer={sum(2, 4)} /> ``` The Debug component supports a variety of syntax options for even more flexible and concise debugging: ```astro --- import { Debug } from 'astro:components'; const sum = (a, b) => a + b; const answer = sum(2, 4); --- <!-- Example: All three examples are equivalent. --> <Debug answer={sum(2, 4)} /> <Debug {{answer: sum(2, 4)}} /> <Debug {answer} /> ``` ## Common Error Messages [Section titled ‚ÄúCommon Error Messages‚Äù](#common-error-messages) Here are some common error messages you might see in the terminal, what they might mean, and what to do about them. See our [full error reference guide](/en/reference/error-reference/) for a complete list of Astro errors you may encounter. ### Cannot use import statement outside a module [Section titled ‚ÄúCannot use import statement outside a module‚Äù](#cannot-use-import-statement-outside-a-module) In Astro components, `<script>` tags are loaded as [JS modules](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules) by default. If you have included the [`is:inline` directive](/en/reference/directives-reference/#isinline) or any other attribute in your tag, this default behavior is removed. **Solution**: If you have added any attributes to your `<script>` tag, you must also add the `type="module"` attribute to be able to use import statements. **Status**: Expected Astro behavior, as intended. **Not sure that this is your problem?**\ Check to see if anyone else has reported [this issue](https://github.com/withastro/astro/issues?q=is%3Aissue+is%3Aopen+Cannot+use+import+statement)! ### `document` (or `window`) is not defined [Section titled ‚Äúdocument (or window) is not defined‚Äù](#document-or-window-is-not-defined) This error occurs when trying to access `document` or `window` on the server. Astro components run on the server, so you can‚Äôt access these browser-specific objects within the frontmatter. Framework components run on the server by default, so this error can occur when accessing `document` or `window` during rendering. **Solution**: Determine the code that calls `document` or `window`. If you aren‚Äôt using `document` or `window` directly and still getting this error, check to see if any packages you‚Äôre importing are meant to run on the client. * If the code is in an Astro component, move it to a `<script>` tag outside of the frontmatter. This tells Astro to run this code on the client, where `document` and `window` are available. * If the code is in a framework component, try to access these objects after rendering using lifecycle methods (e.g. [`useEffect()`](https://react.dev/reference/react/useEffect) in React, [`onMounted()`](https://vuejs.org/api/composition-api-lifecycle.html#onmounted) in Vue, and [`onMount()`](https://svelte.dev/docs#run-time-svelte-onmount) in Svelte). Tell the framework component to hydrate client-side by using a [client:](/en/reference/directives-reference/#client-directives) directive, like `client:load`, to run these lifecycle methods. You can also prevent the component from rendering on the server at all by adding the [`client:only`](/en/reference/directives-reference/#clientonly) directive. **Status**: Expected Astro behavior, as intended. ### Expected a default export [Section titled ‚ÄúExpected a default export‚Äù](#expected-a-default-export) This error can be thrown when trying to import or render an invalid component, or one that is not working properly. (This particular message occurs because of the way importing a UI component works in Astro.) **Solution**: Try looking for errors in any component you are importing and rendering, and make sure it‚Äôs working correctly. Consider opening an Astro starter template from [astro.new](https://astro.new) and troubleshooting just your component in a minimal Astro project. **Status**: Expected Astro behavior, as intended. ### Refused to execute inline script [Section titled ‚ÄúRefused to execute inline script‚Äù](#refused-to-execute-inline-script) You may see the following error logged in the browser console: > Refused to execute inline script because it violates the following Content Security Policy directive: ‚Ä¶ This means that your site‚Äôs [Content Security Policy](https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP) (CSP) disallows running inline `<script>` tags, which Astro outputs by default. **Solution:** Update your CSP to include `script-src: 'unsafe-inline'` to allow inline scripts to run. Alternatively, you can use a third-party integration such as [`astro-shield`](https://github.com/KindSpells/astro-shield) to generate the CSP headers for you. ## Common gotchas [Section titled ‚ÄúCommon gotchas‚Äù](#common-gotchas) ### My component is not rendering [Section titled ‚ÄúMy component is not rendering‚Äù](#my-component-is-not-rendering) First, check to see that you have **imported the component** in your [`.astro` component script](/en/basics/astro-components/#the-component-script) or [`.mdx` file](/en/guides/integrations-guide/mdx/#using-components-in-mdx). Then check your import statement: * Is your import linking to the wrong place? (Check your import path.) * Does your import have the same name as the imported component? (Check your component name and that it [follows the `.astro` syntax](/en/reference/astro-syntax/#differences-between-astro-and-jsx).) * Have you included the extension in the import? (Check that your imported file contains an extension. e.g. `.astro`, `.md`, `.vue`, `.svelte`. Note: File extensions are **not** required for `.js(x)` and `.ts(x)` files only.) ### My component is not interactive [Section titled ‚ÄúMy component is not interactive‚Äù](#my-component-is-not-interactive) If your component is rendering (see above) but is not responding to user interaction, then you may be missing a [`client:*` directive](/en/reference/directives-reference/#client-directives) to hydrate your component. By default, a [UI Framework component is not hydrated in the client](/en/guides/framework-components/#hydrating-interactive-components). If no `client:*` directive is provided, its HTML is rendered onto the page without JavaScript. ### Cannot find package ‚ÄòX‚Äô [Section titled ‚ÄúCannot find package ‚ÄòX‚Äô‚Äù](#cannot-find-package-x) If you see a `"Cannot find package 'react'"` (or similar) warning when you start up Astro, that means that you need to install that package into your project. Not all package managers will install peer dependencies for you automatically. If you are on Node v16+ and using npm, you should not need to worry about this section. React, for example, is a peer dependency of the `@astrojs/react` integration. That means that you should install the official `react` and `react-dom` packages alongside your integration. The integration will then pull from these packages automatically. ```shell # Example: Install integrations and frameworks together npm install @astrojs/react react react-dom ``` See [Astro‚Äôs integration guide](/en/guides/integrations-guide/) for instructions on adding framework renderers, CSS tools and other packages to Astro. ### Using Astro with Yarn 2+ (Berry) [Section titled ‚ÄúUsing Astro with Yarn 2+ (Berry)‚Äù](#using-astro-with-yarn-2-berry) Yarn 2+, a.k.a. Berry, uses a technique called [Plug‚Äôn‚ÄôPlay (PnP)](https://yarnpkg.com/features/pnp) to store and manage Node modules, which can [cause problems](https://github.com/withastro/astro/issues/3450) while initializing a new Astro project using `create astro` or while working with Astro. A workaround is to set the [`nodeLinker` property](https://yarnpkg.com/configuration/yarnrc#nodeLinker) in `.yarnrc.yml` to `node-modules`: .yarnrc.yml ```yaml nodeLinker: "node-modules" ``` ### Adding dependencies to Astro in a monorepo [Section titled ‚ÄúAdding dependencies to Astro in a monorepo‚Äù](#adding-dependencies-to-astro-in-a-monorepo) When working with Astro in a monorepo setup, project dependencies should be added in each project‚Äôs own `package.json` file. However, you may also want to use Astro in the root of the monorepo (e.g. [Nx projects recommend installing dependencies at the root](https://github.com/nrwl/nx/issues/3023#issuecomment-630558318)). In this case, manually add Astro-related dependencies (e.g. `@astrojs/vue`, `astro-component-lib`) to the `vite.ssr.noExternal` part of Astro‚Äôs config to ensure that these dependencies are properly installed and bundled: astro.config.mjs ```js import { defineConfig } from 'astro/config' export default defineConfig({ vite: { ssr: { noExternal: [ '@astrojs/vue', 'astro-component-lib', ] } } }) ``` ### Using `<head>` in a component [Section titled ‚ÄúUsing \<head> in a component‚Äù](#using-head-in-a-component) In Astro, using a `<head>` tag works like any other HTML tag: it does not get moved to the top of the page or merged with the existing `<head>`. Because of this, you usually only want to include one `<head>` tag throughout a page. We recommend writing that single `<head>` and its contents in a [layout component](/en/basics/layouts/). ### An unexpected `<style>` is included [Section titled ‚ÄúAn unexpected \<style> is included‚Äù](#an-unexpected-style-is-included) You may notice an imported component‚Äôs `<style>` tag included in your HTML source even if that component doesn‚Äôt appear in the final output. For example, this will occur with [conditionally rendered](/en/reference/astro-syntax/#dynamic-html) components that are not displayed. Astro‚Äôs build process works on the module graph: once a component is included in the template, its `<style>` tag is processed, optimized, and bundled, whether it appears in the final output or not. ### Escaping special characters in Markdown [Section titled ‚ÄúEscaping special characters in Markdown‚Äù](#escaping-special-characters-in-markdown) Certain characters have a special meaning in Markdown. You may need to use a different syntax if you want to display them. To do this, you can use [HTML entities](https://developer.mozilla.org/en-US/docs/Glossary/Entity) for these characters instead. For example, to prevent `<` being interpreted as the beginning of an HTML element, write `&lt;`. ## Creating minimal reproductions [Section titled ‚ÄúCreating minimal reproductions‚Äù](#creating-minimal-reproductions) When troubleshooting your code, it can be helpful to create a **minimal reproduction** of the issue that you can share. This is a smaller, simplified Astro project that demonstrates your issue. Having a working reproduction in a new project helps to confirm that this is a repeatable problem, and is not caused by something else in your personal environment or existing project. Sharing a minimal reproduction is helpful when asking for help in our support threads and is often required when filing a bug report to Astro. ### Create a StackBlitz via [astro.new](https://astro.new/repro) [Section titled ‚ÄúCreate a StackBlitz via astro.new‚Äù](#create-a-stackblitz-via-astronew) You can use [astro.new](https://astro.new/repro) to create a new Astro project with a single click. For minimal reproductions, we strongly recommend starting from the minimal (empty) example running in [StackBlitz](https://stackblitz.com), with as little extra code as possible. StackBlitz will run this Astro project in the browser, outside of your local environment. It will also provide you with a shareable link so that any Astro maintainer or support squad member can view your minimal reproduction outside of their own local environment. This means that everyone is viewing the exact same project, with the same configuration and dependencies. This makes it easy for someone else to help troubleshoot your code. If the issue is reproducible, it allows you to verify that the issue lies within the Astro code itself and you can feel confident submitting a bug report. Note that not every issue is reproducible in StackBlitz. For example, your issue might be dependent on a specific environment or package manager, or it may involve HTML Streaming, which isn‚Äôt supported in StackBlitz. In this case, create a new minimal (empty) Astro project using the CLI, reproduce the issue, and upload it to a GitHub repository. Instead of sharing a StackBlitz URL, provide a link to the GitHub repository of your minimal reproduction. ### Minimal code [Section titled ‚ÄúMinimal code‚Äù](#minimal-code) Once your empty project is set up, go through the steps to reproduce the issue. This can include adding packages, changing configuration, and writing code. You should only add the minimum amount of code necessary to reproduce the issue. Do not reproduce other elements of your existing project, and remove all code that is not directly related to the issue. ### Create an issue [Section titled ‚ÄúCreate an issue‚Äù](#create-an-issue) If your issue can be reproduced, then it is time to create an issue and file a bug report! Go to the appropriate Astro repository on GitHub and open a new issue. Most repositories have an issue template that will ask questions or require information in order to submit. It‚Äôs important that you follow these templates because if you don‚Äôt provide the information we need, then we have to ask you for it‚Ä¶ and no one is working on your issue! Include the link to your minimal reproduction on StackBlitz (or GitHub repository, if necessary). Start with a description of the expected versus actual behavior to provide context for the issue. Then, include clear, step-by-step instructions on how to replicate the issue in an Astro project. ## Need more? [Section titled ‚ÄúNeed more?‚Äù](#need-more) Come and chat with us on [Discord](https://astro.build/chat) and explain your issue in the `#support` forum channel. We‚Äôre always happy to help! Visit the current [open Issues in Astro](https://github.com/withastro/astro/issues/) to see if you are encountering a known problem or file a bug report. You can also visit [RFC Discussions](https://github.com/withastro/rfcs/discussions/) to see whether you‚Äôve found a known limitation of Astro, and check to see whether there are current proposals related to your use case.

# TypeScript

> Learn how to use Astro's built-in TypeScript support.

Astro ships with built-in support for [TypeScript](https://www.typescriptlang.org/). You can import `.ts` and `.tsx` files in your Astro project, write TypeScript code directly inside your [Astro component](/en/basics/astro-components/#the-component-script), and even use an [`astro.config.ts`](/en/guides/configuring-astro/#the-astro-config-file) file for your Astro configuration if you like. Using TypeScript, you can prevent errors at runtime by defining the shapes of objects and components in your code. For example, if you use TypeScript to [type your component‚Äôs props](#component-props), you‚Äôll get an error in your editor if you set a prop that your component doesn‚Äôt accept. You don‚Äôt need to write TypeScript code in your Astro projects to benefit from it. Astro always treats your component code as TypeScript, and the [Astro VS Code Extension](/en/editor-setup/) will infer as much as it can to provide autocompletion, hints, and errors in your editor. The Astro dev server won‚Äôt perform any type checking, but you can use a [separate script](#type-checking) to check for type errors from the command line. ## Setup [Section titled ‚ÄúSetup‚Äù](#setup) Astro starter projects include a `tsconfig.json` file in your project. Even if you don‚Äôt write TypeScript code, this file is important so that tools like Astro and VS Code know how to understand your project. Some features (like npm package imports) aren‚Äôt fully supported in the editor without a `tsconfig.json` file. If you install Astro manually, be sure to create this file yourself. ### TSConfig templates [Section titled ‚ÄúTSConfig templates‚Äù](#tsconfig-templates) Three extensible `tsconfig.json` templates are included in Astro: `base`, `strict`, and `strictest`. The `base` template enables support for modern JavaScript features and is also used as a basis for the other templates. We recommend using `strict` or `strictest` if you plan to write TypeScript in your project. You can view and compare the three template configurations at [astro/tsconfigs/](https://github.com/withastro/astro/blob/main/packages/astro/tsconfigs/). To inherit from one of the templates, use [the `extends` setting](https://www.typescriptlang.org/tsconfig#extends): tsconfig.json ```json { "extends": "astro/tsconfigs/base" } ``` Additionally, we recommend setting `include` and `exclude` as follows to benefit from Astro types and avoid checking built files: tsconfig.json ```diff { "extends": "astro/tsconfigs/base", +"include": [".astro/types.d.ts", "**/*"], +"exclude": ["dist"] } ``` ### TypeScript editor plugin [Section titled ‚ÄúTypeScript editor plugin‚Äù](#typescript-editor-plugin) The [Astro TypeScript plugin](https://www.npmjs.com/package/@astrojs/ts-plugin) can be installed separately when you are not using the [official Astro VS Code extension](https://marketplace.visualstudio.com/items?itemName=astro-build.astro-vscode). This plugin is automatically installed and configured by the VS Code extension, and you do not need to install both. This plugin runs only in the editor. When running `tsc` in the terminal, `.astro` files are ignored entirely. Instead, you can use [the `astro check` CLI command](/en/reference/cli-reference/#astro-check) to check both `.astro` and `.ts` files. This plugin also supports importing `.astro` files from `.ts` files (which can be useful for re-exporting). * npm ```shell npm install @astrojs/ts-plugin ``` * pnpm ```shell pnpm add @astrojs/ts-plugin ``` * Yarn ```shell yarn add @astrojs/ts-plugin ``` Then, add the following to your `tsconfig.json`: tsconfig.json ```json { "compilerOptions": { "plugins": [ { "name": "@astrojs/ts-plugin" }, ], } } ``` To check that the plugin is working, create a `.ts` file and import an Astro component into it. You should have no warning messages from your editor. ### UI Frameworks [Section titled ‚ÄúUI Frameworks‚Äù](#ui-frameworks) If your project uses a [UI framework](/en/guides/framework-components/), additional settings depending on the framework might be needed. Please see your framework‚Äôs TypeScript documentation for more information. ([Vue](https://vuejs.org/guide/typescript/overview.html#using-vue-with-typescript), [React](https://react-typescript-cheatsheet.netlify.app/docs/basic/setup), [Preact](https://preactjs.com/guide/v10/typescript), [Solid](https://www.solidjs.com/guides/typescript), [Svelte](https://svelte.dev/docs/svelte/typescript)) ## Type Imports [Section titled ‚ÄúType Imports‚Äù](#type-imports) Use explicit type imports and exports whenever possible. ```diff -import { SomeType } from "./script"; +import type { SomeType } from "./script"; ``` This way, you avoid edge cases where Astro‚Äôs bundler may try to incorrectly bundle your imported types as if they were JavaScript. You can configure TypeScript to enforce type imports in your `tsconfig.json` file. Set [`verbatimModuleSyntax`](https://www.typescriptlang.org/tsconfig#verbatimModuleSyntax) to `true`. TypeScript will check your imports and tell you when `import type` should be used. This setting is enabled by default in all our presets. tsconfig.json ```diff { "compilerOptions": { +"verbatimModuleSyntax": true } } ``` ## Import Aliases [Section titled ‚ÄúImport Aliases‚Äù](#import-aliases) Astro supports import aliases that you define in your `tsconfig.json` `paths` configuration. [Read our imports guide](/en/guides/imports/#aliases) to learn more. src/pages/about/nate.astro ```astro --- import HelloWorld from "@components/HelloWorld.astro"; import Layout from "@layouts/Layout.astro"; --- ``` tsconfig.json ```json { "compilerOptions": { "paths": { "@components/*": ["./src/components/*"], "@layouts/*": ["./src/layouts/*"] } } } ``` ## Extending global types [Section titled ‚ÄúExtending global types‚Äù](#extending-global-types) You can create `src/env.d.ts` as a convention for adding custom types declarations, or to benefit from Astro types if you don‚Äôt have a `tsconfig.json`: src/env.d.ts ```ts // Custom types declarations declare var myString: string; // Astro types, not necessary if you already have a `tsconfig.json` /// <reference path="../.astro/types.d.ts" /> ``` ### `window` and `globalThis` [Section titled ‚Äúwindow and globalThis‚Äù](#window-and-globalthis) You may want to add a property to the global object. You can do this by adding top-level declarations using the `declare` keyword to your `env.d.ts` file: src/env.d.ts ```ts declare var myString: string; declare function myFunction(): boolean; ``` This will provide typing to `globalThis.myString` and `globalThis.myFunction`, as well as `window.myString` and `window.myFunction`. Note that `window` is only available in client-side code. `globalThis` is available both server-side and client-side, but its server-side value won‚Äôt be shared with the client. If you only want to type a property on the `window` object, provide a `Window` interface instead: src/env.d.ts ```ts interface Window { myFunction(): boolean; } ``` ### Add non-standard attributes [Section titled ‚ÄúAdd non-standard attributes‚Äù](#add-non-standard-attributes) You may want to define a type for custom attributes or CSS properties. You can extend the default JSX definitions to add non-standard attributes by redeclaring the `astroHTML.JSX` namespace in a `.d.ts` file. src/env.d.ts ```ts declare namespace astroHTML.JSX { interface HTMLAttributes { "data-count"?: number; "data-label"?: string; } // Add a CSS custom property to the style object interface CSSProperties { "--theme-color"?: "black" | "white"; } } ``` ### Using imports [Section titled ‚ÄúUsing imports‚Äù](#using-imports) You may want to extend global types by reusing types declared elsewhere in your project or from an external library. To do this, use [dynamic imports](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/import): src/env.d.ts ```ts type Product = { id: string; name: string; price: number; }; declare namespace App { interface Locals { orders: Map<string, Product[]> session: import("./lib/server/session").Session | null; user: import("my-external-library").User; } } ``` A `.d.ts` file is an [ambient module](https://www.typescriptlang.org/docs/handbook/modules/reference.html#ambient-modules) declaration. While its syntax is similar to ES modules, these files do not allow top-level imports/exports. If Typescript encounters one, the file will be considered a [module augmentation](https://www.typescriptlang.org/docs/handbook/declaration-merging.html#module-augmentation) and this will break your global types. ## Component Props [Section titled ‚ÄúComponent Props‚Äù](#component-props) Astro supports typing your component props via TypeScript. To enable, add a TypeScript `Props` interface to your component frontmatter. An `export` statement may be used, but is not necessary. The [Astro VS Code Extension](/en/editor-setup/) will automatically look for the `Props` interface and give you proper TS support when you use that component inside another template. src/components/HelloProps.astro ```diff --- +interface Props { + name: string; + greeting?: string; +} const { greeting = "Hello", name } = Astro.props; --- <h2>{greeting}, {name}!</h2> ``` ### Common prop type patterns [Section titled ‚ÄúCommon prop type patterns‚Äù](#common-prop-type-patterns) * If your component takes no props or slotted content, you can use `type Props = Record<string, never>`. * If your component must be passed children to its default slot, you can enforce this by using `type Props = { children: any; };`. ## Type Utilities [Section titled ‚ÄúType Utilities‚Äù](#type-utilities) **Added in:** `astro@1.6.0` Astro comes with some built-in utility types for common prop type patterns. These are available under the `astro/types` entrypoint. ### Built-in HTML attributes [Section titled ‚ÄúBuilt-in HTML attributes‚Äù](#built-in-html-attributes) Astro provides the `HTMLAttributes` type to check that your markup is using valid HTML attributes. You can use these types to help build component props. For example, if you were building a `<Link>` component, you could do the following to mirror the default HTML attributes for `<a>` tags in your component‚Äôs prop types. src/components/Link.astro ```astro --- import type { HTMLAttributes } from "astro/types"; // use a `type` type Props = HTMLAttributes<"a">; // or extend with an `interface` interface Props extends HTMLAttributes<"a"> { myProp?: boolean; } const { href, ...attrs } = Astro.props; --- <a href={href} {...attrs}> <slot /> </a> ``` ### `ComponentProps` type [Section titled ‚ÄúComponentProps type‚Äù](#componentprops-type) **Added in:** `astro@4.3.0` This type export allows you to reference the `Props` accepted by another component, even if that component doesn‚Äôt export that `Props` type directly. The following example shows using the `ComponentProps` utility from `astro/types` to reference a `<Button />` component‚Äôs `Props` types: src/pages/index.astro ```astro --- import type { ComponentProps } from "astro/types"; import Button from "./Button.astro"; type ButtonProps = ComponentProps<typeof Button>; --- ``` ### Polymorphic type [Section titled ‚ÄúPolymorphic type‚Äù](#polymorphic-type) **Added in:** `astro@2.5.0` Astro includes a helper to make it easier to build components that can render as different HTML elements with full type safety. This is useful for components like `<Link>` that can render as either `<a>` or `<button>` depending on the props passed to it. The example below implements a fully-typed, polymorphic component that can render as any HTML element. The [`HTMLTag`](#built-in-html-attributes) type is used to ensure that the `as` prop is a valid HTML element. ```astro --- import type { HTMLTag, Polymorphic } from "astro/types"; type Props<Tag extends HTMLTag> = Polymorphic<{ as: Tag }>; const { as: Tag, ...props } = Astro.props; --- <Tag {...props} /> ``` ### Infer `getStaticPaths()` types [Section titled ‚ÄúInfer getStaticPaths() types‚Äù](#infer-getstaticpaths-types) **Added in:** `astro@2.1.0` Astro includes helpers for working with the types returned by your [`getStaticPaths()`](/en/reference/routing-reference/#getstaticpaths) function for dynamic routes. You can get the type of [`Astro.params`](/en/reference/api-reference/#params) with `InferGetStaticParamsType` and the type of [`Astro.props`](/en/reference/api-reference/#props) with `InferGetStaticPropsType` or you can use `GetStaticPaths` to infer both at once: src/pages/posts/\[...id].astro ```astro --- import type { InferGetStaticParamsType, InferGetStaticPropsType, GetStaticPaths, } from "astro"; export const getStaticPaths = (async () => { const posts = await getCollection("blog"); return posts.map((post) => { return { params: { id: post.id }, props: { draft: post.data.draft, title: post.data.title }, }; }); }) satisfies GetStaticPaths; type Params = InferGetStaticParamsType<typeof getStaticPaths>; type Props = InferGetStaticPropsType<typeof getStaticPaths>; const { id } = Astro.params as Params; // ^? { id: string; } const { title } = Astro.props; // ^? { draft: boolean; title: string; } --- ``` ## Type checking [Section titled ‚ÄúType checking‚Äù](#type-checking) To see type errors in your editor, please make sure that you have the [Astro VS Code extension](/en/editor-setup/) installed. Please note that the `astro start` and `astro build` commands will transpile the code with esbuild, but will not run any type checking. To prevent your code from building if it contains TypeScript errors, change your ‚Äúbuild‚Äù script in `package.json` to the following: package.json ```diff { "scripts": { -"build": "astro build", +"build": "astro check && astro build", }, } ``` Read more about [`.ts` file imports](/en/guides/imports/#typescript) in Astro. Read more about [TypeScript Configuration](https://www.typescriptlang.org/tsconfig/). ## Troubleshooting [Section titled ‚ÄúTroubleshooting‚Äù](#troubleshooting) ### Errors typing multiple JSX frameworks at the same time [Section titled ‚ÄúErrors typing multiple JSX frameworks at the same time‚Äù](#errors-typing-multiple-jsx-frameworks-at-the-same-time) An issue may arise when using multiple JSX frameworks in the same project, as each framework requires different, sometimes conflicting, settings inside `tsconfig.json`. **Solution**: Set the [`jsxImportSource` setting](https://www.typescriptlang.org/tsconfig#jsxImportSource) to `react` (default), `preact` or `solid-js` depending on your most-used framework. Then, use a [pragma comment](https://www.typescriptlang.org/docs/handbook/jsx.html#configuring-jsx) inside any conflicting file from a different framework. For the default setting of `jsxImportSource: react`, you would use: ```jsx // For Preact /** @jsxImportSource preact */ // For Solid /** @jsxImportSource solid-js */ ```

# Upgrade to Astro v5

> How to upgrade your project to Astro v5.0.

This guide will help you migrate from Astro v4 to Astro v5. Need to upgrade an older project to v4 first? See our [older migration guide](/en/guides/upgrade-to/v4/). Need to see the v4 docs? Visit this [older version of the docs site (unmaintained v4.16 snapshot)](https://v4.docs.astro.build/). ## Upgrade Astro [Section titled ‚ÄúUpgrade Astro‚Äù](#upgrade-astro) Update your project‚Äôs version of Astro to the latest version using your package manager: * npm ```shell # Upgrade Astro and official integrations together npx @astrojs/upgrade ``` * pnpm ```shell # Upgrade Astro and official integrations together pnpm dlx @astrojs/upgrade ``` * Yarn ```shell # Upgrade Astro and official integrations together yarn dlx @astrojs/upgrade ``` You can also [upgrade your Astro integrations manually](/en/guides/integrations-guide/#manual-upgrading) if needed, and you may also need to upgrade other dependencies in your project. Astro v5.0 includes [potentially breaking changes](#breaking-changes), as well as the removal and deprecation of some features. If your project doesn‚Äôt work as expected after upgrading to v5.0, check this guide for an overview of all breaking changes and instructions on how to update your codebase. See [the Astro changelog](https://github.com/withastro/astro/blob/main/packages/astro/CHANGELOG.md) for full release notes. ## Dependency Upgrades [Section titled ‚ÄúDependency Upgrades‚Äù](#dependency-upgrades) Any major upgrades to Astro‚Äôs dependencies may cause breaking changes in your project. ### Vite 6.0 [Section titled ‚ÄúVite 6.0‚Äù](#vite-60) Astro v5.0 upgrades to Vite v6.0 as the development server and production bundler. #### What should I do? [Section titled ‚ÄúWhat should I do?‚Äù](#what-should-i-do) If you are using Vite-specific plugins, configuration, or APIs, check the [Vite migration guide](https://vite.dev/guide/migration.html) for their breaking changes and upgrade your project as needed. ### `@astrojs/mdx` [Section titled ‚Äú@astrojs/mdx‚Äù](#astrojsmdx) [Implementation PR: Cleanup unused JSX code (#11741)](https://github.com/withastro/astro/pull/11741) In Astro v4.x, Astro performed internal JSX handling for the `@astrojs/mdx` integration. Astro v5.0 moves this responsibility to handle and render JSX and MDX to the `@astrojs/mdx` package directly. This means that Astro 5.0 is no longer compatible with older versions of the MDX integration. #### What should I do? [Section titled ‚ÄúWhat should I do?‚Äù](#what-should-i-do-1) If your project includes `.mdx` files, you must upgrade `@astrojs/mdx` to the latest version (v4.0.0) so that your JSX can be handled properly by the integration. If you are using an MDX server renderer with the experimental [Astro Container API](/en/reference/container-reference/) you must update the import to reflect the new location: ```diff -import mdxRenderer from "astro/jsx/server.js"; +import mdxRenderer from "@astrojs/mdx/server.js"; ``` Learn more about [using MDX in your project](/en/guides/integrations-guide/mdx/). ## Legacy [Section titled ‚ÄúLegacy‚Äù](#legacy) The following features are now considered legacy features. They should function normally but are no longer recommended and are in maintenance mode. They will see no future improvements and documentation will not be updated. These features will eventually be deprecated, and then removed entirely. ### Legacy: v2.0 Content Collections API [Section titled ‚ÄúLegacy: v2.0 Content Collections API‚Äù](#legacy-v20-content-collections-api) In Astro 4.x, content collections were defined, queried, and rendered using [the Content Collections API first introduced in Astro v2.0](https://astro.build/blog/introducing-content-collections/). All collection entries were local files within the reserved `src/content/` folder. Additionally, Astro‚Äôs [file name convention to exclude building individual pages](/en/guides/routing/#excluding-pages) was built in to the Content Collections API. Astro 5.0 introduces a new version of content collections using the Content Layer API which brings several performance improvements and added capabilities. While old (legacy) and new (Content Layer API) collections can continue exist together in this release, there are potentially breaking changes to existing legacy collections. This release also removes the option to prefix collection entry file names with an underscore (`_`) to prevent building a route. #### What should I do? [Section titled ‚ÄúWhat should I do?‚Äù](#what-should-i-do-2) We recommend [converting any existing collections to the new Content Layer API](#updating-existing-collections) as soon as you are able and making any new collections using the Content Layer API. If you are unable to convert your collections, then please consult the [legacy collections breaking changes](#breaking-changes-to-legacy-content-and-data-collections) to see whether your existing collections are affected and require updating. If you are unable to make any changes to your collections at this time, you can [enable the `legacy.collections` flag](#enabling-the-legacycollections-flag) which will allow you to keep your collections in their current state until the legacy flag is no longer supported. Learn more about the updated [content collections](/en/guides/content-collections/). ##### Updating existing collections [Section titled ‚ÄúUpdating existing collections‚Äù](#updating-existing-collections) See the instructions below for updating an existing content collection (`type: 'content'` or `type: 'data'`) to use the Content Layer API. ##### Breaking changes to legacy `content` and `data` collections [Section titled ‚ÄúBreaking changes to legacy content and data collections‚Äù](#breaking-changes-to-legacy-content-and-data-collections) [Implementation PR: Implement legacy collections using glob (#11976)](https://github.com/withastro/astro/pull/11976) By default, collections that use the old `type` property (`content` or `data`) and do not define a `loader` are now implemented under the hood using the Content Layer API‚Äôs built-in `glob()` loader, with extra backward-compatibility handling. Additionally, temporary backwards compatibility exists for keeping the content config file in its original location of `src/content/config.ts`. This backwards compatibility implementation is able to emulate most of the features of legacy collections and will allow many legacy collections to continue to work even without updating your code. However, **there are some differences and limitations that may cause breaking changes to existing collections**: * In previous versions of Astro, collections would be generated for all folders in `src/content/`, even if they were not defined in `src/content/config.ts`. This behavior is now deprecated, and collections should always be defined in `src/content.config.ts`. For existing collections, these can just be empty declarations (e.g. `const blog = defineCollection({})`) and Astro will implicitly define your legacy collection for you in a way that is compatible with the new loading behavior. * The special `layout` field is not supported in Markdown collection entries. This property is intended only for standalone page files located in `src/pages/` and not likely to be in your collection entries. However, if you were using this property, you must now create dynamic routes that include your page styling. * Sort order of generated collections is non-deterministic and platform-dependent. This means that if you are calling `getCollection()`, the order in which entries are returned may be different than before. If you need a specific order, you must sort the collection entries yourself. * `image().refine()` is not supported. If you need to validate the properties of an image you will need to do this at runtime in your page or component. * The `key` argument of `getEntry(collection, key)` is typed as `string`, rather than having types for every entry. * Previously when calling `getEntry(collection, key)` with a static string as the key, the return type was not nullable. The type now includes `undefined` so you must check if the entry is defined before using the result or you will have type errors. ##### Enabling the `legacy.collections` flag [Section titled ‚ÄúEnabling the legacy.collections flag‚Äù](#enabling-the-legacycollections-flag) [Implementation PR: Implement legacy collections using glob (#11976)](https://github.com/withastro/astro/pull/11976) If you are not yet ready to update your existing collections, you can enable the [`legacy.collections`](/en/reference/legacy-flags/) flag and your existing collections will continue to function as before. ## Deprecated [Section titled ‚ÄúDeprecated‚Äù](#deprecated) The following deprecated features are no longer supported and are no longer documented. Please update your project accordingly. Some deprecated features may temporarily continue to function until they are completely removed. Others may silently have no effect, or throw an error prompting you to update your code. ### Deprecated: `Astro.glob()` [Section titled ‚ÄúDeprecated: Astro.glob()‚Äù](#deprecated-astroglob) [Implementation PR: Deprecate glob (#11826)](https://github.com/withastro/astro/pull/11826) In Astro v4.x, you could use `Astro.glob()` in your `.astro` components to query multiple files in your project. This had some limitations (where it could be used, performance, etc.), and using querying functions from the Content Collections API or Vite‚Äôs own `import.meta.glob()` often provided more function and flexibility. Astro 5.0 deprecates `Astro.glob()` in favor of using `getCollection()` to query your collections, and `import.meta.glob()` to query other source files in your project. #### What should I do? [Section titled ‚ÄúWhat should I do?‚Äù](#what-should-i-do-3) Replace all use of `Astro.glob()` with `import.meta.glob()`. Note that `import.meta.glob()` no longer returns a `Promise`, so you may have to update your code accordingly. You should not require any updates to your [glob patterns](/en/guides/imports/#glob-patterns). src/pages/blog.astro ```diff --- -const posts = await Astro.glob('./posts/*.md'); +const posts = Object.values(import.meta.glob('./posts/*.md', { eager: true })); --- {posts.map((post) => <li><a href={post.url}>{post.frontmatter.title}</a></li>)} ``` Where appropriate, consider using [content collections](/en/guides/content-collections/) to organize your content, which has its own newer, more performant querying functions. You may also wish to consider using glob packages from NPM, such as [`fast-glob`](https://www.npmjs.com/package/fast-glob). Learn more about [importing files with `import.meta.glob`](/en/guides/imports/#importmetaglob). ### Deprecated: `functionPerRoute` (Adapter API) [Section titled ‚ÄúDeprecated: functionPerRoute (Adapter API)‚Äù](#deprecated-functionperroute-adapter-api) [Implementation PR: Remove functionPerRoute option (#11714)](https://github.com/withastro/astro/pull/11714) In Astro v4.x, you could opt into creating a separate file for each route defined in the project, mirroring your `src/pages/` directory in the build folder. By default, Astro emitted a single `entry.mjs` file, which was responsible for emitting the rendered page on each request. Astro v5.0 removes the option to opt out of the default behavior. This behavior is now standard, and non-configurable. Remove the `functionPerRoute` property from your `adapterFeatures` configuration. It is no longer available. my-adapter.mjs ```diff export default function createIntegration() { return { name: '@matthewp/my-adapter', hooks: { 'astro:config:done': ({ setAdapter }) => { setAdapter({ name: '@matthewp/my-adapter', serverEntrypoint: '@matthewp/my-adapter/server.js', adapterFeatures: { - functionPerRoute: true } }); }, }, }; } ``` Learn more about [the Adapter API](/en/reference/adapter-reference/) for building adapter integrations. ### Deprecated: `routes` on `astro:build:done` hook (Integration API) [Section titled ‚ÄúDeprecated: routes on astro:build:done hook (Integration API)‚Äù](#deprecated-routes-on-astrobuilddone-hook-integration-api) [Implementation PR: feat(next): astro:routes:resolved (#12329)](https://github.com/withastro/astro/pull/12329) In Astro v4.x, integrations accessed routes from the `astro:build:done` hook. Astro v5.0 deprecates the `routes` array passed to this hook. Instead, it exposes a new `astro:routes:resolved` hook that runs before `astro:config:done`, and whenever a route changes in development. It has all the same properties of the deprecated `routes` list, except `distURL` which is only available during build. #### What should I do? [Section titled ‚ÄúWhat should I do?‚Äù](#what-should-i-do-4) Remove any instance of `routes` passed to `astro:build:done` and replace it with the new `astro:routes:resolved` hook. Access `distURL` on the newly exposed `assets` map: my-integration.mjs ```diff const integration = () => { let routes return { name: 'my-integration', hooks: { +'astro:routes:resolved': (params) => { +routes = params.routes }, 'astro:build:done': ({ -routes +assets }) => { for (const route of routes) { const distURL = assets.get(route.pattern) if (distURL) { +Object.assign(route, { distURL }) } } console.log(routes) } } } } ``` Learn more about [the Integration API `astro:routes:resolved` hook](/en/reference/integrations-reference/#astroroutesresolved) for building integrations. ## Removed [Section titled ‚ÄúRemoved‚Äù](#removed) The following features have now been entirely removed from the code base and can no longer be used. Some of these features may have continued to work in your project even after deprecation. Others may have silently had no effect. Projects now containing these removed features will be unable to build, and there will no longer be any supporting documentation prompting you to remove these features. ### Removed: The Lit integration [Section titled ‚ÄúRemoved: The Lit integration‚Äù](#removed-the-lit-integration) [Implementation PR: Remove \`@astrojs/lit\` (#11680)](https://github.com/withastro/astro/pull/11680) In Astro v4.x, [Lit](https://lit.dev/) was a core-maintained framework library through the `@astrojs/lit` package. Astro v5.0 removes the integration and it will not receive further updates for compatibility with 5.x and above. #### What should I do? [Section titled ‚ÄúWhat should I do?‚Äù](#what-should-i-do-5) You can continue to use Lit for client components by adding a client-side script tag. For example: ```astro <script> import "../components/MyTabs"; </script> <my-tabs title="These are my tabs">...</my-tabs> ``` If you‚Äôre interested in maintaining a Lit integration yourself, you may wish to use the [last published version of `@astrojs/lit`](https://github.com/withastro/astro/tree/astro%404.13.0/packages/integrations/lit) as a starting point and upgrade the relevant packages. Learn more about [Astro‚Äôs official integrations](/en/guides/integrations-guide/). ### Removed: `hybrid` rendering mode [Section titled ‚ÄúRemoved: hybrid rendering mode‚Äù](#removed-hybrid-rendering-mode) [Implementation PR: Merge output:hybrid and output:static (#11824)](https://github.com/withastro/astro/pull/11824) In Astro v4.x, Astro provided three rendering `output` rendering modes: `'static'`, `'hybrid'`, and `'server'` Astro v5.0 merges the `output: 'hybrid'` and `output: 'static'` configurations into one single configuration (now called `'static'`) that works the same way as the previous hybrid option. It is no longer necessary to specify `output: 'hybrid'` in your Astro config to use server-rendered pages. The new `output: 'static'` has this capability included. Astro will now automatically allow you to opt out of prerendering in your static site with no change to your output configuration required. Any page route or endpoint can include `export const prerender = false` to be server-rendered on demand, while the rest of your site is statically generated. #### What should I do? [Section titled ‚ÄúWhat should I do?‚Äù](#what-should-i-do-6) If your project used hybrid rendering, you must now remove the `output: 'hybrid'` option from your Astro config as it no longer exists. However, no other changes to your project are required, and you should have no breaking changes. The previous `'hybrid'` behavior is now the default, under a new name `'static'`. astro.config.mjs ```diff import { defineConfig } from "astro/config"; export default defineConfig({ - output: 'hybrid', }); ``` If you were using the `output: 'static'` (default) option, you can continue to use it as before. By default, all of your pages will continue to be prerendered and you will have a completely static site. You should have no breaking changes to your project. An adapter is still required to deploy an Astro project with any server-rendered pages, no matter which `output` mode your project uses. Failure to include an adapter will result in a warning in development and an error at build time. Learn more about [on-demand rendering in Astro](/en/guides/on-demand-rendering/). ### Removed: support for dynamic `prerender` values in routes [Section titled ‚ÄúRemoved: support for dynamic prerender values in routes‚Äù](#removed-support-for-dynamic-prerender-values-in-routes) [Implementation PR: Merge output:hybrid and output:static (#11824)](https://github.com/withastro/astro/pull/11824) In Astro 4.x, environment variables could be used to dynamically set the value of `prerender` exports in routes, for example `export const prerender = import.meta.env.SOME_VAR`. Astro v5.0 removes support for dynamic values in `prerender` exports. Only the static values `true` and `false` are supported. #### What should I do? [Section titled ‚ÄúWhat should I do?‚Äù](#what-should-i-do-7) 1. Remove any dynamic `prerender` exports in your routes: src/pages/blog/\[slug].astro ```diff --- -export const prerender = import.meta.env.SOME_VAR; --- ``` 2. Use an Astro integration in your `astro.config.mjs` file to set `prerender` values that need to be dynamic in the `"astro:route:setup"` hook: astro.config.mjs ```js import { defineConfig } from 'astro/config'; import { loadEnv } from 'vite'; export default defineConfig({ integrations: [ { name: 'set-prerender', hooks: { 'astro:route:setup': ({ route }) => { // Load environment variables from .env files (if needed) const { PRERENDER } = loadEnv(process.env.NODE_ENV, process.cwd(), ''); // Find routes matching the expected filename. if (route.component.endsWith('/blog/[slug].astro')) { // Set the prerender value on routes as needed. route.prerender = PRERENDER; } }, }, } ], }); ``` ### Removed: Squoosh image service [Section titled ‚ÄúRemoved: Squoosh image service‚Äù](#removed-squoosh-image-service) [Implementation PR: remove the squoosh image service (#11770)](https://github.com/withastro/astro/pull/11770) In Astro 4.x, you could configure `image.service: squooshImageService()` to use Squoosh to transform your images instead of Sharp. However, the underlying library `libsquoosh` is no longer maintained and has memory and performance issues. Astro 5.0 removes the Squoosh image optimization service entirely. #### What should I do? [Section titled ‚ÄúWhat should I do?‚Äù](#what-should-i-do-8) To switch to the built-in Sharp image service, remove the `squooshImageService` import from your Astro config. By default, you will use Sharp for `astro:assets`. astro.config.mjs ```diff -import { squooshImageService } from "astro/config"; import { defineConfig } from "astro/config"; export default defineConfig({ - image: { - service: squooshImageService() - } }); ``` If you are using a strict package manager like `pnpm`, you may need to install the `sharp` package manually to use the Sharp image service, even though it is built into Astro by default. If your adapter does not support Astro‚Äôs built-in Sharp image optimization, you can [configure a no-op image service](/en/guides/images/#configure-no-op-passthrough-service) to allow you to use the `<Image />` and `<Picture />` components. Alternatively, you may wish to consider [a community-maintained Squoosh image service](https://github.com/Princesseuh/astro-image-service-squoosh) if you are unable to use the Sharp image service. ##### For adapters [Section titled ‚ÄúFor adapters‚Äù](#for-adapters) If your adapter previously precised its compatibility status with Squoosh, you should now remove this information from your adapter configuration. my-adapter.mjs ```diff supportedAstroFeatures: { - assets: { - isSquooshCompatible: true - } } ``` Read more about [configuring your default image service](/en/guides/images/#default-image-service). ### Removed: some public-facing types [Section titled ‚ÄúRemoved: some public-facing types‚Äù](#removed-some-public-facing-types) [Implementation PR: Refactor/types (#11715)](https://github.com/withastro/astro/pull/11715) In Astro v4.x, `@types/astro.ts` exposed all types publicly to users, whether or not they were still actively used or only intended for internal use. Astro v5.0 refactors this file to remove outdated and internal types. This refactor brings improvements to your editor (e.g. faster completions, lower memory usage, and more relevant completion options). However, this refactor may cause errors in some projects that have been relying on types that are no longer available to the public. #### What should I do? [Section titled ‚ÄúWhat should I do?‚Äù](#what-should-i-do-9) Remove any types that now cause errors in your project as you no longer have access to them. These are mostly APIs that have previously been deprecated and removed, but may also include types that are now internal. See the [public types exposed for use](https://github.com/withastro/astro/tree/main/packages/astro/src/types/public). ### Experimental Flags [Section titled ‚ÄúExperimental Flags‚Äù](#experimental-flags) The following experimental flags have been removed in Astro v5.0 and these features are available for use: * `env` * `serverIslands` Additionally, the following experimental flags have been removed and **are now the default or recommended behavior in Astro v5.0**. * `directRenderScript` (See below for breaking changes to [default `<script>` behavior](#script-tags-are-rendered-directly-as-declared).) * `globalRoutePriority` (See below for breaking changes to [default route priority order](#route-priority-order-for-injected-routes-and-redirects).) * `contentLayer` (See guidance for [upgrading existing content collections](#legacy-v20-content-collections-api) to the new, preferred Content Layer API.) The following experimental flags have been removed and **their corresponding features are not part of Astro v5.0**. * `contentCollectionsCache` Remove these experimental flags if you were previously using them, and move your `env` configuration to the root of your Astro config: astro.config.mjs ```diff import { defineConfig } from 'astro/config'; export default defineConfig({ experimental: { - directRenderScript: true, - globalRoutePriority: true, - contentLayer: true, - serverIslands: true, - contentCollectionsCache: true, - env: { - schema: {...} - } }, + env: { + schema: {...} + } }) ``` These features are all available by default in Astro v5.0. Read about these exciting features and more in [the v5.0 Blog post](https://astro.build/blog/astro-5/). ## Changed Defaults [Section titled ‚ÄúChanged Defaults‚Äù](#changed-defaults) Some default behavior has changed in Astro v5.0 and your project code may need updating to account for these changes. In most cases, the only action needed is to review your existing project‚Äôs deployment and ensure that it continues to function as you expect, making updates to your code as necessary. In some cases, there may be a configuration setting to allow you to continue to use the previous default behavior. ### CSRF protection is now set by default [Section titled ‚ÄúCSRF protection is now set by default‚Äù](#csrf-protection-is-now-set-by-default) [Implementation PR: change default value of checkOrigin (#11788)](https://github.com/withastro/astro/pull/11788) In Astro v4.x, The default value of `security.checkOrigin` was `false`. Previously, you had to explicitly set this value to `true` to enable Cross-Site Request Forgery (CSRF) protection. Astro v5.0 changes the default value of this option to `true`, and will automatically check that the ‚Äúorigin‚Äù header matches the URL sent by each request in on-demand rendered pages. #### What should I do? [Section titled ‚ÄúWhat should I do?‚Äù](#what-should-i-do-10) If you had previously configured `security.checkOrigin: true`, you no longer need this line in your Astro config. This is now the default. To disable this behavior, you must explicitly set `security.checkOrigin: false`. astro.config.mjs ```diff export default defineConfig({ output: "server", + security: { + checkOrigin: false + } }) ``` Read more about [security configuration options](/en/reference/configuration-reference/#security) ### Route priority order for injected routes and redirects [Section titled ‚ÄúRoute priority order for injected routes and redirects‚Äù](#route-priority-order-for-injected-routes-and-redirects) [Implementation PR: Remove legacy route prioritization (#11798)](https://github.com/withastro/astro/pull/11798) In Astro v4.x, `experimental.globalRoutePriority` was an optional flag that ensured that injected routes, file-based routes, and redirects were all prioritized using the [route priority order rules for all routes](/en/guides/routing/#route-priority-order). This allowed more control over routing in your project by not automatically prioritizing certain kinds of routes and standardizing the route priority order. Astro v5.0 removes this experimental flag and makes this the new default behavior in Astro: redirects and injected routes are now prioritized equally alongside file-based project routes. Note that this was already the default behavior in Starlight, and should not affect updated Starlight projects. #### What should I do? [Section titled ‚ÄúWhat should I do?‚Äù](#what-should-i-do-11) If your project includes injected routes or redirects, please check that your routes are building page URLs as expected. An example of the new expected behavior is shown below. In a project containing the following routes: * File-based route: `/blog/post/[pid]` * File-based route: `/[page]` * Injected route: `/blog/[...slug]` * Redirect: `/blog/tags/[tag] -> /[tag]` * Redirect: `/posts -> /blog` The following URLs will be built (instead of following the route priority order of Astro v4.x): * `/blog/tags/astro` is built by the redirect to `/tags/[tag]` (instead of the injected route `/blog/[...slug]`) * `/blog/post/0` is built by the file-based route `/blog/post/[pid]` (instead of the injected route `/blog/[...slug]`) * `/posts` is built by the redirect to `/blog` (instead of the file-based route `/[page]`) In the event of route collisions, where two routes of equal route priority attempt to build the same URL, Astro will log a warning identifying the conflicting routes. Read more about the [route priority order rules](/en/guides/routing/#route-priority-order). ### `<script>` tags are rendered directly as declared [Section titled ‚Äú\<script> tags are rendered directly as declared‚Äù](#script-tags-are-rendered-directly-as-declared) [Implementation PR: Make directRenderScript the default (#11791)](https://github.com/withastro/astro/pull/11791) In Astro v4.x, `experimental.directRenderScript` was an optional flag to directly render `<scripts>` as declared in `.astro` files (including existing features like TypeScript, importing `node_modules`, and deduplicating scripts). This strategy prevented scripts from being executed in places where they were not used. Additionally, conditionally rendered scripts were previously implicitly inlined, as if an `is:inline` directive was automatically added to them. Astro 5.0 removes this experimental flag and makes this the new default behavior in Astro: scripts are no longer hoisted to the `<head>`, multiple scripts on a page are no longer bundled together, and a `<script>` tag may interfere with CSS styling. Additionally, conditionally rendered scripts are no longer implicitly inlined. #### What should I do? [Section titled ‚ÄúWhat should I do?‚Äù](#what-should-i-do-12) Please review your `<script>` tags and ensure they behave as desired. If you previously had conditionally rendered `<script>` tags, you will need to add an `is:inline` attribute to preserve the same behavior as before: src/components/MyComponent.astro ```astro --- type Props = { showAlert: boolean } const { showAlert } = Astro.props; --- { showAlert && <script is:inline>alert("Some very important code!!")</script> } ``` Read more about [using `script` tags in Astro](/en/guides/client-side-scripts/). ## Breaking Changes [Section titled ‚ÄúBreaking Changes‚Äù](#breaking-changes) The following changes are considered breaking changes in Astro v5.0. Breaking changes may or may not provide temporary backwards compatibility. If you were using these features, you may have to update your code as recommended in each entry. ### Renamed: `<ViewTransitions />` component [Section titled ‚ÄúRenamed: \<ViewTransitions /> component‚Äù](#renamed-viewtransitions--component) [Implementation PR: Rename the ViewTransitions component to ClientRouter (#11980)](https://github.com/withastro/astro/pull/11980) In Astro 4.x, Astro‚Äôs View Transitions API included a `<ViewTransitions />` router component to enable client-side routing, page transitions, and more. Astro 5.0 renames this component to `<ClientRouter />` to clarify the role of the component within the API. This makes it more clear that the features you get from Astro‚Äôs `<ClientRouter />` routing component are slightly different from the native CSS-based MPA router. No functionality has changed. This component has only changed its name. #### What should I do? [Section titled ‚ÄúWhat should I do?‚Äù](#what-should-i-do-13) Replace all occurrences of the `ViewTransitions` import and component with `ClientRouter`: src/layouts/MyLayout.astro ```diff -import { ViewTransitions } from 'astro:transitions'; +import { ClientRouter } from 'astro:transitions'; <html> <head> ... -<ViewTransitions /> +<ClientRouter /> </head> </html> ``` Read more about [view transitions and client-side routing in Astro](/en/guides/view-transitions/). ### Changed: TypeScript configuration [Section titled ‚ÄúChanged: TypeScript configuration‚Äù](#changed-typescript-configuration) [Implementation PR: better tsconfig (#11859)](https://github.com/withastro/astro/pull/11859) In Astro v4.x, Astro relied on a `src/env.d.ts` file for type inferencing and defining modules for features that relied on generated types. Astro 5.0 instead uses a `.astro/types.d.ts` file for type inferencing, and now recommends setting `include` and `exclude` in `tsconfig.json` to benefit from Astro types and avoid checking built files. Running `astro sync` no longer creates, nor updates, `src/env.d.ts` as it is not required for type-checking standard Astro projects. #### What should I do? [Section titled ‚ÄúWhat should I do?‚Äù](#what-should-i-do-14) To update your project to Astro‚Äôs recommended TypeScript settings, add the following `include` and `exclude` properties to your existing `tsconfig.json`: tsconfig.json ```diff { "extends": "astro/tsconfigs/base", +"include": [".astro/types.d.ts", "**/*"], +"exclude": ["dist"] } ``` Note that `src/env.d.ts` is only necessary if you have added custom configurations, or if you‚Äôre not using a `tsconfig.json` file. Read more about [TypeScript configuration in Astro](/en/guides/typescript/#setup). ### Changed: Actions submitted by HTML forms no longer use cookie redirects [Section titled ‚ÄúChanged: Actions submitted by HTML forms no longer use cookie redirects‚Äù](#changed-actions-submitted-by-html-forms-no-longer-use-cookie-redirects) [Implementation PR: Actions middleware (#12373)](https://github.com/withastro/astro/pull/12373) In Astro 4.x, actions called from an HTML form would trigger a redirect with the result forwarded using cookies. This caused issues for large form errors and return values that exceeded the 4 KB limit of cookie-based storage. Astro 5.0 now renders the result of an action as a POST result without any forwarding. This will introduce a ‚Äúconfirm form resubmission?‚Äù dialog when a user attempts to refresh the page, though it no longer imposes a 4 KB limit on action return value. #### What should I do? [Section titled ‚ÄúWhat should I do?‚Äù](#what-should-i-do-15) You should update handling for action results that relies on redirects, and optionally address the ‚Äúconfirm form resubmission?‚Äù dialog with middleware. ##### To redirect to the previous route on error [Section titled ‚ÄúTo redirect to the previous route on error‚Äù](#to-redirect-to-the-previous-route-on-error) If your HTML form action is directed to a different route (i.e. `action={"/success-page" + actions.name}`), Astro will no longer redirect to the previous route on error. You can implement this behavior manually using redirects from your Astro component. This example instead redirects to a new route on success, and handles errors on the current page otherwise: src/pages/newsletter.astro ```diff --- import { actions } from 'astro:actions'; +const result = Astro.getActionResult(actions.newsletter); +if (!result?.error) { +// Embed relevant result data in the URL if needed +// example: redirect(`/confirmation?email=${result.data.email}`); +return redirect('/confirmation'); +} --- <form method="POST" action={'/confirmation' + actions.newsletter}> <label>E-mail <input required type="email" name="email" /></label> <button>Sign up</button> </form> ``` ##### (Optional) To remove the confirm dialog on refresh [Section titled ‚Äú(Optional) To remove the confirm dialog on refresh‚Äù](#optional-to-remove-the-confirm-dialog-on-refresh) To address the ‚Äúconfirm form resubmission?‚Äù dialog on refresh, or to preserve action results across sessions, you can now [customize action result handling from middleware](/en/guides/actions/#advanced-persist-action-results-with-a-session). We recommend using a session storage provider [as described in our Netlify Blob example](/en/guides/actions/#advanced-persist-action-results-with-a-session). However, if you prefer the cookie forwarding behavior from 4.X and accept the 4 KB size limit, you can implement the pattern as shown in this sample snippet: src/middleware.ts ```ts import { defineMiddleware } from 'astro:middleware'; import { getActionContext } from 'astro:actions'; export const onRequest = defineMiddleware(async (context, next) => { // Skip requests for prerendered pages if (context.isPrerendered) return next(); const { action, setActionResult, serializeActionResult } = getActionContext(context); // If an action result was forwarded as a cookie, set the result // to be accessible from `Astro.getActionResult()` const payload = context.cookies.get('ACTION_PAYLOAD'); if (payload) { const { actionName, actionResult } = payload.json(); setActionResult(actionName, actionResult); context.cookies.delete('ACTION_PAYLOAD', { path: '/' }); return next(); } // If an action was called from an HTML form action, // call the action handler and redirect with the result as a cookie. if (action?.calledFrom === 'form') { const actionResult = await action.handler(); context.cookies.set('ACTION_PAYLOAD', { actionName: action.name, actionResult: serializeActionResult(actionResult), }, { path: '/', httpOnly: true, sameSite: 'lax', maxAge: 60 }); if (actionResult.error) { // Redirect back to the previous page on error const referer = context.request.headers.get('Referer'); if (!referer) { throw new Error('Internal: Referer unexpectedly missing from Action POST request.'); } return context.redirect(referer); } // Redirect to the destination page on success return context.redirect(context.originPathname); } return next(); }) ``` ### Changed: `compiledContent()` is now an async function [Section titled ‚ÄúChanged: compiledContent() is now an async function‚Äù](#changed-compiledcontent-is-now-an-async-function) [Implementation PR: Remove TLA by making compiledContent async (#11782)](https://github.com/withastro/astro/pull/11782) In Astro 4.x, top level await was included in Markdown modules. This caused some issues with custom image services and images inside Markdown, causing Node to suddenly exit with no error message. Astro 5.0 makes the `compiledContent()` property on Markdown import an async function, requiring an `await` to resolve the content. #### What should I do? [Section titled ‚ÄúWhat should I do?‚Äù](#what-should-i-do-16) Update your code to use `await` when calling `compiledContent()`. src/pages/post.astro ```diff --- import * as myPost from "../blog/post.md"; -const content = myPost.compiledContent(); +const content = await myPost.compiledContent(); --- <Fragment set:html={content} /> ``` Read more about the [`compiledContent()` function](/en/guides/markdown-content/#importing-markdown) for returning compiled Markdown. ### Changed: `astro:content` can no longer be used on the client [Section titled ‚ÄúChanged: astro:content can no longer be used on the client‚Äù](#changed-astrocontent-can-no-longer-be-used-on-the-client) [Implementation PR: Prevent usage of \`astro:content\` in the client (#11827)](https://github.com/withastro/astro/pull/11827) In Astro 4.x, it was possible to access the `astro:content` module on the client. Astro 5.0 removes this access as it was never intentionally exposed for client use. Using `astro:content` this way had limitations and bloated client bundles. #### What should I do? [Section titled ‚ÄúWhat should I do?‚Äù](#what-should-i-do-17) If you are currently using `astro:content` in the client, pass the data you need through props to your client components instead: src/pages/blog.astro ```astro --- import { getCollection } from 'astro:content'; import ClientComponent from '../components/ClientComponent'; const posts = await getCollection('blog'); const postsData = posts.map(post => post.data); --- <ClientComponent posts={postsData} /> ``` Read more about [the `astro:content` API](/en/reference/modules/astro-content/). ### Renamed: Shiki `css-variables` theme color token names [Section titled ‚ÄúRenamed: Shiki css-variables theme color token names‚Äù](#renamed-shiki-css-variables-theme-color-token-names) [Implementation PR: Update to new shiki token names (#11661)](https://github.com/withastro/astro/pull/11661) In Astro v4.x, the Shiki `css-variables` theme used the `--astro-code-color-text` and `--astro-code-color-background` tokens for styling the foreground and background colors of code blocks respectively. Astro v5.0 renames them to `--astro-code-foreground` and `--astro-code-background` respectively to better align with the Shiki v1 defaults. #### What should I do? [Section titled ‚ÄúWhat should I do?‚Äù](#what-should-i-do-18) You can perform a global find and replace in your project to migrate to the new token names. src/styles/global.css ```diff :root { ---astro-code-color-text: #000; ---astro-code-color-background: #fff; +--astro-code-foreground: #000; +--astro-code-background: #fff; } ``` Read more about [syntax highlighting in Astro](/en/guides/syntax-highlighting/). ### Changed: internal Shiki rehype plugin for highlighting code blocks [Section titled ‚ÄúChanged: internal Shiki rehype plugin for highlighting code blocks‚Äù](#changed-internal-shiki-rehype-plugin-for-highlighting-code-blocks) [Implementation PR: Refactor createShikiHighlighter (#11825)](https://github.com/withastro/astro/pull/11825) In Astro 4.x, Astro‚Äôs internal Shiki rehype plugin highlighted code blocks as HTML. Astro 5.0 updates this plugin to highlight code blocks as hast. This allows a more direct Markdown and MDX processing and improves the performance when building the project. However, this may cause issues with existing Shiki transformers. #### What should I do? [Section titled ‚ÄúWhat should I do?‚Äù](#what-should-i-do-19) If you are using Shiki transformers passed to `markdown.shikiConfig.transformers`, you must make sure they do not use the `postprocess` hook. This hook no longer runs on code blocks in `.md` and `.mdx` files. (See [the Shiki documentation on transformer hooks](https://shiki.style/guide/transformers#transformer-hooks) for more information). Code blocks in `.mdoc` files and Astro‚Äôs built-in `<Code />` component do not use the internal Shiki rehype plugin and are unaffected. Read more about [syntax highlighting in Astro](/en/guides/syntax-highlighting/). ### Changed: Automatic `charset=utf-8` behavior for Markdown and MDX pages [Section titled ‚ÄúChanged: Automatic charset=utf-8 behavior for Markdown and MDX pages‚Äù](#changed-automatic-charsetutf-8-behavior-for-markdown-and-mdx-pages) [Implementation PR: Unset charset=utf-8 content-type for md/mdx pages (#12231)](https://github.com/withastro/astro/pull/12231) In Astro 4.0, Markdown and MDX pages (located in `src/pages/`) automatically responded with `charset=utf-8` in the `Content-Type` header, which allowed rendering non-ASCII characters in your pages. Astro 5.0 updates the behaviour to add the `<meta charset="utf-8">` tag instead, and only for pages that do not use Astro‚Äôs special `layout` frontmatter property. Similarly for MDX pages, Astro will only add the tag if the MDX content does not import a wrapping `Layout` component. If your Markdown or MDX pages use the `layout` frontmatter property, or if the MDX page content imports a wrapping `Layout` component, then the HTML encoding will be handled by the designated layout component instead, and the `<meta charset="utf-8">` tag will not be added to your page by default. #### What should I do? [Section titled ‚ÄúWhat should I do?‚Äù](#what-should-i-do-20) If you require `charset=utf-8` to render your page correctly, make sure that your layout components contain the `<meta charset="utf-8">` tag. You may need to add this if you have not already done so. Read more about [Markdown layouts](/en/basics/layouts/#markdown-layouts). ### Changed: Astro-specific metadata attached in remark and rehype plugins [Section titled ‚ÄúChanged: Astro-specific metadata attached in remark and rehype plugins‚Äù](#changed-astro-specific-metadata-attached-in-remark-and-rehype-plugins) [Implementation PR: Clean up Astro metadata in vfile.data (#11861)](https://github.com/withastro/astro/pull/11861) In Astro 4.x, the Astro-specific metadata attached to `vfile.data` in remark and rehype plugins was attached in different locations with inconsistent names. Astro 5 cleans up the API and the metadata is now renamed as below: * `vfile.data.__astroHeadings` -> `vfile.data.astro.headings` * `vfile.data.imagePaths` -> `vfile.data.astro.imagePaths` The types of `imagePaths` has also been updated from `Set<string>` to `string[]`. The `vfile.data.astro.frontmatter` metadata is left unchanged. #### What should I do? [Section titled ‚ÄúWhat should I do?‚Äù](#what-should-i-do-21) While we don‚Äôt consider these APIs public, they can be accessed by remark and rehype plugins that want to re-use Astro‚Äôs metadata. If you are using these APIs, make sure to access them in the new locations. Read more about [using Markdown plugins in Astro](/en/guides/markdown-content/#markdown-plugins). ### Changed: image endpoint configuration [Section titled ‚ÄúChanged: image endpoint configuration‚Äù](#changed-image-endpoint-configuration) [Implementation PR: Allow customising the route of the image endpoint (#11908)](https://github.com/withastro/astro/pull/11908) In Astro 4.x, you could set an endpoint in your `image` configuration to use for image optimization. Astro 5.0 allows you to customize a `route` and `entrypoint` of the `image.endpoint` config. This can be useful in niche situations where the default route `/_image` conflicts with an existing route or your local server setup. #### What should I do? [Section titled ‚ÄúWhat should I do?‚Äù](#what-should-i-do-22) If you had previously customized `image.endpoint`, move this endpoint to the new `endpoint.entrypoint` property. Optionally, you may customize a `route`: astro.config.mjs ```diff import { defineConfig } from "astro/config"; defineConfig({ image: { - endpoint: './src/image-endpoint.ts', + endpoint: { + route: "/image", + entrypoint: "./src/image_endpoint.ts" + } }, }) ``` Read more about [setting an endpoint to use for image optimization](/en/reference/configuration-reference/#imageendpoint). ### Changed: `build.client` and `build.server` resolve behavior [Section titled ‚ÄúChanged: build.client and build.server resolve behavior‚Äù](#changed-buildclient-and-buildserver-resolve-behavior) [Implementation PR: Fix build.client and build.server resolve behaviour (#11916)](https://github.com/withastro/astro/pull/11916) In Astro v4.x, the `build.client` and `build.server` options were documented to resolve relatively from the `outDir` option, but it didn‚Äôt always work as expected. Astro 5.0 fixes the behavior to correctly resolve from the `outDir` option. For example, if `outDir` is set to `./dist/nested/`, then by default: * `build.client` will resolve to `<root>/dist/nested/client/` * `build.server` will resolve to `<root>/dist/nested/server/` Previously the values were incorrectly resolved: * `build.client` was resolved to `<root>/dist/nested/dist/client/` * `build.server` was resolved to `<root>/dist/nested/dist/server/` #### What should I do? [Section titled ‚ÄúWhat should I do?‚Äù](#what-should-i-do-23) If you were relying on the previous build paths, make sure that your project code is updated to the new build paths. Read more about [`build` configuration options in Astro](/en/reference/configuration-reference/#build-options). ### Changed: JS dependencies in config file are no longer processed by Vite [Section titled ‚ÄúChanged: JS dependencies in config file are no longer processed by Vite‚Äù](#changed-js-dependencies-in-config-file-are-no-longer-processed-by-vite) [Implementation PR: Set external: true when loading astro config (#11819)](https://github.com/withastro/astro/pull/11819) In Astro 4.x, locally-linked JS dependencies (e.g. `npm link`, in a monorepo, etc) were able to use Vite features like `import.meta.glob` when imported by the Astro config file. Astro 5 updates the Astro config loading flow to ignore processing locally-linked JS dependencies with Vite. Dependencies exporting raw TypeScript files are unaffected. Instead, these JS dependencies will be normally imported by the Node.js runtime the same way as other dependencies from `node_modules`. This change was made as the previous behavior caused confusion among integration authors who tested against a package that worked locally, but not when published. It also restricted using CJS-only dependencies because Vite required the code to be ESM. While this change only affects JS dependencies, it‚Äôs also recommended for packages to export JavaScript instead of raw TypeScript where possible to prevent accidental Vite-specific usage as it‚Äôs an implementation detail of Astro‚Äôs config loading flow. #### What should I do? [Section titled ‚ÄúWhat should I do?‚Äù](#what-should-i-do-24) Make sure your locally-linked JS dependencies are built before running your Astro project. Then, the config loading should work as before. Read more about [Vite configuration settings in Astro](/en/reference/configuration-reference/#vite). ### Changed: URLs returned by `paginate()` [Section titled ‚ÄúChanged: URLs returned by paginate()‚Äù](#changed-urls-returned-by-paginate) [Implementation PR: Add base to paginate (#11253)](https://github.com/withastro/astro/pull/11253) In Astro v4.x, the URL returned by `paginate()` (e.g. `page.url.next`, `page.url.first`, etc.) did not include the value set for `base` in your Astro config. You had to manually prepend your configured value for `base` to the URL path. Astro 5.0 automatically includes the `base` value in `page.url`. #### What should I do? [Section titled ‚ÄúWhat should I do?‚Äù](#what-should-i-do-25) If you are using the `paginate()` function for these URLs, remove any existing `base` value as it is now added for you: ```diff --- export async function getStaticPaths({ paginate }) { const astronautPages = [{ astronaut: 'Neil Armstrong', }, { astronaut: 'Buzz Aldrin', }, { astronaut: 'Sally Ride', }, { astronaut: 'John Glenn', }]; return paginate(astronautPages, { pageSize: 1 }); } const { page } = Astro.props; // `base: /'docs'` configured in `astro.config.mjs` -const prev = "/docs" + page.url.prev; +const prev = page.url.prev; --- <a id="prev" href={prev}>Back</a> ``` Read more about [pagination in Astro](/en/guides/routing/#pagination). ### Changed: non-boolean HTML attribute values [Section titled ‚ÄúChanged: non-boolean HTML attribute values‚Äù](#changed-non-boolean-html-attribute-values) [Implementation PR: Fix attribute rendering for boolean values (take 2) (#11660)](https://github.com/withastro/astro/pull/11660) In Astro v4.x, non-[boolean HTML attributes](https://developer.mozilla.org/en-US/docs/Glossary/Boolean/HTML) may not have included their values when rendered to HTML. Astro v5.0 renders the values explicitly as `="true"` or `="false"`, matching proper attribute handling in browsers. In the following `.astro` examples, only `allowfullscreen` is a boolean attribute: src/pages/index.astro ```astro <!-- `allowfullscreen` is a boolean attribute --> <p allowfullscreen={true}></p> <p allowfullscreen={false}></p> <!-- `inherit` is *not* a boolean attribute --> <p inherit={true}></p> <p inherit={false}></p> <!-- `data-*` attributes are not boolean attributes --> <p data-light={true}></p> <p data-light={false}></p> ``` Astro v5.0 now preserves the full data attribute with its value when rendering the HTML of non-boolean attributes: ```diff <p allowfullscreen></p> <p></p> <p inherit="true"></p> <p inherit></p> <p inherit="false"></p> <p data-light></p> <p data-light="true"></p> <p></p> <p data-light="false"></p> ``` #### What should I do? [Section titled ‚ÄúWhat should I do?‚Äù](#what-should-i-do-26) If you rely on attribute values, for example, to locate elements or to conditionally render, update your code to match the new non-boolean attribute values: ```diff -el.getAttribute('inherit') === '' +el.getAttribute('inherit') === 'false' -el.hasAttribute('data-light') +el.dataset.light === 'true' ``` Read more about [using HTML attributes in Astro](/en/reference/astro-syntax/#dynamic-attributes). ### Changed: adding values to `context.locals` [Section titled ‚ÄúChanged: adding values to context.locals‚Äù](#changed-adding-values-to-contextlocals) [Implementation PR: TODOs (#11987)](https://github.com/withastro/astro/pull/11987) In Astro 4.x, it was possible to completely replace the entire `locals` object in middleware, API endpoints, and pages when adding new values. Astro 5.0 requires you to append values to the existing `locals` object without deleting it. Locals in middleware, API endpoints, and pages, can no longer be completely overridden. #### What should I do? [Section titled ‚ÄúWhat should I do?‚Äù](#what-should-i-do-27) Where you previously were overwriting the object, you must now instead assign values to it: src/middleware.js ```diff -ctx.locals = { Object.assign(ctx.locals, { one: 1, two: 2 -} +}) ``` See more about [storing data in `context.locals`](/en/guides/middleware/#storing-data-in-contextlocals). ### Changed: `params` no longer decoded [Section titled ‚ÄúChanged: params no longer decoded‚Äù](#changed-params-no-longer-decoded) [Implementation PR: decode pathname early, don't decode params (#12079)](https://github.com/withastro/astro/pull/12079) In Astro v4.x, `params` passed to `getStaticPath()` were automatically decoded using `decodeURIComponent`. Astro v5.0 no longer decodes the value of `params` passed to `getStaticPaths`. You must manually decode them yourself if needed. #### What should I do? [Section titled ‚ÄúWhat should I do?‚Äù](#what-should-i-do-28) If you were previously relying on the automatic decoding, use `decodeURI` when passing `params`. src/pages/\[id].astro ```diff --- export function getStaticPaths() { return [ - { params: { id: "%5Bpage%5D" } }, + { params: { id: decodeURI("%5Bpage%5D") } }, ] } const { id } = Astro.params; --- ``` Note that the use of [`decodeURIComponent`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/decodeURIComponent) is discouraged for `getStaticPaths` because it decodes more characters than it should, for example `/`, `?`, `#` and more. Read more about [creating dynamic routes with `params`](/en/guides/routing/#static-ssg-mode). ### Changed: `RouteData` type replaced by `IntegrationsRouteData` (Integrations API) [Section titled ‚ÄúChanged: RouteData type replaced by IntegrationsRouteData (Integrations API)‚Äù](#changed-routedata-type-replaced-by-integrationsroutedata-integrations-api) [Implementation PR: send \`IntegrationRouteData\` to integrations (#11864)](https://github.com/withastro/astro/pull/11864) In Astro v4.x, the `entryPoints` type inside the `astro:build:ssr` and `astro:build:done` hooks was `RouteData`. Astro v5.0 the `entryPoints` type is now `IntegrationRouteData`, which contains a subset of the `RouteData` type. The fields `isIndex` and `fallbackRoutes` were removed. #### What should I do? [Section titled ‚ÄúWhat should I do?‚Äù](#what-should-i-do-29) Update your adapter to change the type of `entryPoints` from `RouteData` to `IntegrationRouteData`. ```diff -import type {RouteData} from 'astro'; +import type {IntegrationRouteData} from "astro" -function useRoute(route: RouteData) { +function useRoute(route: IntegrationRouteData) { } ``` See the [API reference for `IntegrationRouteData`](/en/reference/integrations-reference/#integrationroutedata). ### Changed: `distURL` is now an array (Integrations API) [Section titled ‚ÄúChanged: distURL is now an array (Integrations API)‚Äù](#changed-disturl-is-now-an-array-integrations-api) [Implementation PR: send \`IntegrationRouteData\` to integrations (#11864)](https://github.com/withastro/astro/pull/11864) In Astro v4.x, `RouteData.distURL` was `undefined` or a `URL`. Astro v5.0 updates the shape of `IntegrationRouteData.distURL` to be `undefined` or an array of `URL`s. This fixes a previous error because a route can generate multiple files on disk, especially when using dynamic routes such as `[slug]` or `[...slug]`. #### What should I do? [Section titled ‚ÄúWhat should I do?‚Äù](#what-should-i-do-30) Update your code to handle `IntegrationRouteData.distURL` as an array. ```diff if (route.distURL) { -if (route.distURL.endsWith('index.html')) { -// do something - } +for (const url of route.distURL) { +if (url.endsWith('index.html')) { +// do something + } + } } ``` See the [API reference for `IntegrationRouteData`](/en/reference/integrations-reference/#integrationroutedata). ### Changed: Arguments passed to `app.render()` (Adapter API) [Section titled ‚ÄúChanged: Arguments passed to app.render() (Adapter API)‚Äù](#changed-arguments-passed-to-apprender-adapter-api) [Implementation PR: TODOs (#11987)](https://github.com/withastro/astro/pull/11987) In Astro 4.x, The Adapter API method `app.render()` could receive three arguments: a mandatory `request`, an object of options or a `routeData` object, and `locals`. Astro 5.0 combines these last two arguments into a single options argument named `renderOptions`. #### What should I do? [Section titled ‚ÄúWhat should I do?‚Äù](#what-should-i-do-31) Pass an object as the second argument to `app.render()`, which can include `routeData` and `locals` as properties. ```diff -const response = await app.render(request, routeData, locals); +const response = await app.render(request, {routeData, locals}); ``` See the [Adapter API reference for `renderOptions`](/en/reference/adapter-reference/#renderoptions). ### Changed: Properties on `supportedAstroFeatures` (Adapter API) [Section titled ‚ÄúChanged: Properties on supportedAstroFeatures (Adapter API)‚Äù](#changed-properties-on-supportedastrofeatures-adapter-api) [Implementation PR: rework supportedAstroFeatures (#11806)](https://github.com/withastro/astro/pull/11806) In Astro 4.x, `supportedAstroFeatures`, which allows adapter authors to specify which features their integration supports, included an `assets` property to specify which of Astro‚Äôs image services were supported. Astro 5.0 replaces this property with a dedicated `sharpImageService` property, used to determine whether the adapter is compatible with the built-in sharp image service. v5.0 also adds a new `limited` value for the different properties of `supportedAstroFeatures` for adapters, which indicates that the adapter is compatible with the feature, but with some limitations. This is useful for adapters that support a feature, but not in all cases or with all options. Additionally, the value of the different properties on `supportedAstroFeatures` for adapters can now be objects, with `support` and `message` properties. The content of the `message` property will show a helpful message in the Astro CLI when the adapter is not compatible with a feature. This is notably useful with the new `limited` value, to explain to the user why support is limited. #### What should I do? [Section titled ‚ÄúWhat should I do?‚Äù](#what-should-i-do-32) If you were using the `assets` property, remove this as it is no longer available. To specify that your adapter supports the built-in sharp image service, replace this with `sharpImageService`. You may also wish to update your supported features with the new `limited` option and include a message about your adapter‚Äôs support. my-adapter.mjs ```diff supportedAstroFeatures: { - assets: { - supportKind: "stable", - isSharpCompatible: true, - isSquooshCompatible: true, - }, + sharpImageService: { + support: "limited", + message: 'This adapter supports the built-in sharp image service, but with some limitations.' + } } ``` Read more about [specifying supported Astro features in an adapter](/en/reference/adapter-reference/#astro-features). ### Removed: Deprecated definition shape for dev toolbar apps (Dev Toolbar API) [Section titled ‚ÄúRemoved: Deprecated definition shape for dev toolbar apps (Dev Toolbar API)‚Äù](#removed-deprecated-definition-shape-for-dev-toolbar-apps-dev-toolbar-api) [Implementation PR: Remove deprecated dev toolbar app shape (#11987)](https://github.com/withastro/astro/pull/11987) In Astro 4.x, when building a dev toolbar app, it was still possible to use the previously deprecated `addDevToolbarApp(string);` signature. The `id`, `title`, and `icon` properties to define the app were then made available through the default export of the app‚Äôs `entrypoint`. Astro 5.0 completely removes this option entirely in favor of the current object shape when defining a dev toolbar app in an integration that‚Äôs more intuitive and allows Astro to provide better errors when toolbar apps fail to load correctly. #### What should I do? [Section titled ‚ÄúWhat should I do?‚Äù](#what-should-i-do-33) If you were using the deprecated shape, update your dev toolbar app to use the new shape: my-integration.mjs ```diff -// Old shape -addDevToolbarApp("./my-dev-toolbar-app.mjs"); +// New shape +addDevToolbarApp({ + id: "my-app", + name: "My App", + icon: "<svg>...</svg>", + entrypoint: "./my-dev-toolbar-app.mjs", +}); ``` my-dev-toolbar-app.mjs ```diff export default { - id: 'my-dev-toolbar-app', - title: 'My Dev Toolbar App', - icon: 'üöÄ', init() { // ... } } ``` Read more about [developing a dev toolbar app for Astro using the Dev Toolbar API](/en/reference/dev-toolbar-app-reference/). ### Removed: configuring Typescript during `create-astro` [Section titled ‚ÄúRemoved: configuring Typescript during create-astro‚Äù](#removed-configuring-typescript-during-create-astro) [Implementation PR: create-astro updates (#12083)](https://github.com/withastro/astro/pull/12083) In Astro v4.x, it was possible to choose between Astro‚Äôs three TypeScript settings when creating a new project using `create astro`, either by answering a question or by passing an associated `--typescript` flag with the desired TypeScript setting. Astro 5.0 updates the `create astro` CLI command to remove the TypeScript question and its associated `--typescript` flag. The ‚Äústrict‚Äù preset is now the default for all new projects created with the command line and it is no longer possible to customize this at that time. However, the TypeScript template can still be changed manually in `tsconfig.json`. #### What should I do? [Section titled ‚ÄúWhat should I do?‚Äù](#what-should-i-do-34) If you were using the `--typescript` flag with `create-astro`, remove it from your command. * npm ```diff -npm create astro@latest -- --template <example-name> --typescript strict +npm create astro@latest -- --template <example-name> ``` * pnpm ```diff -pnpm create astro@latest --template <example-name> --typescript strict +pnpm create astro@latest --template <example-name> ``` * Yarn ```diff -yarn create astro --template <example-name> --typescript strict +yarn create astro --template <example-name> ``` See [all the available `create astro` command flags](https://github.com/withastro/astro/blob/main/packages/create-astro/README.md) ## Community Resources [Section titled ‚ÄúCommunity Resources‚Äù](#community-resources) Know a good resource for Astro v5.0? [Edit this page](https://github.com/withastro/docs/edit/main/src/content/docs/en/guides/upgrade-to/v5.mdx) and add a link below! ## Known Issues [Section titled ‚ÄúKnown Issues‚Äù](#known-issues) Please check [Astro‚Äôs issues on GitHub](https://github.com/withastro/astro/issues/) for any reported issues, or to file an issue yourself.

# View transitions

> Enable seamless navigation between pages in Astro with view transitions.

[View transitions](https://developer.mozilla.org/en-US/docs/Web/API/View_Transition_API) are animated transitions between different website views. They are a popular design choice for preserving visual continuity as visitors move between states or views of an application. Astro‚Äôs view transitions and client-side routing support is powered by the [View Transitions browser API](https://developer.chrome.com/docs/web-platform/view-transitions/) and also includes: * A few [built-in animation options](#built-in-animation-directives), such as `fade`, `slide`, and `none`. * Support for both forwards and backwards navigation animations. * The ability to fully [customize all aspects of transition animation](#customizing-animations), and build your own animations. * A way to carry HTML elements from the current page to the next during navigation. * The option to [prevent client-side navigation for non-page links](#preventing-client-side-navigation). * [Control over fallback behavior](#fallback-control) for browsers that do not yet support the View Transition APIs. * Automatic support for [`prefers-reduced-motion`](#prefers-reduced-motion). ## Differences between browser-native view transitions and Astro‚Äôs `<ClientRouter />` [Section titled ‚ÄúDifferences between browser-native view transitions and Astro‚Äôs \<ClientRouter />‚Äù](#differences-between-browser-native-view-transitions-and-astros-clientrouter-) [Browser-native, cross-document view transitions](https://developer.mozilla.org/en-US/docs/Web/API/View_Transition_API/Using#basic_mpa_view_transition) can be used in Astro to animate the navigation between documents in a multi-page app (MPA), often providing the experience of client-side routing of single-page applications. They don‚Äôt alter the core functionality of a multi-page application, nor do they affect any existing scripts or add additional JavaScript to your page load. They simply add animations. For enhanced client-side routing and view transition features not yet fully supported by the View Transition API, Astro provides a built-in, lightweight component to enable client-side routing and turn your multi-page app into a [single-page app](#enabling-view-transitions-spa-mode) with smooth animations on navigation. That comes with some benefits, like shared state across pages and persistent elements, and some drawbacks, such as needing to manually reinitialize scripts or state after navigation. Adding Astro‚Äôs built-in `<ClientRouter />` component: * [intercepts page navigation](#client-side-navigation-process) and gives you considerable control over this process. * extends and enhances some View Transition/Navigation API features. * allows you to [configure fallback strategies](#fallback-control) for when [native browser support is lacking](https://developer.mozilla.org/en-US/docs/Web/API/View_Transition_API#browser_compatibility). However, as browser APIs and web standards evolve, using Astro‚Äôs `<ClientRouter />` for this additional functionality [will increasingly become unnecessary](https://astro.build/blog/future-of-astro-zero-js-view-transitions/). We recommend keeping up with the current state of browser APIs so you can [decide whether you still need Astro‚Äôs client-side routing](https://events-3bg.pages.dev/jotter/astro-view-transitions/) for the specific features you use. ## Enabling view transitions (SPA mode) [Section titled ‚ÄúEnabling view transitions (SPA mode)‚Äù](#enabling-view-transitions-spa-mode) Import and add the `<ClientRouter />` component to your common `<head>` or shared layout component. Astro will create default page animations based on the similarities between the old and new page, and will also provide fallback behavior for unsupported browsers. The example below shows adding Astro‚Äôs default page navigation animations site-wide, including the default fallback control option for non-supporting browsers, by importing and adding this component to a `<CommonHead />` Astro component: src/components/CommonHead.astro ```diff --- +import { ClientRouter } from "astro:transitions"; --- <link rel="icon" type="image/svg+xml" href="/favicon.svg" /> <meta name="generator" content={Astro.generator} /> <!-- Primary Meta Tags --> <title>{title}</title> <meta name="title" content={title} /> <meta name="description" content={description} /> +<ClientRouter /> ``` No other configuration is necessary to enable Astro‚Äôs default client-side navigation! Use [transition directives](#transition-directives) or [override default client-side navigation](#preventing-client-side-navigation) on individual elements for finer control. ## Transition Directives [Section titled ‚ÄúTransition Directives‚Äù](#transition-directives) Astro will automatically assign corresponding elements found in both the old page and the new page a shared, unique `view-transition-name`. This pair of matching elements is inferred by both the type of element and its location in the DOM. Use optional `transition:*` directives on page elements in your `.astro` components for finer control over the page transition behaviour during navigation. * `transition:name`: Allows you to override Astro‚Äôs default element matching for old/new content animation and [specify a transition name](#naming-a-transition) to associate a pair of DOM elements. * `transition:animate`: Allows you to override Astro‚Äôs default animation while replacing the old element with the new one by specifying an animation type. Use Astro‚Äôs [built-in animation directives](#built-in-animation-directives) or [create custom transition animations](#customizing-animations). * `transition:persist`: Allows you to override Astro‚Äôs default replacing old elements for new ones and instead [persist components and HTML elements](#maintaining-state) when navigating to another page. ### Naming a transition [Section titled ‚ÄúNaming a transition‚Äù](#naming-a-transition) In some cases, you may want or need to identify the corresponding view transition elements yourself. You can specify a name for a pair of elements using the `transition:name` directive. src/pages/old-page.astro ```astro <aside transition:name="hero"> ``` src/pages/new-page.astro ```astro <aside transition:name="hero"> ``` Note that the provided `transition:name` value can only be used once on each page. Set this manually when Astro can‚Äôt infer a proper name itself, or for more fine control over matching elements. ### Maintaining State [Section titled ‚ÄúMaintaining State‚Äù](#maintaining-state) **Added in:** `astro@2.10.0` You can persist components and HTML elements (instead of replacing them) across page navigations using the `transition:persist` directive. For example, the following `<video>` will continue to play as you navigate to another page that contains the same video element. This works for both forwards and backwards navigation. src/components/Video.astro ```astro <video controls muted autoplay transition:persist> <source src="https://ia804502.us.archive.org/33/items/GoldenGa1939_3/GoldenGa1939_3_512kb.mp4" type="video/mp4" /> </video> ``` You can also place the directive on an [Astro island](/en/concepts/islands/) (a UI framework component with a [`client:` directive](/en/reference/directives-reference/#client-directives)). If that component exists on the next page, the island from the old page **with its current state** will continue to be displayed, instead of replacing it with the island from the new page. In the example below, the component‚Äôs internal state of the count will not be reset when navigating back and forth across pages that contain the `<Counter />` component with the `transition:persist` attribute. components/Header.astro ```astro <Counter client:load transition:persist initialCount={5} /> ``` You can also [manually identify corresponding elements](#naming-a-transition) if the island/element is in a different component between the two pages. src/pages/old-page.astro ```astro <video controls muted autoplay transition:name="media-player" transition:persist /> ``` src/pages/new-page.astro ```astro <MyVideo controls muted autoplay transition:name="media-player" transition:persist /> ``` As a convenient shorthand, `transition:persist` can alternatively take a transition name as a value. src/pages/index.astro ```astro <video controls muted autoplay transition:persist="media-player"> ``` #### `transition:persist-props` [Section titled ‚Äútransition:persist-props‚Äù](#transitionpersist-props) **Added in:** `astro@4.5.0` This allows you to control whether or not an island‚Äôs props should be persisted upon navigation. By default, when you add `transition:persist` to an island, the state is retained upon navigation, but your component will re-render with new props. This is useful, for example, when a component receives page-specific props such as the current page‚Äôs `title`. You can override this behavior by setting `transition:persist-props` in addition to `transition:persist`. Adding this directive will keep an island‚Äôs existing props (not re-render with new values) in addition to maintaining its existing state. ### Built-in Animation Directives [Section titled ‚ÄúBuilt-in Animation Directives‚Äù](#built-in-animation-directives) Astro comes with a few built-in animations to override the default `fade` transition. Add the `transition:animate` directive to individual elements to customize the behavior of specific transitions. * `fade` (default): An opinionated crossfade animation. The old content fades out and the new content fades in. * `initial`: Opt out of Astro‚Äôs opinionated crossfade animation and use the browser‚Äôs default styling. * `slide`: An animation where the old content slides out to the left and new content slides in from the right. On backwards navigation, the animations are the opposite. * `none`: Disable the browser‚Äôs default animations. Use on a page‚Äôs `<html>` element to disable the default fade for every element on the page. Combine directives for full control over your page animation. Set a page default on the `<html>` element, and override on any individual elements as desired. The example below produces a slide animation for the body content while disabling the browser‚Äôs default fade animation for the rest of the page: ```astro --- import CommonHead from "../components/CommonHead.astro"; --- <html transition:name="root" transition:animate="none"> <head> <CommonHead /> </head> <body> <header> ... </header> <!-- Override your page default on a single element --> <main transition:animate="slide"> ... </main> </body> </html> ``` ### Customizing Animations [Section titled ‚ÄúCustomizing Animations‚Äù](#customizing-animations) You can customize all aspects of a transition with any CSS animation properties. To customize a built-in animation, first import the animation from `astro:transitions`, and then pass in customization options. The example below customizes the duration of the built-in `fade` animation: ```astro --- import { fade } from "astro:transitions"; --- <header transition:animate={fade({ duration: "0.4s" })}> ``` You can also define your own animations for use with `transition:animate` by defining both the forwards and backwards behavior, as well as new and old pages, according to the following types: ```ts export interface TransitionAnimation { name: string; // The name of the keyframe delay?: number | string; duration?: number | string; easing?: string; fillMode?: string; direction?: string; } export interface TransitionAnimationPair { old: TransitionAnimation | TransitionAnimation[]; new: TransitionAnimation | TransitionAnimation[]; } export interface TransitionDirectionalAnimations { forwards: TransitionAnimationPair; backwards: TransitionAnimationPair; } ``` The following example shows all the necessary properties to define a custom `bump` animation inside a `<style is:global>` tag in your root layout file: src/layouts/Layout.astro ```astro --- import { ClientRouter } from "astro:transitions"; --- <html lang="en"> <head> <ClientRouter /> </head> <body> <slot /> </body> </html> <style is:global> @keyframes bump { 0% { opacity: 0; transform: scale(1) translateX(200px); } 50% { opacity: 0.5; transform: scale(1.1); } 100% { opacity: 1; transform: scale(1) translateX(0); } } </style> ``` The animation‚Äôs behavior must be defined in the frontmatter of every component using the animation: src/pages/index.astro ```astro --- const anim = { old: { name: "bump", duration: "0.5s", easing: "ease-in", direction: "reverse", }, new: { name: "bump", duration: "0.5s", easing: "ease-in-out", }, }; const customTransition = { forwards: anim, backwards: anim, }; --- <header transition:animate={customTransition}> ... </header> ``` You have great flexibility when defining custom animations. To achieve your desired result, you may wish to consider unusual combinations such as using different objects for forward and backward, or providing separate keyframe animations for old and new. ## Router control [Section titled ‚ÄúRouter control‚Äù](#router-control) The `<ClientRouter />` router handles navigation by listening to: * Clicks on `<a>` elements. * Backwards and forwards navigation events. The following options allow you to further control when navigation occurs within the router: * `data-astro-reload`: an `<a>` tag attribute to [force a full-page navigation](#preventing-client-side-navigation) * `data-astro-history="auto | push | replace"`: an `<a>` tag attribute to [control the browser‚Äôs history](#replace-entries-in-the-browser-history) * `navigate(href, options)`: a method available to any client script or client component to [trigger navigation](#trigger-navigation) ### Preventing client-side navigation [Section titled ‚ÄúPreventing client-side navigation‚Äù](#preventing-client-side-navigation) There are some cases where you cannot navigate via client-side routing since both pages involved must use the `<ClientRouter />` router to prevent a full-page reload. You may also not want client-side routing on every navigation change and would prefer a traditional page navigation on select routes instead. You can opt out of client-side routing on a per-link basis by adding the `data-astro-reload` attribute to any `<a>` or `<form>` tag. This attribute will override any existing `<ClientRouter />` component and instead trigger a browser refresh during navigation. The following example shows preventing client-side routing when navigating to an article from the home page only. This still allows you to have animation on shared elements, such as a hero image, when navigating to the same page from an article listing page: src/pages/index.astro ```astro <a href="/articles/emperor-penguins" data-astro-reload> ``` src/pages/articles.astro ```astro <a href="/articles/emperor-penguins"> ``` Links with the `data-astro-reload` attribute will be ignored by the router and a full-page navigation will occur. ### Trigger navigation [Section titled ‚ÄúTrigger navigation‚Äù](#trigger-navigation) You can also trigger client-side navigation via events not normally listened to by the `<ClientRouter />` router using [`navigate()`](/en/reference/modules/astro-transitions/#navigate). This function from the `astro:transitions/client` module can be used in scripts, and in framework components that are hydrated with a [client directive](/en/reference/directives-reference/#client-directives). The following example shows an Astro component that navigates a visitor to another page they select from a menu: src/components/Form.astro ```astro <script> import { navigate } from "astro:transitions/client"; // Navigate to the selected option automatically. document.querySelector("select").onchange = (event) => { let href = event.target.value; navigate(href); }; </script> <select> <option value="/play">Play</option> <option value="/blog">Blog</option> <option value="/about">About</option> <option value="/contact">Contact</option> </select> ``` src/pages/index.astro ```astro --- import Form from "../components/Form.astro"; import { ClientRouter } from "astro:transitions"; --- <html> <head> <ClientRouter /> </head> <body> <Form /> </body> </html> ``` The following example implements the same using `navigate()` in a React `<Form />` component: src/components/Form.jsx ```js import { navigate } from "astro:transitions/client"; export default function Form() { return ( <select onChange={(e) => navigate(e.target.value)}> <option value="/play">Play</option> <option value="/blog">Blog</option> <option value="/about">About</option> <option value="/contact">Contact</option> </select> ); } ``` The `<Form />` component can then be rendered on an Astro page that uses the `<ClientRouter />` router, with a client directive: src/pages/index.astro ```astro --- import Form from "../components/Form.jsx"; import { ClientRouter } from "astro:transitions"; --- <html> <head> <ClientRouter /> </head> <body> <Form client:load /> </body> </html> ``` For backward and forward navigation through the browser history, you can combine `navigate()` with the built-in `history.back()`, `history.forward()` and `history.go()` functions of the browser. If `navigate()` is called during the server-side render of your component, it has no effect. See the `astro:transitions` reference for more information about the [`navigate()` options](/en/reference/modules/astro-transitions/#navigate). ### Replace entries in the browser history [Section titled ‚ÄúReplace entries in the browser history‚Äù](#replace-entries-in-the-browser-history) Normally, each time you navigate, a new entry is written to the browser‚Äôs history. This allows navigation between pages using the browser‚Äôs `back` and `forward` buttons. The `<ClientRouter />` router allows you to overwrite history entries by adding the `data-astro-history` attribute to any individual `<a>` tag. The `data-astro-history` attribute can be set to the same three values as the [`history` option of the `navigate()` function](/en/reference/modules/astro-transitions/#history-option): * `"push"`: the router will use `history.pushState` to create a new entry in the browser history. * `"replace"`: the router will use `history.replaceState` to update the URL without adding a new entry into navigation. * `"auto"` (default): the router will attempt `history.pushState`, but if the URL is not one that can be transitioned to, the current URL will remain with no changes to the browser history. The following example navigates to the `/main` page but does not add a new entry to the browsing history. Instead, it reuses the current entry in the history (`/confirmation`) and overwrites it. src/pages/confirmation.astro ```astro <a href="/main" data-astro-history="replace"> ``` This has the effect that if you go back from the `/main` page, the browser will not display the `/confirmation` page, but the page before it. ### Transitions with forms [Section titled ‚ÄúTransitions with forms‚Äù](#transitions-with-forms) **Added in:** `astro@4.0.0` The `<ClientRouter />` router will trigger in-page transitions from `<form>` elements, supporting both `GET` and `POST` requests. By default, Astro submits your form data as `multipart/form-data` when your `method` is set to `POST`. If you want to match the default behavior of web browsers, use the `enctype` attribute to submit your data encoded as `application/x-www-form-urlencoded`: src/components/Form.astro ```astro <form action="/contact" method="POST" enctype="application/x-www-form-urlencoded" > ``` You can opt out of router transitions on any individual form using the `data-astro-reload` attribute: src/components/Form.astro ```astro <form action="/contact" data-astro-reload> ``` ### Navigating with user input [Section titled ‚ÄúNavigating with user input‚Äù](#navigating-with-user-input) The `navigate()` API does not perform sanitization on the URLs passed to it. If you are using user input to determine the URL to navigate to, you should validate the input before passing it to `navigate()`. For example, a `?redirect` query parameter could be used to navigate away from your site (`?redirect=http://example.com`) or to execute arbitrary code (`?redirect=javascript:alert('Evil code')`) if the value is not sanitized before use. One way to implement this safely is to ensure only a set of known paths can be redirected to: src/pages/index.astro ```astro <script> import { navigate } from 'astro:transitions/client'; const params = new URLSearchParams(window.location.search); const redirect = params.get('redirect'); const allowedPaths = ['/home', '/about', '/contact']; if (allowedPaths.includes(redirect)) { navigate(redirect); } </script> ``` The exact kind of sanitization you need will depend on your site and what you want to allow. Consider enabling Astro‚Äôs [experimental Content Security Policy feature](/en/reference/experimental-flags/csp/) to help protect against cross-site scripting (XSS) risks if using user input with the `navigate()` API. ## Fallback control [Section titled ‚ÄúFallback control‚Äù](#fallback-control) The `<ClientRouter />` router works best in browsers that support View Transitions (i.e. Chromium browsers), but also includes default fallback support for other browsers. Even if the browser does not support the View Transitions API, Astro‚Äôs client router can still provide in-browser navigation using one of the fallback options. Depending on browser support, you may need to explicitly set the `name` or `animate` [transition directives](#transition-directives) on the elements you wish to animate for a comparable experience across all browsers: src/pages/about.astro ```astro --- import Layout from "../layouts/LayoutUsingClientRouter.astro"; --- <title transition:animate="fade">About my site</title> ``` You can override Astro‚Äôs default fallback support by adding a `fallback` property on the `<ClientRouter />` component and setting it to `swap` or `none`: * `animate` (default, recommended): Astro will simulate view transitions using custom attributes before updating page content. * `swap`: Astro will not attempt to animate the page. Instead, the old page will be immediately replaced by the new one. * `none`: Astro will not do any animated page transitions at all. Instead, you will get full page navigation in non-supporting browsers. ```astro --- import { ClientRouter } from "astro:transitions"; --- <title>My site</title> <ClientRouter fallback="swap" /> ``` ## Client-side navigation process [Section titled ‚ÄúClient-side navigation process‚Äù](#client-side-navigation-process) When using the `<ClientRouter />` router, the following steps occur to produce Astro‚Äôs client-side navigation: 1. A visitor to your site triggers navigation by any of the following actions: * Clicking an `<a>` tag linking internally to another page on your site. * Clicking the back button. * Clicking the forward button. 2. The router starts fetching the next page. 3. The router adds the `data-astro-transition` attribute to the HTML element with a value of `"forward"` or `"back"` as appropriate. 4. The router calls `document.startViewTransition`. This triggers the browser‚Äôs own [view transition process](https://developer.mozilla.org/en-US/docs/Web/API/View_Transition_API/Using#the_view_transition_process). Importantly, the browser screenshots the current state of the page. 5. Inside the `startViewTransition` callback, the router performs a **swap**, which consists of the following sequence of events: * The contents of the `<head>` are swapped out, with some elements kept: * Stylesheet DOM nodes are left in if they exist on the new page, to prevent FOUC. * Scripts are left in if they exist on the new page. * Any other head elements with `transition:persist` are left in if there is a corresponding element in the new page. * The `<body>` is completely replaced with the new page‚Äôs body. * Elements marked `transition:persist` are moved over to the new DOM if they exist on the new page. * Scroll position is restored if necessary. * The `astro:after-swap` event is triggered on the `document`. This is the end of the **swap** process. 6. The router waits for any new stylesheets to load before resolving the transition. 7. The router executes any new scripts added to the page. 8. The `astro:page-load` event fires. This is the end of the navigation process. ## Script behavior with view transitions [Section titled ‚ÄúScript behavior with view transitions‚Äù](#script-behavior-with-view-transitions) When you add view transitions to an existing Astro project, some of your scripts may no longer re-run after page navigation like they did with full-page browser refreshes. Use the following information to ensure that your scripts execute as expected. ### Script order [Section titled ‚ÄúScript order‚Äù](#script-order) When navigating between pages with the `<ClientRouter />` component, scripts are run in sequential order to match browser behavior. ### Script re-execution [Section titled ‚ÄúScript re-execution‚Äù](#script-re-execution) [Bundled module scripts](/en/guides/client-side-scripts/#script-processing), which are the default scripts in Astro, are only ever executed once. After initial execution they will be ignored, even if the script exists on the new page after a transition. Unlike bundled module scripts, [inline scripts](/en/guides/client-side-scripts/#unprocessed-scripts) have the potential to be re-executed during a user‚Äôs visit to a site if they exist on a page that is visited multiple times. Inline scripts might also re-execute when a visitor navigates to a page without the script, and then back to one with the script. With view transitions, some scripts may no longer re-run after page navigation like they do with full-page browser refreshes. There are several [events during client-side routing that you can listen for](#lifecycle-events), and fire events when they occur. You can wrap an existing script in an event listener to ensure it runs at the proper time in the navigation cycle. The following example wraps a script for a mobile ‚Äúhamburger‚Äù menu in an event listener for `astro:page-load` which runs at the end of page navigation to make the menu responsive to being clicked after navigating to a new page: src/scripts/menu.js ```diff +document.addEventListener("astro:page-load", () => { document.querySelector(".hamburger").addEventListener("click", () => { document.querySelector(".nav-links").classList.toggle("expanded"); }); +}); ``` The following example shows a function that runs in response to the `astro:after-swap` event, which happens immediately after the new page has replaced the old page and before the DOM elements are painted to the screen. This avoids a flash of light mode theme after page navigation by checking and, if necessary, setting the dark mode theme before the new page is rendered: src/components/ThemeToggle.astro ```astro <script is:inline> function applyTheme() { localStorage.theme === "dark" ? document.documentElement.classList.add("dark") : document.documentElement.classList.remove("dark"); } document.addEventListener("astro:after-swap", applyTheme); applyTheme(); </script> ``` #### `data-astro-rerun` [Section titled ‚Äúdata-astro-rerun‚Äù](#data-astro-rerun) **Added in:** `astro@4.5.0` To force inline scripts to re-execute after every transition, add the `data-astro-rerun` property. Adding any attribute to a script also implicitly adds `is:inline`, so this is only available for scripts that are not bundled and processed by Astro. ```astro <script is:inline data-astro-rerun>...</script> ``` To ensure that a script runs every time a page is loaded during client-side navigation, it should be executed by a [lifecycle event](#lifecycle-events). For example, event listeners for `DOMContentLoaded` can be replaced by the [`astro:page-load`](/en/guides/view-transitions/#astropage-load) lifecycle event. If you have code that sets up a global state in an inline script, this state will need to take into account that the script might execute more than once. Check for the global state in your `<script>` tag, and conditionally execute your code where possible. This works because `window` is preserved. ```astro <script is:inline> if (!window.SomeGlobal) { window.SomeGlobal = {}; } </script> ``` ## Lifecycle events [Section titled ‚ÄúLifecycle events‚Äù](#lifecycle-events) The `<ClientRouter />` router fires a number of events on the `document` during navigation. These events provide hooks into the lifecycle of navigation, allowing you to do things like show indicators that a new page is loading, override default behavior, and restore state as navigation is completing. The navigation process involves a **preparation** phase, when new content is loaded; a **DOM swap** phase, where the old page‚Äôs content is replaced by the new page‚Äôs content; and a **completion** phase where scripts are executed, loading is reported as completed and clean-up work is carried out. Astro‚Äôs View Transition API lifecycle events in order are: * [`astro:before-preparation`](#astrobefore-preparation) * [`astro:after-preparation`](#astroafter-preparation) * [`astro:before-swap`](#astrobefore-swap) * [`astro:after-swap`](#astroafter-swap) * [`astro:page-load`](#astropage-load) While some actions can be triggered during any event, some tasks can only be performed during a specific event for best results, such as displaying a loading spinner before preparation or overriding animation pairs before swapping content. ### `astro:before-preparation` [Section titled ‚Äúastro:before-preparation‚Äù](#astrobefore-preparation) **Added in:** `astro@3.6.0` An event that fires at the beginning of the preparation phase, after navigation has started (e.g. after the user has clicked a link), but before content is loaded. This event is used: * To do something before loading has started, such as showing a loading spinner. * To alter loading, such as loading content you‚Äôve defined in a template rather than from the external URL. * To change the `direction` of the navigation (which is usually either `forward` or `backward`) for custom animation. Here is an example of using the `astro:before-preparation` event to load a spinner before the content is loaded and stop it immediately after loading. Note that using the [`loader` callback](/en/reference/modules/astro-transitions/#loader) in this way allows asynchronous execution of code. ```astro <script is:inline> document.addEventListener("astro:before-preparation", (event) => { const originalLoader = event.loader; event.loader = async function () { const { startSpinner } = await import("./spinner.js"); const stop = startSpinner(); await originalLoader(); stop(); }; }); </script> ``` ### `astro:after-preparation` [Section titled ‚Äúastro:after-preparation‚Äù](#astroafter-preparation) **Added in:** `astro@3.6.0` An event that fires at the end of the preparation phase, after the new page‚Äôs content has been loaded and parsed into a document. This event occurs before the view transitions phase. This example uses the `astro:before-preparation` event to start a loading indicator and the `astro:after-preparation` event to stop it: ```astro <script is:inline> document.addEventListener("astro:before-preparation", () => { document.querySelector("#loading").classList.add("show"); }); document.addEventListener("astro:after-preparation", () => { document.querySelector("#loading").classList.remove("show"); }); </script> ``` This is a simpler version of loading a spinner than the example shown above: if all of the listener‚Äôs code can be executed synchronously, there is no need to hook into the `loader` callback. ### `astro:before-swap` [Section titled ‚Äúastro:before-swap‚Äù](#astrobefore-swap) **Added in:** `astro@3.6.0` An event that fires before the new document (which is populated during the preparation phase) replaces the current document. This event occurs inside of the view transition, where the user is still seeing a snapshot of the old page. This event can be used to make changes before the swap occurs. The `newDocument` property on the event represents the incoming document. Here is an example of ensuring the browser‚Äôs light or dark mode preference in `localStorage` is carried over to the new page: ```astro <script> document.addEventListener("astro:before-swap", (event) => { event.newDocument.documentElement.dataset.theme = localStorage.getItem("darkMode") ? "dark" : "light"; }); </script> ``` The `astro:before-swap` event can also be used to change the *implementation* of the swap. The default swap implementation diffs head content, moves **persistent** elements from the old document to the `newDocument`, and then replaces the entire `body` with the body of the new document. At this point of the lifecycle, you could choose to define your own swap implementation, for example to diff the entire contents of the existing document (which some other routers do): ```astro <script is:inline> document.addEventListener("astro:before-swap", (event) => { event.swap = () => { diff(document, event.newDocument); }; }); </script> ``` #### Building a custom swap function [Section titled ‚ÄúBuilding a custom swap function‚Äù](#building-a-custom-swap-function) **Added in:** `astro@4.15.0` The [`swapFunctions` object](/en/reference/modules/astro-transitions/#swapfunctions) of the `astro:transitions/client` module provides five utility functions that handle specific swap-related tasks, including handling document attributes, page elements, and script execution. These functions can be used directly to define a custom swap implementation. The following example demonstrates how to use these functions to recreate Astro‚Äôs built-in swap implementation: ```astro <script> import { swapFunctions } from "astro:transitions/client"; // substitutes `window.document` with `doc` function mySwap(doc: Document) { swapFunctions.deselectScripts(doc); swapFunctions.swapRootAttributes(doc); swapFunctions.swapHeadElements(doc); const restoreFocusFunction = swapFunctions.saveFocus(); swapFunctions.swapBodyElement(doc.body, document.body); restoreFocusFunction(); } document.addEventListener("astro:before-swap", (event) => { event.swap = () => mySwap(event.newDocument); }); <script> ``` Custom swap implementations can start with this template and add or replace individual steps with custom logic as needed. ### `astro:after-swap` [Section titled ‚Äúastro:after-swap‚Äù](#astroafter-swap) An event that fires immediately after the new page replaces the old page. You can listen to this event on the `document` and trigger actions that will occur before the new page‚Äôs DOM elements render and scripts run. This event, when listened to on the **outgoing page**, is useful to pass along and restore any state on the DOM that needs to transfer over to the new page. This is the latest point in the lifecycle where it is still safe to, for example, add a dark mode class name (`<html class="dark-mode">`), though you may wish to do so in an earlier event. The `astro:after-swap` event occurs immediately after the browser history has been updated and the scroll position has been set. Therefore, one use of targeting this event is to override the default scroll restore for history navigation. The following example resets the horizontal and vertical scroll position to the top left corner of the page for each navigation. ```js document.addEventListener("astro:after-swap", () => window.scrollTo({ left: 0, top: 0, behavior: "instant" }), ); ``` ### `astro:page-load` [Section titled ‚Äúastro:page-load‚Äù](#astropage-load) An event that fires at the end of page navigation, after the new page is visible to the user and blocking styles and scripts are loaded. You can listen to this event on the `document`. The `<ClientRouter />` component fires this event both on initial page navigation for a pre-rendered page and on any subsequent navigation, either forwards or backwards. You can use this event to run code on every page navigation, for example to set up event listeners that would otherwise be lost during navigation. ```astro <script> document.addEventListener("astro:page-load", () => { // This runs on first page load and after every navigation. setupStuff(); // e.g. add event listeners }); </script> ``` ## Accessibility [Section titled ‚ÄúAccessibility‚Äù](#accessibility) Enabling client-side routing and animating page transitions both come with accessibility challenges, and Astro aims to make sites opting in to View Transitions as accessible-by-default as possible. ### Route announcement [Section titled ‚ÄúRoute announcement‚Äù](#route-announcement) **Added in:** `astro@3.2.0` The `<ClientRouter />` component includes a route announcer for page navigation during client-side routing. No configuration or action is needed to enable this. Assistive technologies let visitors know that the page has changed by announcing the new page title after navigation. When using server-side routing with traditional full-page browser refreshes, this happens by default after the new page loads. In client-side routing, the `<ClientRouter />` component performs this action. To add route announcement to client-side routing, the component adds an element to the new page with the `aria-live` attribute set to `assertive`. This tells AT (assistive technology) to announce immediately. The component also checks for the following, in priority order, to determine the announcement text: * The `<title>`, if it exists. * The first `<h1>` it finds. * The `pathname` of the page. We strongly recommend you always include a `<title>` in each page for accessibility. ### `prefers-reduced-motion` [Section titled ‚Äúprefers-reduced-motion‚Äù](#prefers-reduced-motion) Astro‚Äôs `<ClientRouter />` component includes a CSS media query that disables *all* view transition animations, including fallback animation, whenever the [`prefers-reduced-motion`](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/prefers-reduced-motion) setting is detected. Instead, the browser will simply swap the DOM elements without an animation.

# Upgrade Astro

> Learn how to upgrade Astro

This guide covers how to update your version of Astro and related dependencies, how to learn what has changed from one version to the next, and how to understand Astro‚Äôs versioning system and corresponding documentation updates. ## What has changed? [Section titled ‚ÄúWhat has changed?‚Äù](#what-has-changed) The latest release of Astro is v5.17.1. You can find an exhaustive list of all changes in [Astro‚Äôs changelog](https://github.com/withastro/astro/blob/main/packages/astro/CHANGELOG.md), and important instructions for upgrading to each new [major version](#major-changes) in our [upgrade guides](#upgrade-guides). ## Upgrade to the latest version [Section titled ‚ÄúUpgrade to the latest version‚Äù](#upgrade-to-the-latest-version) Update your project‚Äôs version of Astro and all official integrations to the latest versions with one command using your package manager: * npm ```shell # Upgrade Astro and official integrations together npx @astrojs/upgrade ``` * pnpm ```shell # Upgrade Astro and official integrations together pnpm dlx @astrojs/upgrade ``` * Yarn ```shell # Upgrade Astro and official integrations together yarn dlx @astrojs/upgrade ``` ### Manual Upgrading [Section titled ‚ÄúManual Upgrading‚Äù](#manual-upgrading) To update Astro and integrations to their current versions manually, use the appropriate command for your package manager. * npm ```shell # Example: upgrade Astro with React and Partytown integrations npm install astro@latest @astrojs/react@latest @astrojs/partytown@latest ``` * pnpm ```shell # Example: upgrade Astro with React and Partytown integrations pnpm add astro@latest @astrojs/react@latest @astrojs/partytown@latest ``` * Yarn ```shell # Example: upgrade Astro with React and Partytown integrations yarn add astro@latest @astrojs/react@latest @astrojs/partytown@latest ``` ### Install a specific version number [Section titled ‚ÄúInstall a specific version number‚Äù](#install-a-specific-version-number) To install a specific [version of Astro](https://www.npmjs.com/package/astro?activeTab=versions) or integrations, use the appropriate command for your package manager. * npm ```shell npm install astro@4.5.3 @astrojs/react@3.0.10 ``` * pnpm ```shell pnpm add astro@4.5.3 @astrojs/react@3.0.10 ``` * Yarn ```shell yarn add astro@4.5.3 @astrojs/react@3.0.10 ``` ## Documentation updates [Section titled ‚ÄúDocumentation updates‚Äù](#documentation-updates) This documentation is updated for each [minor release](#minor-changes) and [major version release](#major-changes). When new features are added, or existing usage changes, the docs will update to reflect the **current behavior of Astro**. If your project is not updated, then you may notice some behaviors do not match the up-to-date documentation. New features are added to docs with the specific version number in which they were added. This means that if you have not updated to the latest release of Astro, some documented features may be unavailable. Always check the `Added in:` version number and make sure your project is updated before attempting to use new features! If you have not upgraded to the latest major version of Astro, you may encounter significant differences between the Astro documentation and your project‚Äôs behavior. We strongly recommend upgrading to the current major version of Astro as soon as you are able. Both the code and the documentation for earlier versions is unsupported. ### Upgrade Guides [Section titled ‚ÄúUpgrade Guides‚Äù](#upgrade-guides) After every [major version release](#major-changes), you will find an **upgrade guide** with information about important changes and instructions for upgrading your project code. The main Astro documentation pages are always **accurate for the latest released version of Astro**. They do not describe or compare to how things worked in previous versions, nor do they highlight updated or changed behavior. See the upgrade guides below for an explanation of changes, comparing the new version to the old. The upgrade guides include everything that could require you to change your own code: breaking changes, deprecations, feature removals and replacements as well as updated usage guidance. Each change to Astro includes a ‚ÄúWhat should I do?‚Äù section to help you successfully update your project code. * [Upgrade to v5](/en/guides/upgrade-to/v5/) * [Upgrade to v4](/en/guides/upgrade-to/v4/) * [Upgrade to v3](/en/guides/upgrade-to/v3/) * [Upgrade to v2](/en/guides/upgrade-to/v2/) * [Upgrade to v1](/en/guides/upgrade-to/v1/) ### Older docs (unmaintained) [Section titled ‚ÄúOlder docs (unmaintained)‚Äù](#older-docs-unmaintained) Documentation for older versions of Astro is not maintained, but is available as a static snapshot. Use these versions of docs if you are unable to upgrade your project, but still wish to consult guides and reference: * [unmaintained v4.16.17 snapshot](https://v4.docs.astro.build/en/getting-started/) * [unmaintained v3.6.3 snapshot](https://web.archive.org/web/20231203051122/https://docs.astro.build/en/getting-started/) * [unmaintained v2.10.15 snapshot](https://web.archive.org/web/20230822134745/https://docs.astro.build/en/getting-started) ## Semantic versioning [Section titled ‚ÄúSemantic versioning‚Äù](#semantic-versioning) Astro attempts to adhere as much as possible to [semantic versioning](https://semver.org/), which is a set of rules developers use to determine how to assign a version number to a release. Semantic version follows a predictable pattern to inform users of the kind of changes they can expect from one version to the next. Semantic versioning enforces a pattern of `X.Y.Z` for software version numbers. These values represent **major (X)**, **minor (Y)**, and **patch (Z)** updates. ### Patch changes [Section titled ‚ÄúPatch changes‚Äù](#patch-changes) Patch changes are the least disruptive changes. They do not change the way you use Astro, and no change to your own code is required when you update. When Astro issues a ‚Äúpatch‚Äù version, the last number increases. (e.g. `astro@4.3.14` -> `astro@4.3.15`) Patches may be released for reasons such as: * Internal changes that do not change Astro‚Äôs functionality: * refactors * performance improvements * increase or change in test coverage * aligning with stated documentation and expected behavior * Improvements to logging and error messages. * Re-releases after a failed release. Patch changes also include **most bug fixes**, even in cases where users were taking advantage of existing unintended or undesirable behavior. ### Minor changes [Section titled ‚ÄúMinor changes‚Äù](#minor-changes) Minor releases primarily introduce new features and improvements that you may wish to try, but require no changes to your code. Some existing features may also be **deprecated** (marked for deletion in a future version while continuing to function) in a minor release, giving you the opportunity to prepare for their eventual removal. Minor releases include changes such as: * **Deprecations** of existing features/options with a warning that they will be removed in an upcoming major release. * Introduction of new functionalities. * Introduction of new options in the integration hooks. * Introduction of new functionalities in `astro/app`, notably used for creating new adapters. A minor release may also include smaller, patch changes at the same time. ### Major changes [Section titled ‚ÄúMajor changes‚Äù](#major-changes) Major releases will include breaking changes to at least some existing code. These breaking changes are always documented in an [‚ÄúUpgrade to vX‚Äù guide](#upgrade-guides) in Astro. Major releases allow Astro to make significant changes not only to internal logic, but also to intended behavior and usage. Documentation will be updated to reflect the latest version only, and **static, unmaintained snapshots of older docs** are available as a historical record for older projects that are not yet upgraded. Major releases include changes such as: * Removal of previously deprecated functionalities. * Changes of existing functionalities. * Changes of existing options in the integration hooks. * Changes of existing options and functionalities in `astro/app`, notably used for creating new adapters. A major release may also include some non-breaking changes and improvements that would normally be released separately in a minor or patch release. ### Exceptions [Section titled ‚ÄúExceptions‚Äù](#exceptions) * **Experimental features**. Releasing versions of Astro without adhering to semantic versioning allows Astro developers the greatest flexibility to explore, and even radically change course, during the development of experimental features. Therefore, the behavior of these features can break in minor and patch changes. These features are usually accompanied by an ongoing, public [Request for Consideration (RFC) stage 3](https://github.com/withastro/roadmap#stage-3-rfc--development). It is expected that beta users will follow for updates, and leave early feedback on the discussion to help guide development of these features. Once these features are out of their experimental period, they will follow the normal semantic versioning contract. * **Improvements to the documentation** (e.g. reference and error messages). They are built from source for the `docs` repository. This allows Astro to quickly update docs fixes and improvements in the cases where documentation source content is stored in the main `astro` repository. ### Node.js support and upgrade policies [Section titled ‚ÄúNode.js support and upgrade policies‚Äù](#nodejs-support-and-upgrade-policies) #### Support [Section titled ‚ÄúSupport‚Äù](#support) * Astro supports the [**latest *Maintenance* LTS** version of Node.js](https://nodejs.org/en/about/previous-releases#release-schedule). * Astro supports the [**current *Active* LTS** version of Node.js](https://nodejs.org/en/about/previous-releases#release-schedule) * Astro can support odd versions of Node.js. #### Upgrade [Section titled ‚ÄúUpgrade‚Äù](#upgrade) The following rules define when Astro may deprecate, drop, or add support for versions of Node.js: * Odd versions of Node.js can be deprecated and/or dropped when the next even version of Node.js published. This change can occur in a **minor** release of Astro, after a reasonable period of extended support as decided by the Astro Core team. * Upgrading the minimum ***Maintenance* LTS** (within the same major range, e.g. from `v18.14.*` to `v18.20.*`) version of Node.js can occur in a **minor** release of Astro. * Security exception: If a security flaw in Node.js that **affects Astro** is disclosed and fixed, the Core team can bump the minimum version of the ***Maintenance* LTS** in a **patch** release. * Upgrading minor or major versions of Node.js (**not** Maintenance LTS) occurs only in major versions of Astro. * Security exception: If a security flaw in Node.js that **affects Astro** is disclosed and fixed, the Core team can bump the minimum version in a **minor** release. ### Extended maintenance [Section titled ‚ÄúExtended maintenance‚Äù](#extended-maintenance) The Core team will provide extended maintenance **for security fixes only** for one previous major version. This means that if the current major is `v4.*`, the Core team will back port security fixes and issue a new `v3.*` release.